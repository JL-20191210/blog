<!doctype html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.17" />
    <meta name="theme" content="VuePress Theme Hope 2.0.0-rc.58" />
    <style>
      :root {
        --vp-c-bg: #fff;
      }

      [data-theme="dark"] {
        --vp-c-bg: #1b1b1f;
      }

      html,
      body {
        background: var(--vp-c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.documentElement.setAttribute("data-theme", "dark");
      }
    </script>
    <title>Redis面试题A货 | 小满</title><meta name="description" content="小满的知识库">
    <link rel="stylesheet" href="/blog/assets/css/styles.6c7a3e47.css">
    <link rel="preload" href="/blog/assets/js/runtime~app.5b07cc97.js" as="script"><link rel="preload" href="/blog/assets/css/styles.6c7a3e47.css" as="style"><link rel="preload" href="/blog/assets/js/12710.15d38a93.js" as="script"><link rel="preload" href="/blog/assets/js/app.f955c049.js" as="script">
    <link rel="prefetch" href="/blog/assets/js/Interview_sanfene_redis.html.0286c4ae.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_sanfene_Java线程.html.24f761b0.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_Java_03-Java并发编程面试题_3.Java线程.html.f9ba31c8.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_Java_07-Redis面试题_7.Redis面试题B.html.c45db3f4.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_Java_06-MySQL面试题_6.MySQL面试题A.html.c71d7a66.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_sanfene_mysql.html.c8d93c72.js" as="script"><link rel="prefetch" href="/blog/assets/js/Java_入门到起飞_31.多线程_juc额外扩展资料_多线程（额外扩展）.html.cff3053c.js" as="script"><link rel="prefetch" href="/blog/assets/js/Database_Redis_2.实战_Redis实战篇.html.d98fbee2.js" as="script"><link rel="prefetch" href="/blog/assets/js/Database_Redis_2.实战_Redis实战篇-在线.html.88494933.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_Java_05-Spring面试题_5.SpringA.html.9c0a92a2.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_sanfene_spring.html.68f15681.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_Java_05-Spring面试题_5.SpringB.html.06f2de46.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_MySQL_MySQL面渣84.html.475a0f87.js" as="script"><link rel="prefetch" href="/blog/assets/js/SSM_03-Maven高级笔记_POM文件帮助文档.html.44fa84a5.js" as="script"><link rel="prefetch" href="/blog/assets/js/SSM_02-SpringMVC笔记_SpringMVC_day01_SpringMVC_day01.html.df4052b6.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_sanfene_Java基础.html.5eb5f678.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_Java_01-Java基础面试题_1.Java基础面试题A.html.e6491872.js" as="script"><link rel="prefetch" href="/blog/assets/js/Netty_01Netty-nio.html.276942d9.js" as="script"><link rel="prefetch" href="/blog/assets/js/SSM_02-SpringMVC笔记_SpringMVC_day02_SpringMVC_day02.html.de0be868.js" as="script"><link rel="prefetch" href="/blog/assets/js/Netty_04Netty-优化与源码.html.5e97573a.js" as="script"><link rel="prefetch" href="/blog/assets/js/SSM_01-Spring笔记_spring_day03_Spring_day03.html.46a9fef8.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_Java_03-Java并发编程面试题_3.Java并发编程面试题.html.e7754c15.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_Spring_Spring面试题41.html.f0c65c41.js" as="script"><link rel="prefetch" href="/blog/assets/js/SSM_05-Mybatisplus笔记_MyBatisPlus.html.0608d881.js" as="script"><link rel="prefetch" href="/blog/assets/js/Netty_03Netty-进阶.html.6fc84fce.js" as="script"><link rel="prefetch" href="/blog/assets/js/Java_入门到起飞_31.多线程_多线程02.html.cd02eee1.js" as="script"><link rel="prefetch" href="/blog/assets/js/Mybatis_Mybatis Plus_Mybatis Plus笔记.html.9365922f.js" as="script"><link rel="prefetch" href="/blog/assets/js/Linux_0.笔记_Linux系统软件安装.html.a03ba364.js" as="script"><link rel="prefetch" href="/blog/assets/js/SSM_01-Spring笔记_spring_day02_Spring_day02.html.c569030a.js" as="script"><link rel="prefetch" href="/blog/assets/js/SSM_01-Spring笔记_spring_day01_Spring_day01.html.3ac3f14a.js" as="script"><link rel="prefetch" href="/blog/assets/js/Netty_02Netty-入门.html.8e52bd7b.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_Java_01-Java基础面试题_1.Java基础面试题.html.524a21fc.js" as="script"><link rel="prefetch" href="/blog/assets/js/Java_入门到起飞_35.反射_动态代理_35.反射_动态代理.html.dbc8eee0.js" as="script"><link rel="prefetch" href="/blog/assets/js/Database_Redis_3.高级_02-多级缓存_多级缓存.html.1b77c902.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_sanfene_jvm.html.5b423363.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_Java_04-Java虚拟机面试题_4.JVM.html.59b5bfa0.js" as="script"><link rel="prefetch" href="/blog/assets/js/MQ_RabbitMQ_基础_MQ基础.html.41390359.js" as="script"><link rel="prefetch" href="/blog/assets/js/SSM_03-Maven高级笔记_Maven高级.html.270538a7.js" as="script"><link rel="prefetch" href="/blog/assets/js/Database_MySQL_MySQL学习笔记_MySQL学习笔记.html.17191d56.js" as="script"><link rel="prefetch" href="/blog/assets/js/SpringCloud_实用_ES_讲义-分布式搜索引擎02.html.2366ab43.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_Java_06-MySQL面试题_6.MySQL面试题.html.3873e670.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_Java_07-Redis面试题_7.Redis面试题A.html.94f2e464.js" as="script"><link rel="prefetch" href="/blog/assets/js/Java_入门到起飞_31.多线程_多线程01.html.13b4dd82.js" as="script"><link rel="prefetch" href="/blog/assets/js/Database_Redis_1.入门_Redis基础篇.html.84d95a80.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_sanfene_mybatis.html.48f5c337.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_Java_05-Spring面试题_5.Spring面试题.html.2a5749c3.js" as="script"><link rel="prefetch" href="/blog/assets/js/Java_入门到起飞_26.集合（Stream流_方法引用）_stream流和方法引用.html.e6e8148c.js" as="script"><link rel="prefetch" href="/blog/assets/js/MQ_RabbitMQ_高级_MQ高级.html.4dc62c19.js" as="script"><link rel="prefetch" href="/blog/assets/js/Database_MySQL_进阶_笔记-进阶篇.html.38ebd1f1.js" as="script"><link rel="prefetch" href="/blog/assets/js/SSM_04-SpringBoot笔记_SpringBoot.html.c516c238.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_sanfene_Java集合框架.html.634f2c90.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_Java_02-Java集合面试题_2.Java集合框架篇A.html.3468ff92.js" as="script"><link rel="prefetch" href="/blog/assets/js/SpringCloud_实用_ES_讲义-分布式搜索引擎01.html.fa8a2050.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_Java_02-Java集合面试题_2.Java集合面试题.html.ba16f2b4.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_sanfene_network.html.057aa6a7.js" as="script"><link rel="prefetch" href="/blog/assets/js/Database_MySQL_MyCat配置文件_schema.html.f95b551b.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_黑马Java2021_04框架篇_框架篇讲义.html.12c9ea05.js" as="script"><link rel="prefetch" href="/blog/assets/js/装机_Intel桌面处理器规格.html.81a8384a.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_黑马Java2021_01基础篇_基础篇讲义.html.fd1648ce.js" as="script"><link rel="prefetch" href="/blog/assets/js/Database_MySQL_基础_多表查询演示.html.052f61a3.js" as="script"><link rel="prefetch" href="/blog/assets/js/SpringBoot_日志框架_Spring Boot 整合 Log4j2.html.867c0721.js" as="script"><link rel="prefetch" href="/blog/assets/js/Database_Redis_4.原理_原理篇.html.4ffa6e0a.js" as="script"><link rel="prefetch" href="/blog/assets/js/SpringCloud_实用_MQ_RabbitMQ.html.108944c0.js" as="script"><link rel="prefetch" href="/blog/assets/js/Java_入门到起飞_15.面向对象进阶（抽象类_接口_内部类）_day03笔记.html.97de14fd.js" as="script"><link rel="prefetch" href="/blog/assets/js/SSM_01-Spring笔记_AOP_性能监控切面.html.4c8c8c80.js" as="script"><link rel="prefetch" href="/blog/assets/js/Database_Redis_3.高级_03-Redis最佳实践_Redis高级篇之最佳实践.html.1753eedd.js" as="script"><link rel="prefetch" href="/blog/assets/js/SpringCloud_高级_Sentinel_微服务保护.html.750efdda.js" as="script"><link rel="prefetch" href="/blog/assets/js/Database_MySQL_基础_约束及多表关系演示.html.7ee11563.js" as="script"><link rel="prefetch" href="/blog/assets/js/SpringCloud_高级_分布式事务_分布式事务.html.e33d05cd.js" as="script"><link rel="prefetch" href="/blog/assets/js/Java_入门到起飞_23.集合（泛型_Set_数据结构)_集合02.html.c4c2e2e3.js" as="script"><link rel="prefetch" href="/blog/assets/js/Java_入门到起飞_22.集合（List集合）_集合01.html.f67fe261.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_sanfene_rocketmq.html.00a75ed1.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_sanfene_设计模式.html.30be772a.js" as="script"><link rel="prefetch" href="/blog/assets/js/Python_基础_核心数据类型.html.1dbd881a.js" as="script"><link rel="prefetch" href="/blog/assets/js/装机_AMD桌面处理器规格.html.754a9807.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_sanfene_微服务.html.f3b3ce52.js" as="script"><link rel="prefetch" href="/blog/assets/js/Database_MySQL_基础_多表查询案例演示.html.132ba5cc.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_sanfene_os.html.b9ad3efc.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_Spring_Spring面试题分析及总结.html.760df3b6.js" as="script"><link rel="prefetch" href="/blog/assets/js/Database_MySQL_运维_运维篇.html.01f09e6c.js" as="script"><link rel="prefetch" href="/blog/assets/js/SpringCloud_实用_Docker_Docker实用篇.html.c1a71cac.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_Java_04-Java虚拟机面试题_4.Java虚拟机面试题.html.77780649.js" as="script"><link rel="prefetch" href="/blog/assets/js/SpringCloud_高级_Seata_seata的部署和集成.html.1df967b9.js" as="script"><link rel="prefetch" href="/blog/assets/js/Database_MySQL_MyCat配置文件_rule.html.837d67e4.js" as="script"><link rel="prefetch" href="/blog/assets/js/Database_Redis_课前资料_Redis集群.html.8aaba09c.js" as="script"><link rel="prefetch" href="/blog/assets/js/Database_Redis_随笔_什么是跳表.html.8493aeea.js" as="script"><link rel="prefetch" href="/blog/assets/js/Linux_8.Shell与脚本编程_Shell编程.html.1186d432.js" as="script"><link rel="prefetch" href="/blog/assets/js/Vue_表单验证.html.1d4b13b9.js" as="script"><link rel="prefetch" href="/blog/assets/js/Database_MySQL_基础_函数演示.html.589318d7.js" as="script"><link rel="prefetch" href="/blog/assets/js/SpringCloud_实用_ES_4.安装elasticsearch.html.569661db.js" as="script"><link rel="prefetch" href="/blog/assets/js/Java_Java8特性_Java Stream API.html.59cbd40f.js" as="script"><link rel="prefetch" href="/blog/assets/js/Java_Java8特性_函数式接口.html.e3311c0c.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_MySQL_MySQL高频60.html.31eb5551.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_Java_08-数据结构面试题_8.数据结构面试题.html.32fb4218.js" as="script"><link rel="prefetch" href="/blog/assets/js/Database_MySQL_基础_笔记-基础篇.html.4effae1b.js" as="script"><link rel="prefetch" href="/blog/assets/js/Python_爬虫_样例.html.b82eb27f.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_面试准备_京东面试题准备.html.0ffc41c4.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_Java_A基础_1.补充- FST框架使用.html.ba8ada39.js" as="script"><link rel="prefetch" href="/blog/assets/js/Java_面试题_1.补充- FST框架使用.html.f0f1903a.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_MySQL_MySQL高频60-优化版.html.ac02e604.js" as="script"><link rel="prefetch" href="/blog/assets/js/Spring_注解_@ControllerAdvice.html.b6affcf2.js" as="script"><link rel="prefetch" href="/blog/assets/js/Java_Java8特性_深入理解 Stream API.html.6c954c8f.js" as="script"><link rel="prefetch" href="/blog/assets/js/60849.39f42502.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_Java_09-MQ面试题_RabbitMQ面试题A.html.93f202d8.js" as="script"><link rel="prefetch" href="/blog/assets/js/Database_Redis_3.高级_01-分布式缓存_Redis高级-分布式缓存.html.d5c815f6.js" as="script"><link rel="prefetch" href="/blog/assets/js/48300.3ee19ba5.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_Java_10-分布式_分布式.html.2b2b5160.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_sanfene_分布式.html.bcd4e92c.js" as="script"><link rel="prefetch" href="/blog/assets/js/Netty_Channel.html.3214a737.js" as="script"><link rel="prefetch" href="/blog/assets/js/34214.fa3e0c09.js" as="script"><link rel="prefetch" href="/blog/assets/js/Database_Redis_课前资料_案例导入说明.html.ffb85e6d.js" as="script"><link rel="prefetch" href="/blog/assets/js/Linux_13.服务与自动化管理_Linux 服务器性能查看命令.html.d2882089.js" as="script"><link rel="prefetch" href="/blog/assets/js/Database_MySQL_MyCat配置文件_server.html.36a775fa.js" as="script"><link rel="prefetch" href="/blog/assets/js/Database_MySQL_基础_函数.html.7ad0084b.js" as="script"><link rel="prefetch" href="/blog/assets/js/SpringMVC_校验_Hibernate Validator.html.f1e24450.js" as="script"><link rel="prefetch" href="/blog/assets/js/Java_Java8特性_深入理解 Java Collector.html.93b373f6.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_sanfene_netty.html.0112b144.js" as="script"><link rel="prefetch" href="/blog/assets/js/项目实战_谷粒商城_板书_数据校验.html.7a04b0b6.js" as="script"><link rel="prefetch" href="/blog/assets/js/Docker_私有云_玩客云.html.dbed3c70.js" as="script"><link rel="prefetch" href="/blog/assets/js/SSM_01-Spring笔记_AOP_入参处理切面.html.6e62afae.js" as="script"><link rel="prefetch" href="/blog/assets/js/设计模式_A创建型_b工厂模式.html.33521137.js" as="script"><link rel="prefetch" href="/blog/assets/js/Mybatis_Mybatis Plus_注解_@TableField.html.4ff8f1fe.js" as="script"><link rel="prefetch" href="/blog/assets/js/SpringMVC_校验_自定义校验.html.86bf2a0c.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_黑马Java2023_08并发编程_01基础知识_8.notify()和 notifyAll()有什么区别.html.9b0c7031.js" as="script"><link rel="prefetch" href="/blog/assets/js/SSM_01-Spring笔记_AOP_基于注解的 AOP 日志切面.html.ac07279f.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_Java_A基础_3.扩展-异常处理注意点.html.f523009a.js" as="script"><link rel="prefetch" href="/blog/assets/js/Java_面试题_3.扩展-异常处理注意点.html.83bdbb12.js" as="script"><link rel="prefetch" href="/blog/assets/js/Database_Redis_课前资料_安装OpenResty.html.74f44156.js" as="script"><link rel="prefetch" href="/blog/assets/js/Mybatis_Mybatis Plus_接口_MetaObjectHandler接口文档.html.12c341a2.js" as="script"><link rel="prefetch" href="/blog/assets/js/Java_队列_ArrayDeque.html.ed65786d.js" as="script"><link rel="prefetch" href="/blog/assets/js/Database_MySQL_基础_事务操作演示.html.ac44426f.js" as="script"><link rel="prefetch" href="/blog/assets/js/Linux_0.笔记_Linux课程笔记.html.f475d1ec.js" as="script"><link rel="prefetch" href="/blog/assets/js/SpringCloud_实用_ES_8.常见查询类型.html.dd7ad357.js" as="script"><link rel="prefetch" href="/blog/assets/js/SpringCloud_实用_Docker_Centos7安装Docker.html.dcfc0e64.js" as="script"><link rel="prefetch" href="/blog/assets/js/emoji.html.a51767b6.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_黑马Java2021_03虚拟机_虚拟机篇讲义.html.5e662b5a.js" as="script"><link rel="prefetch" href="/blog/assets/js/Spring_注解_@InitBinder.html.dfb600fd.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_Java_A基础_17.JDK动态代理和CGLIB动态代理有什么区别.html.5e3242d9.js" as="script"><link rel="prefetch" href="/blog/assets/js/Java_面试题_17.JDK动态代理和CGLIB动态代理有什么区别.html.5d94d59a.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_黑马Java2023_08并发编程_01基础知识_10. 如何停止一个正在运行的线程.html.9d91be3d.js" as="script"><link rel="prefetch" href="/blog/assets/js/Java_Java8特性_深入理解 Java 中的默认方法和静态方法.html.4407513d.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_sanfene_linux.html.0f3075e4.js" as="script"><link rel="prefetch" href="/blog/assets/js/项目实战_谷粒商城_报错记录_测试方法启动空指针.html.8f332f7d.js" as="script"><link rel="prefetch" href="/blog/assets/js/设计模式_代理模式.html.307dfb55.js" as="script"><link rel="prefetch" href="/blog/assets/js/计算机基础_网络_socket是什么.html.6477332a.js" as="script"><link rel="prefetch" href="/blog/assets/js/Spring_注解_元注解.html.1f12c058.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_黑马Java2023_08并发编程_01基础知识_3.创建线程的四种方式.html.f54a02a9.js" as="script"><link rel="prefetch" href="/blog/assets/js/40611.4644bae7.js" as="script"><link rel="prefetch" href="/blog/assets/js/JVM_jstack用法.html.835d2afe.js" as="script"><link rel="prefetch" href="/blog/assets/js/SpringCloud_Alibaba-OSS_阿里云oss使用记录.html.ea0cd2cc.js" as="script"><link rel="prefetch" href="/blog/assets/js/Mybatis_Mybatis Plus_接口_MetaObjectHandler示例.html.4efccaa4.js" as="script"><link rel="prefetch" href="/blog/assets/js/SpringMVC_校验_JSR303数字校验.html.e2275b16.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_SQL刷题_262.行程和用户.html.8bd8e9da.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_面试答题卡_Java_Java 中的深拷贝实现方式.html.b3f1bf54.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_面试答题卡_Java_LSP 设计原则反例.html.03e7c579.js" as="script"><link rel="prefetch" href="/blog/assets/js/设计模式_C行为型_a观察者模式.html.1a217de1.js" as="script"><link rel="prefetch" href="/blog/assets/js/SSM_01-Spring笔记_随笔_Spring随笔.html.a213478a.js" as="script"><link rel="prefetch" href="/blog/assets/js/CICD_Jenkins 配置后端工程，自动拉取代码、打包与重新部署.html.c14fdeb5.js" as="script"><link rel="prefetch" href="/blog/assets/js/SpringBoot_日志框架_Logback 切换到 Log4j2.html.b6953a7b.js" as="script"><link rel="prefetch" href="/blog/assets/js/Spring_注解_@EnableTransactionManagement.html.675c265b.js" as="script"><link rel="prefetch" href="/blog/assets/js/JVM_2.内存结构_2.5方法区.html.f109c320.js" as="script"><link rel="prefetch" href="/blog/assets/js/Java_Java8特性_深入理解 Java Optional 类.html.e5509be0.js" as="script"><link rel="prefetch" href="/blog/assets/js/Mybatis_Mybatis Plus_this.page().html.4b65b971.js" as="script"><link rel="prefetch" href="/blog/assets/js/Java_Java8特性_深入理解 Java 8 新特性：从核心到实践.html.ee87173d.js" as="script"><link rel="prefetch" href="/blog/assets/js/项目实战_个人博客_前端部署.html.7ccf5612.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_面试答题卡_MySQL_锁详解.html.9e56f82a.js" as="script"><link rel="prefetch" href="/blog/assets/js/SpringBoot_注解_@ConfigurationProperties.html.d6fa4f99.js" as="script"><link rel="prefetch" href="/blog/assets/js/Vue_vue模板.html.3c45406b.js" as="script"><link rel="prefetch" href="/blog/assets/js/Java_入门到起飞_35.反射_动态代理_反射.html.9fae427b.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_Java_A基础_16.什么是Java中的动态代理.html.735e8e9f.js" as="script"><link rel="prefetch" href="/blog/assets/js/Java_面试题_16.什么是Java中的动态代理.html.bb8abfbb.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_面试答题卡_Java_代理模式（Proxy Pattern）.html.618ad1ab.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_Java_A基础_5.什么是Java的多态.html.582e8612.js" as="script"><link rel="prefetch" href="/blog/assets/js/Java_面试题_5.什么是Java的多态.html.c9538290.js" as="script"><link rel="prefetch" href="/blog/assets/js/Database_Redis_课前资料_安装Canal.html.eca6c6c7.js" as="script"><link rel="prefetch" href="/blog/assets/js/设计模式_A创建型_a单例模式.html.a617a8cf.js" as="script"><link rel="prefetch" href="/blog/assets/js/Database_MySQL_MySQL小白_mysql是什么_架构是怎么样的.html.90369239.js" as="script"><link rel="prefetch" href="/blog/assets/js/Database_MySQL_基础_数据库控制语言DCL.html.6e262ce8.js" as="script"><link rel="prefetch" href="/blog/assets/js/Spring_注解_@Import.html.d6e348d3.js" as="script"><link rel="prefetch" href="/blog/assets/js/Java_随笔_Java 的引用传递机制.html.3e64511e.js" as="script"><link rel="prefetch" href="/blog/assets/js/Docker_随笔_docker-compose安装软件.html.dd082ab5.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_面试答题卡_数据结构_什么是跳表.html.e8e21a6b.js" as="script"><link rel="prefetch" href="/blog/assets/js/Java_String_Java中重写toString.html.cfe084d4.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_SQL刷题_607.销售员.html.700c3a8e.js" as="script"><link rel="prefetch" href="/blog/assets/js/SpringBoot_注解_@EnableConfigurationProperties.html.3df698c0.js" as="script"><link rel="prefetch" href="/blog/assets/js/设计模式_B结构型_适配器模式.html.289eb72a.js" as="script"><link rel="prefetch" href="/blog/assets/js/SpringCloud_高级_Seata_配置文件.html.ed31c587.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_Spring_Spring 实例化 Bean 的四种方式.html.5bc902d2.js" as="script"><link rel="prefetch" href="/blog/assets/js/设计模式_C行为型_b策略模式.html.6c1eebce.js" as="script"><link rel="prefetch" href="/blog/assets/js/JVM_2.内存结构_2.6直接内存.html.bab6eedb.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_Java_A基础_7.Java 不支持多重继承.html.049b3c41.js" as="script"><link rel="prefetch" href="/blog/assets/js/Java_面试题_7.Java 不支持多重继承.html.05d57fbf.js" as="script"><link rel="prefetch" href="/blog/assets/js/87583.28addbdd.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_面试答题卡_Java_根据业务场景选择线程池参数.html.c9470b27.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_SQL刷题_185.部门工资前三高的所有员工.html.8501414e.js" as="script"><link rel="prefetch" href="/blog/assets/js/SpringCloud_高级_Jmeter_3.sentinel规则持久化.html.940a7cec.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_黑马Java2021_02并发篇_并发篇讲义.html.d1f3ebb0.js" as="script"><link rel="prefetch" href="/blog/assets/js/SSM_03-Maven高级笔记_随笔_packaging类型.html.71ed9684.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_Java_A基础_6.Java中的参数传递是按值还是按引用.html.671e2e5a.js" as="script"><link rel="prefetch" href="/blog/assets/js/Java_面试题_6.Java中的参数传递是按值还是按引用.html.a265d76c.js" as="script"><link rel="prefetch" href="/blog/assets/js/Mybatis_Mybatis Plus_wrapper.and().html.8316c195.js" as="script"><link rel="prefetch" href="/blog/assets/js/学习路线.html.0b64c59e.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_面试答题卡_Java_接口隔离原则（ISP）.html.d381d887.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_面试答题卡_Java_开放封闭原则（OCP）.html.080b85f3.js" as="script"><link rel="prefetch" href="/blog/assets/js/Java_入门到起飞_31.多线程_并发编程的艺术_2.happens-before原则.html.c7682bf5.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_Java_07-Redis面试题_7.Redis面试题.html.608ca372.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_SQL刷题_601.体育馆的人流量.html.f838f49e.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_黑马Java2023_08并发编程_01基础知识_9.在 java 中 wait 和 sleep 方法的不同.html.91a70cf9.js" as="script"><link rel="prefetch" href="/blog/assets/js/SpringCloud_实用_Nacos_2.配置中心.html.b29dd97e.js" as="script"><link rel="prefetch" href="/blog/assets/js/87096.9698059e.js" as="script"><link rel="prefetch" href="/blog/assets/js/Java_异常_try-with-resources自动关闭资源.html.21d0bca1.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_面试答题卡_Java_适配器模式（Adapter Pattern）.html.3166841c.js" as="script"><link rel="prefetch" href="/blog/assets/js/JVM_一命速通_4. JVM性能调优与监控工具_4.1JVM常见 OOM 错误类型与排查.html.36fec502.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_SQL刷题_608.树节点.html.02ca4a60.js" as="script"><link rel="prefetch" href="/blog/assets/js/Linux_5.软件包管理_修改yum源.html.caa89064.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_面试答题卡_Java_synchronized 详解.html.61e523f1.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_面试答题卡_Java_什么是回调地狱.html.66868a5f.js" as="script"><link rel="prefetch" href="/blog/assets/js/JVM_一命速通_1. JVM 架构与类加载_1.3类的初始化与加载的触发条件.html.21caf559.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_Java_A基础_8.Java面向对象和面向过程编程的区别.html.7b8bd3bc.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_Java_A基础_9.Java方法重载和重写之间的区别.html.546de22e.js" as="script"><link rel="prefetch" href="/blog/assets/js/Java_面试题_8.Java面向对象和面向过程编程的区别.html.64e63a49.js" as="script"><link rel="prefetch" href="/blog/assets/js/Java_面试题_9.Java方法重载和重写之间的区别.html.40d36ab9.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_面试答题卡_Java_依赖倒置原则（DIP）.html.a499a2c3.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_MySQL_MySQL黑马23.html.ab3faf7e.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_黑马Java2023_08并发编程_02并发安全_2.synchronized关键字的底层原理-进阶.html.3e7c5321.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_Java_A基础_11.Java8新特性.html.23f9776d.js" as="script"><link rel="prefetch" href="/blog/assets/js/Java_面试题_11.Java8新特性.html.a98b11c9.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_面试答题卡_Java_AQS（AbstractQueuedSynchronizer）详解.html.c8aae121.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_SQL刷题_184.部门工资最高的员工.html.dd9695ab.js" as="script"><link rel="prefetch" href="/blog/assets/js/Database_MySQL_随笔_CTE全面解析d.html.6312a968.js" as="script"><link rel="prefetch" href="/blog/assets/js/SpringCloud_实用_Nacos_5.Nacos多节点部署.html.8456cb97.js" as="script"><link rel="prefetch" href="/blog/assets/js/SpringCloud_实用_ES_10.分页.html.cedf9def.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_面试答题卡_Java_最少知识原则（LoD）.html.4423383c.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_黑马Java2023_08并发编程_02并发安全_1.讲一下synchronized关键字的底层原理.html.bdd0f6cf.js" as="script"><link rel="prefetch" href="/blog/assets/js/JVM_一命速通_1. JVM 架构与类加载_1.2类加载机制详解.html.ede4775f.js" as="script"><link rel="prefetch" href="/blog/assets/js/Linux_4.系统与进程管理_init命令详解.html.f7dcea5f.js" as="script"><link rel="prefetch" href="/blog/assets/js/Linux_4.系统与进程管理_查看系统配置.html.71500e4a.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_面试答题卡_JVM_双亲委派模型.html.5cdef243.js" as="script"><link rel="prefetch" href="/blog/assets/js/SpringCloud_高级_Seata_四种分布式事务模式.html.d9994c2d.js" as="script"><link rel="prefetch" href="/blog/assets/js/JVM_一命速通_2.内存结构与并发内存模型_2.2Java内存模型（JMM）与happens-before 原则.html.08204e52.js" as="script"><link rel="prefetch" href="/blog/assets/js/Bug_maven刷新时语言基本重置问题.html.51d7a73b.js" as="script"><link rel="prefetch" href="/blog/assets/js/MQ_RabbitMQ_什么是RabbitMQ.html.6e3d2053.js" as="script"><link rel="prefetch" href="/blog/assets/js/Mybatis_Mybatis_批量插入方式.html.2607328c.js" as="script"><link rel="prefetch" href="/blog/assets/js/SpringCloud_实用_MQ_安装_RabbitMQ部署指南.html.c7bd6a71.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_SQL刷题_585.2016年的投资.html.4e5b9db5.js" as="script"><link rel="prefetch" href="/blog/assets/js/Database_MySQL_随笔_FROM A_ B 与 JOIN 的区别.html.52e8265a.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_面试答题卡_Java_锁的状态详解（偏向锁 → 轻量级锁 → 重量级锁）.html.7679dc05.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_黑马Java2023_08并发编程_02并发安全_5.请谈谈你对 volatile 的理解.html.9dc59c8d.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_算法_力扣_字符串_415.字符串相加.html.c4c9a9ec.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_面试答题卡_Java_volatile 详解.html.65b9fad6.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_黑马Java2023_08并发编程_01基础知识_6.线程包括哪些状态，状态之间是如何变化的.html.b0d2e096.js" as="script"><link rel="prefetch" href="/blog/assets/js/Linux_4.系统与进程管理_查询安装位置.html.107ea7e4.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_黑马Java2023_08并发编程_02并发安全_4.CAS是什么（含乐观悲观锁）.html.8a33b038.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_SQL刷题_175.组合两个表.html.58353c6c.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_黑马Java2023_08并发编程_02并发安全_11.死锁产生的条件.html.bd8153ae.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_SQL刷题_550.游戏玩法分析 IV.html.cfdb921c.js" as="script"><link rel="prefetch" href="/blog/assets/js/Docker_随笔_查看镜像架构.html.c70c3e3a.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_Java_A基础_15.Java中的hashCode和equals方法之间有什么关系.html.afc56aaf.js" as="script"><link rel="prefetch" href="/blog/assets/js/Java_面试题_15.Java中的hashCode和equals方法之间有什么关系.html.a6a53f4a.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_面试答题卡_Java_ConcurrentHashMap 的 put 操作中 CAS 和 synchronized 的使用.html.bdd99579.js" as="script"><link rel="prefetch" href="/blog/assets/js/Docker_随笔_Dockerfile 构建 Spring Boot 镜像并运行服务.html.2708f12b.js" as="script"><link rel="prefetch" href="/blog/assets/js/装机_电脑装机进阶.html.803808fb.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_面试答题卡_JVM_JVM 类加载与类初始化详解.html.03dffa37.js" as="script"><link rel="prefetch" href="/blog/assets/js/SSM_02-SpringMVC笔记_随笔_SpringMVC随笔.html.4256e059.js" as="script"><link rel="prefetch" href="/blog/assets/js/27124.92624cc2.js" as="script"><link rel="prefetch" href="/blog/assets/js/Database_Redis_Redis 是什么？架构是怎么样的？.html.99c350f4.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_算法_力扣_字符串_784.字母大小写全排列.html.1504853d.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_SQL刷题_577.员工奖金.html.7f1f8deb.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_面试答题卡_Java_内存屏障（Memory Barrier）详解.html.c9362df2.js" as="script"><link rel="prefetch" href="/blog/assets/js/Database_MySQL_基础_DCL语句演示.html.24b350a0.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_SQL刷题_619.只出现一次的最大数字.html.ceaa1710.js" as="script"><link rel="prefetch" href="/blog/assets/js/Spring_Junit_生命周期注解.html.b917412e.js" as="script"><link rel="prefetch" href="/blog/assets/js/Database_MySQL_MySQL安全配置_数据库安全配置.html.3478a04c.js" as="script"><link rel="prefetch" href="/blog/assets/js/Java_核心类库_System 类详解.html.e0fb77b9.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_黑马Java2023_08并发编程_02并发安全_7.什么是可重入锁.html.61649fca.js" as="script"><link rel="prefetch" href="/blog/assets/js/项目实战_谷粒商城_报错记录_人人后台注册至Nacos版本问题.html.4a5a3f6c.js" as="script"><link rel="prefetch" href="/blog/assets/js/SpringBoot_lombok注解_@RequiredArgsConstructor.html.0eaaeae8.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_SQL刷题_177.第N高的薪水.html.f914eef1.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_面试答题卡_Java_String vs StringBuffer vs StringBuilder.html.2ac590e9.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_黑马Java2023_08并发编程_01基础知识_7.新建 T1、T2、T3 三个线程，如何保证它们按顺序执行.html.de7b954b.js" as="script"><link rel="prefetch" href="/blog/assets/js/JVM_一命速通_2.内存结构与并发内存模型_2.3直接内存DirectMemory的使用与风险.html.027e23d1.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_面试答题卡_Java_字符串拼接与性能优化.html.c7b266d5.js" as="script"><link rel="prefetch" href="/blog/assets/js/Docker_随笔_镜像导入导出.html.459efbc5.js" as="script"><link rel="prefetch" href="/blog/assets/js/Java_入门到起飞_31.多线程_并发编程的艺术_1.Java内存模型.html.a8e00246.js" as="script"><link rel="prefetch" href="/blog/assets/js/SpringCloud_实用_ES_9.copy_to的用法.html.ba1d3aa7.js" as="script"><link rel="prefetch" href="/blog/assets/js/Netty_API_API.html.aed69c9f.js" as="script"><link rel="prefetch" href="/blog/assets/js/Docker_私有云_私有云部署软件.html.becd4e2a.js" as="script"><link rel="prefetch" href="/blog/assets/js/CICD_Jenkins 配置前端工程，自动拉取代码、打包与上传云服务器.html.f0b7df24.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_面试答题卡_Java_CompletableFuture 使用详解.html.7498c471.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_面试答题卡_Java_CopyOnWriteArrayList 详解.html.7973ce47.js" as="script"><link rel="prefetch" href="/blog/assets/js/Java_入门到起飞_35.反射_动态代理_getMethods()和getDeclaredMethods()的区别.html.19f34463.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_面试答题卡_Java_单一职责原则（SRP）.html.6b4297e8.js" as="script"><link rel="prefetch" href="/blog/assets/js/Database_MySQL_MySQL安装文档-Linux_MySQL-Linux-yum及docker安装.html.745e1748.js" as="script"><link rel="prefetch" href="/blog/assets/js/Docker_随笔_docker安装jenkins及配置.html.da7c1d8b.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_面试答题卡_Git_Merge VS Rebase.html.40788ac9.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_SQL刷题_183.从不订购的客户.html.e603ce93.js" as="script"><link rel="prefetch" href="/blog/assets/js/Spring_注解_@FeignClient.html.80615f37.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_SQL刷题_626.换座位.html.82ead62a.js" as="script"><link rel="prefetch" href="/blog/assets/js/Database_MySQL_MySQL安装文档-Linux_MySQL-Linux离线安装.html.2ef2bbaa.js" as="script"><link rel="prefetch" href="/blog/assets/js/Mybatis_Mybatis Plus_新版分页插件.html.6cf93fd3.js" as="script"><link rel="prefetch" href="/blog/assets/js/JVM_一命速通_3.GC垃圾回收机制_3.4 GC 参数调优实战策略.html.d8183e84.js" as="script"><link rel="prefetch" href="/blog/assets/js/JVM_一命速通_4. JVM性能调优与监控工具_4.3常见内存泄漏模式与定位技巧.html.47b2516c.js" as="script"><link rel="prefetch" href="/blog/assets/js/Java_入门到起飞_35.反射_动态代理_getDeclaredField()和getField()区别.html.a09b9582.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_面试答题卡_Java_为什么 ArrayList 不是线程安全的.html.eea72b5b.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_面试答题卡_Java_ConcurrentHashMap 详解.html.82b7b57b.js" as="script"><link rel="prefetch" href="/blog/assets/js/Java_入门到起飞_31.多线程_多线程总结.html.c759fde8.js" as="script"><link rel="prefetch" href="/blog/assets/js/JVM_一命速通_2.内存结构与并发内存模型_2.1JVM内存结构详解（堆、栈、方法区等）.html.96804b02.js" as="script"><link rel="prefetch" href="/blog/assets/js/Docker_随笔_Docker容器与宿主机时间同步.html.3b0590fa.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_算法_力扣_字符串_541.反转字符串 II.html.9ded453a.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_SQL刷题_176.第二高的薪水.html.0bfe54d2.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_SQL刷题_602.好友申请 II ：谁有最多的好友.html.1261e7c6.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_SQL刷题_180.连续出现的数字.html.624a128e.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_SQL刷题_620.有趣的电影.html.23782b6c.js" as="script"><link rel="prefetch" href="/blog/assets/js/Database_MySQL_MySQL安全配置_数据库隔离级别.html.95b0e396.js" as="script"><link rel="prefetch" href="/blog/assets/js/Linux_9.磁盘管理与存储_硬盘挂载.html.c89f7fef.js" as="script"><link rel="prefetch" href="/blog/assets/js/Database_MySQL_MySQL故障修复_Navicat连接mysql报错.html.596df1ac.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_面试答题卡_Java_PriorityQueue.html.47e4622d.js" as="script"><link rel="prefetch" href="/blog/assets/js/VCS_Git_本地项目推送至远程库.html.c069015f.js" as="script"><link rel="prefetch" href="/blog/assets/js/JVM_cpu load过高问题.html.57d36fe3.js" as="script"><link rel="prefetch" href="/blog/assets/js/JVM_一命速通_1. JVM 架构与类加载_1.1架构组成与执行流程.html.caec0c39.js" as="script"><link rel="prefetch" href="/blog/assets/js/SSM_01-Spring笔记_AOP_日志切面排除路径.html.407aa222.js" as="script"><link rel="prefetch" href="/blog/assets/js/Netty_释放ByteBuf.html.d15dc7ac.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_黑马Java2023_08并发编程_02并发安全_8.什么是自旋锁.html.e091e46c.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_SQL刷题_570.至少有5名直接下属的经理.html.6146537e.js" as="script"><link rel="prefetch" href="/blog/assets/js/Spring_注解_注解@RequestMapping、@PostMapping、@GetMapping.html.1fcf37fc.js" as="script"><link rel="prefetch" href="/blog/assets/js/SpringCloud_高级_Jmeter_1.MAC安装JMeter.html.371361c1.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_面试答题卡_Java_hashCode() 与 equals() 的关系.html.37e1996c.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_SQL刷题_595.大的国家.html.3ecb4f75.js" as="script"><link rel="prefetch" href="/blog/assets/js/SpringCloud_实用_ES_7.创建索引库.html.30c0002d.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_SQL刷题_196.删除重复的电子邮箱.html.c8b4e803.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_SQL刷题_197.上升的温度.html.aa8fb619.js" as="script"><link rel="prefetch" href="/blog/assets/js/SpringCloud_高级_Seata_seata1.4.2升级2.0.0注意点.html.1bedbbe6.js" as="script"><link rel="prefetch" href="/blog/assets/js/Docker_私有云_前后端分离博客项目.html.5fb906a3.js" as="script"><link rel="prefetch" href="/blog/assets/js/JVM_一命速通_3.GC垃圾回收机制_3.3 GC 日志参数详解与案例分析.html.cd9074de.js" as="script"><link rel="prefetch" href="/blog/assets/js/JVM_一命速通_5.性能诊断与运维工具推荐_5.1JDK 命令行工具全景图与典型用途.html.0d2dcf05.js" as="script"><link rel="prefetch" href="/blog/assets/js/Java_架构_学习路线.html.3609357c.js" as="script"><link rel="prefetch" href="/blog/assets/js/MQ_Kafka_发送接收demo.html.c7fbf715.js" as="script"><link rel="prefetch" href="/blog/assets/js/JVM_一命速通_3.GC垃圾回收机制_3.2 CMS、G1、ZGC、Shenandoah 对比.html.449a16d4.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_SQL刷题_586.订单最多的客户.html.7fd101a7.js" as="script"><link rel="prefetch" href="/blog/assets/js/Linux_13.服务与自动化管理_systemctl.html.cae58440.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_Java_A基础_14.Java 中 hashCode_equals 方法和__ 操作符.html.1db60aff.js" as="script"><link rel="prefetch" href="/blog/assets/js/Java_面试题_14.Java 中 hashCode_equals 方法和__ 操作符.html.02289754.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_SQL刷题_584.寻找用户推荐人.html.6bba7fed.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_SQL刷题_178.分数排名.html.a6407e4b.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_SQL刷题_596.超过 5 名学生的课.html.379fa891.js" as="script"><link rel="prefetch" href="/blog/assets/js/JVM_一命速通_3.GC垃圾回收机制_3.1 Java 垃圾回收算法与分代机制.html.40528f7e.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_SQL刷题_511.游戏玩法分析 I.html.ad4d27c8.js" as="script"><link rel="prefetch" href="/blog/assets/js/JVM_GC类型.html.956efd3c.js" as="script"><link rel="prefetch" href="/blog/assets/js/SSM_01-Spring笔记_随笔_Spring注解.html.b05cc95b.js" as="script"><link rel="prefetch" href="/blog/assets/js/SpringCloud_实用_ES_1.什么是ES.html.1412b54e.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_SQL刷题_181.超过经理收入的员工.html.0ad796c0.js" as="script"><link rel="prefetch" href="/blog/assets/js/81434.b756e60f.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_SQL刷题_610.判断三角形.html.214e3071.js" as="script"><link rel="prefetch" href="/blog/assets/js/JVM_一命速通_4. JVM性能调优与监控工具_4.2如何分析 Java 堆转储文件（hprof）.html.fffe2a55.js" as="script"><link rel="prefetch" href="/blog/assets/js/JVM_OOM.html.652cb72c.js" as="script"><link rel="prefetch" href="/blog/assets/js/Le Penseur_做一个内核稳定的人.html.71bd9c2a.js" as="script"><link rel="prefetch" href="/blog/assets/js/Database_MySQL_MySQL安全配置_MySQL数据库授权管理.html.478d525f.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_面试答题卡_Java_Java注解原理.html.57953bb9.js" as="script"><link rel="prefetch" href="/blog/assets/js/Java_面试题_4.Java的优势.html.e6a40bc6.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_Java_A基础_4.Java的优势.html.ad171d14.js" as="script"><link rel="prefetch" href="/blog/assets/js/Bug_Java_InaccessibleObjectException.html.5219e853.js" as="script"><link rel="prefetch" href="/blog/assets/js/Java_随笔_Java 中引用类型在内存中的存储方式.html.281e4654.js" as="script"><link rel="prefetch" href="/blog/assets/js/Le Penseur_立体的人而不是平面的人.html.9ef0e04e.js" as="script"><link rel="prefetch" href="/blog/assets/js/Database_MySQL_MyCat安装文档_MyCat安装文档.html.d492abe5.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_算法_力扣_字符串_344.反转字符串.html.3c3c67c7.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_面试记录_中电金信.html.b5492ae1.js" as="script"><link rel="prefetch" href="/blog/assets/js/Database_MySQL_index.html.f7b9099b.js" as="script"><link rel="prefetch" href="/blog/assets/js/Netty_关闭事件循环组.html.f766844e.js" as="script"><link rel="prefetch" href="/blog/assets/js/81316.d360a347.js" as="script"><link rel="prefetch" href="/blog/assets/js/Netty_核心概念理解.html.6718f95f.js" as="script"><link rel="prefetch" href="/blog/assets/js/42275.93cd7f21.js" as="script"><link rel="prefetch" href="/blog/assets/js/Docker_随笔_docker安装软件.html.cc7f7df0.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_面试答题卡_OS_用户态与内核态切换详解.html.5018ad12.js" as="script"><link rel="prefetch" href="/blog/assets/js/Linux_2.文件系统_软硬链接.html.36ad5eae.js" as="script"><link rel="prefetch" href="/blog/assets/js/CICD_Jenkins 配置后端：自动构建 Docker 镜像、运行容器服务.html.77b0effa.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_面试答题卡_JVM_垃圾回收器 CMS 与 G1 的区别详解.html.e8e23282.js" as="script"><link rel="prefetch" href="/blog/assets/js/21317.0c91ade5.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_Java_A基础_10.Java内部类及作用.html.d0e13488.js" as="script"><link rel="prefetch" href="/blog/assets/js/Java_面试题_10.Java内部类及作用.html.2d106f27.js" as="script"><link rel="prefetch" href="/blog/assets/js/26873.343cbf8d.js" as="script"><link rel="prefetch" href="/blog/assets/js/Linux_6.网络配置与管理_关闭端口占用进程.html.3cf08e6a.js" as="script"><link rel="prefetch" href="/blog/assets/js/SpringCloud_实用_Nacos_3.网关配置.html.01ed9c33.js" as="script"><link rel="prefetch" href="/blog/assets/js/JVM_一命速通_6. 服务器与容器线程模型调优_6.1Tomcat 线程模型详解与调优指南.html.0b770676.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_Java_A基础_12.JDK和JRE区别.html.2b3e129d.js" as="script"><link rel="prefetch" href="/blog/assets/js/Java_面试题_12.JDK和JRE区别.html.58f30852.js" as="script"><link rel="prefetch" href="/blog/assets/js/JVM_一命速通_5.性能诊断与运维工具推荐_5.3Arthas 使用指南及常用命令解析.html.3a105f07.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_面试答题卡_Spring_Spring 三级缓存解决循环依赖详解.html.1465d647.js" as="script"><link rel="prefetch" href="/blog/assets/js/网络_L2TP和IPsec协议常见软件和工具.html.91cbb5ae.js" as="script"><link rel="prefetch" href="/blog/assets/js/Database_MySQL_MySQL优化_union和unionAll.html.9c20b2a0.js" as="script"><link rel="prefetch" href="/blog/assets/js/Docker_随笔_pull.html.44394d97.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_Java_热点面试题_热点面试题.html.bbf12268.js" as="script"><link rel="prefetch" href="/blog/assets/js/Linux_1.安装与配置_V2ray安装.html.8a275489.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_SQL刷题_182.查找重复的电子邮箱.html.cd97846b.js" as="script"><link rel="prefetch" href="/blog/assets/js/Spring_SpringBoot无数据源启动.html.e2d9a0c8.js" as="script"><link rel="prefetch" href="/blog/assets/js/Linux_4.系统与进程管理_Ubuntu命令行图形化界面切换.html.7f6331d5.js" as="script"><link rel="prefetch" href="/blog/assets/js/Java_工具类_BeanUtil.html.21b8dfab.js" as="script"><link rel="prefetch" href="/blog/assets/js/SpringCloud_高级_Jmeter_2.Jmeter快速入门.html.ada282d8.js" as="script"><link rel="prefetch" href="/blog/assets/js/Database_MySQL_MySQL安装文档-Windows_MySQL安装.html.f4180953.js" as="script"><link rel="prefetch" href="/blog/assets/js/Mybatis_Mybatis_逻辑删除.html.b503f3ed.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_面试答题卡_JVM_垃圾回收算法哪些阶段会stop the world.html.6407dff3.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_面试答题卡_Java_Java_多态_设计模式.html.24af44e4.js" as="script"><link rel="prefetch" href="/blog/assets/js/JVM_一命速通_5.性能诊断与运维工具推荐_5.2使用 Java Mission Control（JMC）进行性能分析.html.5bd378f4.js" as="script"><link rel="prefetch" href="/blog/assets/js/5663.892fda56.js" as="script"><link rel="prefetch" href="/blog/assets/js/设计模式_设计模式.html.d6fbc67a.js" as="script"><link rel="prefetch" href="/blog/assets/js/JVM_一命速通_10. JVM面试高频问答_10.1JVM面试高频问答汇总.html.91dadb49.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_面试答题卡_Linux_Linux 的软链接与硬链接.html.99b91d68.js" as="script"><link rel="prefetch" href="/blog/assets/js/Netty_API_ExecutorService.html.7b20dfc2.js" as="script"><link rel="prefetch" href="/blog/assets/js/项目实战_谷粒商城_关闭eslint检查.html.0edbe5eb.js" as="script"><link rel="prefetch" href="/blog/assets/js/装机_N1盒子_N1盒子配置AdGuard及passwall.html.810d8d98.js" as="script"><link rel="prefetch" href="/blog/assets/js/VCS_Git_删除最近一次推送.html.b83830e3.js" as="script"><link rel="prefetch" href="/blog/assets/js/SSM_03-Maven高级笔记_随笔_pom中的relativePath.html.9a93f81b.js" as="script"><link rel="prefetch" href="/blog/assets/js/Java_入门到起飞_15.面向对象进阶（抽象类_接口_内部类）_课堂笔记.html.07d99c09.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_黑马Java2023_08并发编程_02并发安全_12.聊一下ConcurrentHashMap .html.f5f71e9f.js" as="script"><link rel="prefetch" href="/blog/assets/js/网络_L2TPIPsec.html.a6aa5fbf.js" as="script"><link rel="prefetch" href="/blog/assets/js/VCS_Git_忽略idea文件夹.html.0be2f29e.js" as="script"><link rel="prefetch" href="/blog/assets/js/Database_MySQL_进阶_1.什么情况下会出现读取记录的事务id比创建readview的事务id大.html.b7777e9a.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_黑马Java2023_08并发编程_02并发安全_13.导致并发程序出现问题的根本原因是什么.html.f6bb777e.js" as="script"><link rel="prefetch" href="/blog/assets/js/Spring_注解_@ResponseBody.html.4093a3b2.js" as="script"><link rel="prefetch" href="/blog/assets/js/Database_MySQL_基础_MySQL数据类型.html.c7569f89.js" as="script"><link rel="prefetch" href="/blog/assets/js/21901.42b8e43b.js" as="script"><link rel="prefetch" href="/blog/assets/js/Linux_7.文件与目录管理_dos2unix换行符清理.html.97757e00.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_黑马Java2023_08并发编程_02并发安全_9.ReentrantLock的实现原理.html.06906a93.js" as="script"><link rel="prefetch" href="/blog/assets/js/JVM_一命速通_7. JVM调优实战总结与案例_7.1JVM 调优实战总结与案例分析.html.195cfe23.js" as="script"><link rel="prefetch" href="/blog/assets/js/项目实战_谷粒商城_报错记录_人人前端启动失败.html.1d13688c.js" as="script"><link rel="prefetch" href="/blog/assets/js/Docker_随笔_特权模式.html.e7fde61a.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_面试答题卡_Java_面向对象设计原则（SOLID 及相关）.html.e6eef6fc.js" as="script"><link rel="prefetch" href="/blog/assets/js/Linux_3.用户与组管理_单用户模式重置密码.html.61e5cb66.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_Java_A基础_7.Java不支持多重继承.html.bad11a11.js" as="script"><link rel="prefetch" href="/blog/assets/js/Java_面试题_7.Java不支持多重继承.html.1b665a7f.js" as="script"><link rel="prefetch" href="/blog/assets/js/Database_MySQL_MySQL卸载文档-Linux_MySQL卸载-Linux.html.ec26d63a.js" as="script"><link rel="prefetch" href="/blog/assets/js/JVM_2.1.年轻代老年代.html.15a43a14.js" as="script"><link rel="prefetch" href="/blog/assets/js/Nginx_413 (Request Entity Too Large).html.aad1abc6.js" as="script"><link rel="prefetch" href="/blog/assets/js/JVM_一命速通_9. 高级调试技巧与工具链整合_9.1JVM高级调试技巧与工具链整合.html.7311f9bb.js" as="script"><link rel="prefetch" href="/blog/assets/js/Spring_注解_@JsonFormat.html.4bf5956d.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_黑马Java2023_08并发编程_02并发安全_6.什么是AQS.html.545675c5.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_Java_A基础_1.序列化与反序列化.html.30fea254.js" as="script"><link rel="prefetch" href="/blog/assets/js/Java_面试题_1.序列化与反序列化.html.3ef46f5a.js" as="script"><link rel="prefetch" href="/blog/assets/js/JVM_一命速通_8. JVM高级性能分析工具_8.2JVM 性能调优实战案例解析.html.46fc268e.js" as="script"><link rel="prefetch" href="/blog/assets/js/Database_MySQL_运维_MyCat配置信息含义.html.fb2d77af.js" as="script"><link rel="prefetch" href="/blog/assets/js/Linux_index.html.bd8c4b6b.js" as="script"><link rel="prefetch" href="/blog/assets/js/装机_电脑配置.html.e20a7999.js" as="script"><link rel="prefetch" href="/blog/assets/js/Database_MySQL_MySQL故障修复_mysql-uroot-p报错.html.45625657.js" as="script"><link rel="prefetch" href="/blog/assets/js/Java_入门到起飞_35.反射_动态代理_反射_动态代理总结.html.5fc80daa.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_面试记录_面试题记录.html.6e36e472.js" as="script"><link rel="prefetch" href="/blog/assets/js/JVM_2.内存结构_2.2虚拟机栈.html.330e8898.js" as="script"><link rel="prefetch" href="/blog/assets/js/JVM_一命速通_8. JVM高级性能分析工具_8.1JVM 高级性能分析工具介绍.html.ab0c42fd.js" as="script"><link rel="prefetch" href="/blog/assets/js/Database_Redis_2.实战_pending-list.html.dbc15200.js" as="script"><link rel="prefetch" href="/blog/assets/js/Database_MySQL_MySQL卸载文档-Windows_MySQL卸载文档-Windows版.html.dc131cc6.js" as="script"><link rel="prefetch" href="/blog/assets/js/Java_入门到起飞_35.反射_动态代理_字节码对象.html.d5b99b51.js" as="script"><link rel="prefetch" href="/blog/assets/js/Linux_1.安装与配置_主要架构.html.40887dfa.js" as="script"><link rel="prefetch" href="/blog/assets/js/Docker_随笔_安装NocoDB.html.d8c45dea.js" as="script"><link rel="prefetch" href="/blog/assets/js/95292.1e1e16d5.js" as="script"><link rel="prefetch" href="/blog/assets/js/Database_MySQL_MySQL故障修复_caching_sha2_password无法加载.html.d4ea7486.js" as="script"><link rel="prefetch" href="/blog/assets/js/网络_刷新dns缓存.html.d7814229.js" as="script"><link rel="prefetch" href="/blog/assets/js/Mybatis_Mybatis Plus_动态构建查询条件.html.e782ca3f.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_Java_B中等_1.Java中String、StringBuffer和StringBuilder的区别.html.b7d4a667.js" as="script"><link rel="prefetch" href="/blog/assets/js/前端_node_nvm更换镜像源.html.b2acda58.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_Java_A基础_2.不可变类.html.1a08eb0d.js" as="script"><link rel="prefetch" href="/blog/assets/js/Java_面试题_2.不可变类.html.ea15d156.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_Java_A基础_13.你使用过哪些JDK工具.html.7d2bf1a5.js" as="script"><link rel="prefetch" href="/blog/assets/js/Java_面试题_13.你使用过哪些JDK工具.html.36b12236.js" as="script"><link rel="prefetch" href="/blog/assets/js/Mybatis_Mybatis Plus_QueryWrapper vs LambdaQueryWrapper.html.d59046cb.js" as="script"><link rel="prefetch" href="/blog/assets/js/SpringCloud_实用_ES_3.基本概念.html.8e3f9f40.js" as="script"><link rel="prefetch" href="/blog/assets/js/SpringCloud_实用_Nacos_0.安装与启动.html.89bd120e.js" as="script"><link rel="prefetch" href="/blog/assets/js/Database_MySQL_工具_闪回-flashback.html.8e629adf.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_黑马Java2023_08并发编程_01基础知识_1.线程和进程的区别.html.9d30aa5e.js" as="script"><link rel="prefetch" href="/blog/assets/js/Mybatis_Mybatis Plus_queryWrapper自定义SQL.html.0ea78bf0.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_Java_A基础_3.Exception和Error的区别.html.b2ce431c.js" as="script"><link rel="prefetch" href="/blog/assets/js/Java_面试题_3.Exception和Error的区别.html.94872ed7.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_黑马Java2023_08并发编程_01基础知识_2.并行和并发有什么区别.html.1dfe94f5.js" as="script"><link rel="prefetch" href="/blog/assets/js/Spring_Spring5.x概述.html.345fb779.js" as="script"><link rel="prefetch" href="/blog/assets/js/Mybatis_Mybatis Plus_where 1_1.html.012f691b.js" as="script"><link rel="prefetch" href="/blog/assets/js/SpringCloud_实用_Nacos_1.注册中心.html.b72894ad.js" as="script"><link rel="prefetch" href="/blog/assets/js/Python_基础_0.前言.html.9a9a3601.js" as="script"><link rel="prefetch" href="/blog/assets/js/JVM_2.内存结构_2.3本地方法栈.html.11cdb8eb.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_黑马Java2023_08并发编程_02并发安全_3.你谈谈 JMM（Java 内存模型）.html.42998293.js" as="script"><link rel="prefetch" href="/blog/assets/js/JVM_2.内存结构_2.1程序计数器.html.f39d01b8.js" as="script"><link rel="prefetch" href="/blog/assets/js/Linux_4.系统与进程管理_daemon-reload.html.4e1ce107.js" as="script"><link rel="prefetch" href="/blog/assets/js/Database_MySQL_MyCat-Web安装文档_MyCat-web安装文档.html.a9fa5e0a.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_Java_B中等_2.Java中volatile关键字的作用.html.1ea7c250.js" as="script"><link rel="prefetch" href="/blog/assets/js/SpringCloud_基础_事务ACID原则.html.838e3d05.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_黑马Java2023_08并发编程_02并发安全_10.synchronized和Lock有什么区别.html.9ed2b29f.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_黑马Java2023_08并发编程_02并发安全_12.如何进行死锁判断.html.87e0947e.js" as="script"><link rel="prefetch" href="/blog/assets/js/SpringCloud_高级_index.html.c9257c28.js" as="script"><link rel="prefetch" href="/blog/assets/js/14903.a286806b.js" as="script"><link rel="prefetch" href="/blog/assets/js/前端_node_npm更换镜像源.html.03210df9.js" as="script"><link rel="prefetch" href="/blog/assets/js/Java_唯手熟尔_equals与等号.html.592e5bc5.js" as="script"><link rel="prefetch" href="/blog/assets/js/Linux_4.系统与进程管理_rc.local.html.73d0fb79.js" as="script"><link rel="prefetch" href="/blog/assets/js/项目实战_谷粒商城_跨域.html.b08f3c80.js" as="script"><link rel="prefetch" href="/blog/assets/js/42916.31234321.js" as="script"><link rel="prefetch" href="/blog/assets/js/SpringCloud_实用_ES_5.分词器.html.64dc7889.js" as="script"><link rel="prefetch" href="/blog/assets/js/JVM_2.内存结构_2.4堆.html.30ac9f74.js" as="script"><link rel="prefetch" href="/blog/assets/js/Java_空值和null值.html.28e8b0bd.js" as="script"><link rel="prefetch" href="/blog/assets/js/42240.ee1637d8.js" as="script"><link rel="prefetch" href="/blog/assets/js/Java_index.html.56171422.js" as="script"><link rel="prefetch" href="/blog/assets/js/Database_Redis_视频教程.html.a1bcc56e.js" as="script"><link rel="prefetch" href="/blog/assets/js/JVM_2.内存结构.html.777fb4bd.js" as="script"><link rel="prefetch" href="/blog/assets/js/SpringCloud_实用_Nacos_4.Nacos指定服务端IP.html.5373f033.js" as="script"><link rel="prefetch" href="/blog/assets/js/Linux_15.故障排除与修复_reset-failed.html.7a2d0fbb.js" as="script"><link rel="prefetch" href="/blog/assets/js/SSM_02-SpringMVC笔记_随笔_SpringMVC注解.html.57c8f6fa.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_黑马Java2023_08并发编程_01基础知识_4.runnable 和 callable 有什么区别.html.ab25491e.js" as="script"><link rel="prefetch" href="/blog/assets/js/SpringCloud_实用_ES_6.mapping常见属性.html.fde8b1be.js" as="script"><link rel="prefetch" href="/blog/assets/js/JVM_1.学习JVM有什么用.html.27f50e12.js" as="script"><link rel="prefetch" href="/blog/assets/js/SpringCloud_高级_Seata_模式总结.html.a9721858.js" as="script"><link rel="prefetch" href="/blog/assets/js/学习记录.html.24dcc78e.js" as="script"><link rel="prefetch" href="/blog/assets/js/项目实战_谷粒商城_报错记录_定时任务启动失败.html.3ee86467.js" as="script"><link rel="prefetch" href="/blog/assets/js/Database_MySQL_进阶_1.为什么InnoDB存储引擎选择使用B_tree索引结构.html.43ed9dbb.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_黑马Java2023_08并发编程_01基础知识_5.线程的 run()和 start()有什么区别.html.ed36c1ac.js" as="script"><link rel="prefetch" href="/blog/assets/js/SpringCloud_实用_ES_2.倒排索引.html.02a709ab.js" as="script"><link rel="prefetch" href="/blog/assets/js/SpringCloud_高级_Sentinel_bug_windows版sentinel运行报错问题处理Unable to make protected final java.lang.Class java.lang.ClassLoader.define.html.6a38fe2f.js" as="script"><link rel="prefetch" href="/blog/assets/js/Java_String_isNotEmpty和isNotBlank.html.369d75b1.js" as="script"><link rel="prefetch" href="/blog/assets/js/项目实战_谷粒商城_报错记录_SpringBoot读取ValidationMessages.properties，中文乱码.html.d56ccb83.js" as="script"><link rel="prefetch" href="/blog/assets/js/装机_飞牛OS开关屏幕.html.b7162650.js" as="script"><link rel="prefetch" href="/blog/assets/js/SpringCloud_高级_Seata_TC_TM_RM.html.0d33a6b2.js" as="script"><link rel="prefetch" href="/blog/assets/js/项目实战_谷粒商城_报错记录_找不到符号.html.84883426.js" as="script"><link rel="prefetch" href="/blog/assets/js/Vue_index.html.e36c6823.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_黑马Java2023_08并发编程_index.html.104ec642.js" as="script"><link rel="prefetch" href="/blog/assets/js/文章分类及标签.html.412063db.js" as="script"><link rel="prefetch" href="/blog/assets/js/项目实战_谷粒商城_报错记录_服务列表为空.html.b079278d.js" as="script"><link rel="prefetch" href="/blog/assets/js/装机_飞牛OS合盖不休眠.html.cbb4d240.js" as="script"><link rel="prefetch" href="/blog/assets/js/项目实战_谷粒商城_视频教程.html.8fcb633c.js" as="script"><link rel="prefetch" href="/blog/assets/js/JVM_index.html.a6a34408.js" as="script"><link rel="prefetch" href="/blog/assets/js/SpringCloud_实用_ES_视频教程.html.9940368b.js" as="script"><link rel="prefetch" href="/blog/assets/js/Netty_1.黑马视频教程.html.32df691c.js" as="script"><link rel="prefetch" href="/blog/assets/js/index.html.101d22b8.js" as="script"><link rel="prefetch" href="/blog/assets/js/Java_雷丰阳Java视频.html.624075ac.js" as="script"><link rel="prefetch" href="/blog/assets/js/Spring_注解_@JsonInclude.html.9d4f2583.js" as="script"><link rel="prefetch" href="/blog/assets/js/SSM_index.html.607f9dac.js" as="script"><link rel="prefetch" href="/blog/assets/js/JVM_黑马JVM.html.e92ef57d.js" as="script"><link rel="prefetch" href="/blog/assets/js/Java_工具类_Java常用工具包.html.a39f2b2b.js" as="script"><link rel="prefetch" href="/blog/assets/js/40676.55bf3d3f.js" as="script"><link rel="prefetch" href="/blog/assets/js/53021.61752250.js" as="script"><link rel="prefetch" href="/blog/assets/js/软件工程_UML图_UML类图绘制.html.98056d55.js" as="script"><link rel="prefetch" href="/blog/assets/js/Python_基础_video.html.1ba631ac.js" as="script"><link rel="prefetch" href="/blog/assets/js/Docker_随笔_查看数据卷目录.html.d6571100.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_Java_A基础_18.接口和抽象类有什么区别.html.a9f378e5.js" as="script"><link rel="prefetch" href="/blog/assets/js/JVM_一命速通_index.html.8e725f92.js" as="script"><link rel="prefetch" href="/blog/assets/js/项目实战_谷粒商城_index.html.29ab8bbf.js" as="script"><link rel="prefetch" href="/blog/assets/js/Java_入门到起飞_15.面向对象进阶（抽象类_接口_内部类）_index.html.22409c55.js" as="script"><link rel="prefetch" href="/blog/assets/js/73160.ebbe013a.js" as="script"><link rel="prefetch" href="/blog/assets/js/intro.html.2ec8ecc0.js" as="script"><link rel="prefetch" href="/blog/assets/js/SpringCloud_实用_Nacos_index.html.c5ea9dce.js" as="script"><link rel="prefetch" href="/blog/assets/js/JVM_一命速通_6. 服务器与容器线程模型调优_index.html.eeefea13.js" as="script"><link rel="prefetch" href="/blog/assets/js/JVM_一命速通_9. 高级调试技巧与工具链整合_index.html.91392b08.js" as="script"><link rel="prefetch" href="/blog/assets/js/SpringMVC_校验_index.html.8d05bbd5.js" as="script"><link rel="prefetch" href="/blog/assets/js/Java_入门到起飞_26.集合（Stream流_方法引用）_index.html.7931a7d2.js" as="script"><link rel="prefetch" href="/blog/assets/js/Java_入门到起飞_23.集合（泛型_Set_数据结构)_index.html.efae9a6c.js" as="script"><link rel="prefetch" href="/blog/assets/js/JVM_一命速通_2.内存结构与并发内存模型_index.html.d09156d1.js" as="script"><link rel="prefetch" href="/blog/assets/js/JVM_一命速通_5.性能诊断与运维工具推荐_index.html.cb0798d6.js" as="script"><link rel="prefetch" href="/blog/assets/js/68984.a201f555.js" as="script"><link rel="prefetch" href="/blog/assets/js/JVM_一命速通_7. JVM调优实战总结与案例_index.html.56116338.js" as="script"><link rel="prefetch" href="/blog/assets/js/JVM_一命速通_4. JVM性能调优与监控工具_index.html.44598787.js" as="script"><link rel="prefetch" href="/blog/assets/js/Java_入门到起飞_31.多线程_并发编程的艺术_index.html.acc8b193.js" as="script"><link rel="prefetch" href="/blog/assets/js/JVM_一命速通_8. JVM高级性能分析工具_index.html.371540c0.js" as="script"><link rel="prefetch" href="/blog/assets/js/Java_入门到起飞_31.多线程_juc额外扩展资料_index.html.ee9fc9ed.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_双亲委派模型_index.html.bb881d5b.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_反射动态代理_index.html.ee455e69.js" as="script"><link rel="prefetch" href="/blog/assets/js/category_springcloud实用篇_index.html.b6246f19.js" as="script"><link rel="prefetch" href="/blog/assets/js/category_springcloud高级篇_index.html.b4483d98.js" as="script"><link rel="prefetch" href="/blog/assets/js/Java_入门到起飞_22.集合（List集合）_index.html.852e2cbb.js" as="script"><link rel="prefetch" href="/blog/assets/js/JVM_一命速通_1. JVM 架构与类加载_index.html.b4c74aa5.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_分布式事务_index.html.6119a13f.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_切点表达式_index.html.83760b17.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_命令行工具_index.html.9c2cbe3e.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_彩色控制台_index.html.31a08bed.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_日志分模块_index.html.35179680.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_消息中间件_index.html.263d480e.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_回收器对比_index.html.3786242c.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_数据库原理_index.html.c2b98f74.js" as="script"><link rel="prefetch" href="/blog/assets/js/JVM_一命速通_10. JVM面试高频问答_index.html.71f8e4c3.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_java内存模型_index.html.e0697c76.js" as="script"><link rel="prefetch" href="/blog/assets/js/Java_入门到起飞_35.反射_动态代理_index.html.3623ae4b.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_spring-boot-配置_index.html.f10e4fe4.js" as="script"><link rel="prefetch" href="/blog/assets/js/category_使用指南_index.html.671b66de.js" as="script"><link rel="prefetch" href="/blog/assets/js/category_依赖注入_index.html.d5eb5c0c.js" as="script"><link rel="prefetch" href="/blog/assets/js/category_博客专栏_index.html.dcb82f01.js" as="script"><link rel="prefetch" href="/blog/assets/js/category_性能优化_index.html.174fda86.js" as="script"><link rel="prefetch" href="/blog/assets/js/category_性能分析_index.html.a01f33a2.js" as="script"><link rel="prefetch" href="/blog/assets/js/category_性能排查_index.html.da8b8bcb.js" as="script"><link rel="prefetch" href="/blog/assets/js/category_日志系统_index.html.c5d52826.js" as="script"><link rel="prefetch" href="/blog/assets/js/category_消息队列_index.html.c262e853.js" as="script"><link rel="prefetch" href="/blog/assets/js/category_网络编程_index.html.9fbff410.js" as="script"><link rel="prefetch" href="/blog/assets/js/category_诊断工具_index.html.058b28c3.js" as="script"><link rel="prefetch" href="/blog/assets/js/category_调试诊断_index.html.240d7a78.js" as="script"><link rel="prefetch" href="/blog/assets/js/category_运维工具_index.html.e1b23343.js" as="script"><link rel="prefetch" href="/blog/assets/js/category_面渣逆袭_index.html.ca360068.js" as="script"><link rel="prefetch" href="/blog/assets/js/category_项目实战_index.html.4c25dc84.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_java-mission-control_index.html.177b4357.js" as="script"><link rel="prefetch" href="/blog/assets/js/JVM_一命速通_3.GC垃圾回收机制_index.html.22f156f1.js" as="script"><link rel="prefetch" href="/blog/assets/js/category_内存泄漏_index.html.e3bfbd08.js" as="script"><link rel="prefetch" href="/blog/assets/js/category_故障排查_index.html.8e9d645c.js" as="script"><link rel="prefetch" href="/blog/assets/js/category_性能调优_index.html.c7352e80.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_黑马Java2023_08并发编程_01基础知识_index.html.1f9b73df.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_黑马Java2023_08并发编程_02并发安全_index.html.c02151fb.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_Java_03-Java并发编程面试题_index.html.bbcfb397.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_三级缓存_index.html.3b783f0e.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_依赖注入_index.html.70b1c399.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_内存泄漏_index.html.76dac890.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_内存管理_index.html.c5924452.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_内存结构_index.html.5e3e3af4.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_参数调优_index.html.47339369.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_基础知识_index.html.d6f0ee21.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_实战经验_index.html.fd35520a.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_常用命令_index.html.d5da01cd.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_异步日志_index.html.22c45607.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_循环依赖_index.html.1ec11ce4.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_性能优化_index.html.5b112d2b.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_性能分析_index.html.f65c4e1e.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_性能监控_index.html.4a3cb4a4.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_性能调优_index.html.40fd640c.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_接口文档_index.html.a59fb9d7.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_接口示例_index.html.750f9baa.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_故障排查_index.html.ee136a71.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_日志切面_index.html.a1d788b5.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_机制详解_index.html.c9a68460.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_案例分析_index.html.1a7b178f.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_版本控制_index.html.7177b60c.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_系统监控_index.html.aab80388.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_网络编程_index.html.34173ca6.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_自动生成_index.html.0a0a078f.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_触发条件_index.html.edbf7dd2.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_课堂随笔_index.html.1dce966d.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_调优实战_index.html.b28719a3.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_调试工具_index.html.1e86d5f2.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_调试技巧_index.html.496a29d5.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_配置文件_index.html.d2cbe584.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_阅读完毕_index.html.8d425f70.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_面渣逆袭_index.html.3e7757c7.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_高级特性_index.html.f567c504.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_高频问题_index.html.6a2c7b6b.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_内存排查_index.html.69a2d80d.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_分库分表_index.html.0e1428fe.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_多级日志_index.html.2fd85b7d.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_执行流程_index.html.40078662.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_日志归档_index.html.9497491d.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_构造函数_index.html.3c271695.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_直接内存_index.html.91475e51.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_线程模型_index.html.231dae3e.js" as="script"><link rel="prefetch" href="/blog/assets/js/Linux_13.服务与自动化管理_index.html.9c87d522.js" as="script"><link rel="prefetch" href="/blog/assets/js/项目实战_谷粒商城_报错记录_index.html.70f7c181.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_Java_08-数据结构面试题_index.html.195976d5.js" as="script"><link rel="prefetch" href="/blog/assets/js/category_服务器_index.html.5995da34.js" as="script"><link rel="prefetch" href="/blog/assets/js/category_面试题_index.html.845f8417.js" as="script"><link rel="prefetch" href="/blog/assets/js/category_中间件_index.html.97ec3efb.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_Java_04-Java虚拟机面试题_index.html.9821df56.js" as="script"><link rel="prefetch" href="/blog/assets/js/category_java基础_index.html.6ae7f865.js" as="script"><link rel="prefetch" href="/blog/assets/js/category_数据库_index.html.83e606c4.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_docker安装_index.html.8b93a24a.js" as="script"><link rel="prefetch" href="/blog/assets/js/category_java高级_index.html.c878be91.js" as="script"><link rel="prefetch" href="/blog/assets/js/category_mybatis-plus_index.html.c04e2de5.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_java8特性_index.html.275356c9.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_happens-before_index.html.65ed2ea4.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_stop-the-world_index.html.01b1690a.js" as="script"><link rel="prefetch" href="/blog/assets/js/Database_Redis_3.高级_01-分布式缓存_index.html.94233e6d.js" as="script"><link rel="prefetch" href="/blog/assets/js/Database_Redis_3.高级_03-Redis最佳实践_index.html.0f697d28.js" as="script"><link rel="prefetch" href="/blog/assets/js/Linux_15.故障排除与修复_index.html.e8992ef7.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_低质量_index.html.79d8906a.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_初始化_index.html.bc7fe59a.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_堆分析_index.html.5c30e37b.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_多线程_index.html.9117e7ac.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_工具链_index.html.bec5721f.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_方法区_index.html.efe49882.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_类加载_index.html.26bf24f2.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_虚拟机_index.html.e51786c3.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_连接池_index.html.fa2d3d68.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_可视化_index.html.54e87301.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_私有云_index.html.d8414901.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_面试题_index.html.e0348b12.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_高质量_index.html.23bd3270.js" as="script"><link rel="prefetch" href="/blog/assets/js/category_gc机制_index.html.761b9ddc.js" as="script"><link rel="prefetch" href="/blog/assets/js/category_springcloud_index.html.43c30a9b.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_java基础_index.html.f180dfb2.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_微服务_index.html.130cbbc0.js" as="script"><link rel="prefetch" href="/blog/assets/js/Linux_6.网络配置与管理_index.html.3e11fb6a.js" as="script"><link rel="prefetch" href="/blog/assets/js/Linux_7.文件与目录管理_index.html.391a9e03.js" as="script"><link rel="prefetch" href="/blog/assets/js/Linux_9.磁盘管理与存储_index.html.6a488e15.js" as="script"><link rel="prefetch" href="/blog/assets/js/category_spring-boot_index.html.b3b456a1.js" as="script"><link rel="prefetch" href="/blog/assets/js/Database_MySQL_MySQL卸载文档-Windows_index.html.6ed31eec.js" as="script"><link rel="prefetch" href="/blog/assets/js/Database_MySQL_MySQL安装文档-Windows_index.html.d4ae3486.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_面试答题卡_数据结构_index.html.2599effa.js" as="script"><link rel="prefetch" href="/blog/assets/js/Linux_4.系统与进程管理_index.html.4322bebf.js" as="script"><link rel="prefetch" href="/blog/assets/js/category_middleware_index.html.9282224a.js" as="script"><link rel="prefetch" href="/blog/assets/js/category_springboot_index.html.99adb94f.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_directmemory_index.html.121087f8.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_mat分析_index.html.f81ddca1.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_sql优化_index.html.86be5054.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_yum安装_index.html.1c491b07.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_Java_01-Java基础面试题_index.html.1c0203ef.js" as="script"><link rel="prefetch" href="/blog/assets/js/Database_MySQL_MySQL卸载文档-Linux_index.html.77099bd5.js" as="script"><link rel="prefetch" href="/blog/assets/js/Database_MySQL_MySQL安装文档-Linux_index.html.20254fd7.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_Java_02-Java集合面试题_index.html.e39faa3d.js" as="script"><link rel="prefetch" href="/blog/assets/js/category_实战_index.html.992f8ceb.js" as="script"><link rel="prefetch" href="/blog/assets/js/category_网络_index.html.0135c50b.js" as="script"><link rel="prefetch" href="/blog/assets/js/category_装机_index.html.ee8a94bd.js" as="script"><link rel="prefetch" href="/blog/assets/js/category_面试_index.html.ca097731.js" as="script"><link rel="prefetch" href="/blog/assets/js/category_项目_index.html.e4746c05.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_gc日志_index.html.87312dc2.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_gc诊断_index.html.d128e952.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_gc调优_index.html.06ec023d.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_gc阶段_index.html.30749003.js" as="script"><link rel="prefetch" href="/blog/assets/js/category_工具_index.html.bd49473f.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_se基础_index.html.7e3cf171.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_面试答题卡_index.html.e2b2991e.js" as="script"><link rel="prefetch" href="/blog/assets/js/Python_index.html.c8abaf0e.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_shenandoah_index.html.180796e7.js" as="script"><link rel="prefetch" href="/blog/assets/js/Database_Redis_3.高级_02-多级缓存_index.html.5fb4ff45.js" as="script"><link rel="prefetch" href="/blog/assets/js/SpringCloud_高级_分布式事务_index.html.c1c1dced.js" as="script"><link rel="prefetch" href="/blog/assets/js/Database_MySQL_MyCat-Web安装文档_index.html.92b1f233.js" as="script"><link rel="prefetch" href="/blog/assets/js/SpringCloud_index.html.342dbd4c.js" as="script"><link rel="prefetch" href="/blog/assets/js/category_markdown_index.html.162868dd.js" as="script"><link rel="prefetch" href="/blog/assets/js/项目实战_谷粒商城_板书_index.html.b67917d1.js" as="script"><link rel="prefetch" href="/blog/assets/js/Linux_8.Shell与脚本编程_index.html.ffe1c3a5.js" as="script"><link rel="prefetch" href="/blog/assets/js/Java_入门到起飞_31.多线程_index.html.602d3354.js" as="script"><link rel="prefetch" href="/blog/assets/js/Linux_3.用户与组管理_index.html.6da59a49.js" as="script"><link rel="prefetch" href="/blog/assets/js/category_mybatis_index.html.4894bb25.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_了解_index.html.ecd9648d.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_事务_index.html.0044a2c4.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_使用_index.html.5131d3b6.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_入门_index.html.eed26a51.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_卸载_index.html.b1697353.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_反射_index.html.32f1407b.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_命令_index.html.69b1e459.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_坑王_index.html.9cce34bb.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_基础_index.html.eb3a8149.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_安全_index.html.bfcd235b.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_安装_index.html.e2d6e1a3.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_容器_index.html.2255a6fc.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_必背_index.html.04b1ce12.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_总结_index.html.29b9f11f.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_排查_index.html.0daa08f8.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_插件_index.html.d014632d.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_教程_index.html.f19541da.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_架构_index.html.9fc77fec.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_爬虫_index.html.2f540f9c.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_目录_index.html.1896117b.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_笔记_index.html.47e511bd.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_简单_index.html.3aefd89b.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_经验_index.html.499f6253.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_网络_index.html.7f3a9817.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_装机_index.html.8bfd3100.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_诊断_index.html.2dad8eee.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_踩坑_index.html.44ea6bd5.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_运维_index.html.76037aa9.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_重点_index.html.e49eed21.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_镜像_index.html.9b6c5d59.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_面试_index.html.e8279c83.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_风险_index.html.38431b65.js" as="script"><link rel="prefetch" href="/blog/assets/js/SpringBoot_index.html.99c2b09d.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_并发_index.html.dab5cb78.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_查询_index.html.8bf196b3.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_注解_index.html.29427b89.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_讲义_index.html.f2836424.js" as="script"><link rel="prefetch" href="/blog/assets/js/category_windows_index.html.a0d63f6b.js" as="script"><link rel="prefetch" href="/blog/assets/js/category_devops_index.html.5f93dbaf.js" as="script"><link rel="prefetch" href="/blog/assets/js/category_docker_index.html.5b2fa542.js" as="script"><link rel="prefetch" href="/blog/assets/js/category_lombok_index.html.d7b729bf.js" as="script"><link rel="prefetch" href="/blog/assets/js/category_python_index.html.f127ec96.js" as="script"><link rel="prefetch" href="/blog/assets/js/category_tomcat_index.html.effa5c76.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_rabbitmq_index.html.0d6500e0.js" as="script"><link rel="prefetch" href="/blog/assets/js/SpringMVC_index.html.5b446489.js" as="script"><link rel="prefetch" href="/blog/assets/js/category_spring_index.html.2fdc451d.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_sentinel_index.html.8336fbff.js" as="script"><link rel="prefetch" href="/blog/assets/js/项目实战_个人博客_index.html.2313e13d.js" as="script"><link rel="prefetch" href="/blog/assets/js/category_linux_index.html.f3228c14.js" as="script"><link rel="prefetch" href="/blog/assets/js/category_maven_index.html.7d60d030.js" as="script"><link rel="prefetch" href="/blog/assets/js/category_mycat_index.html.86a2db6b.js" as="script"><link rel="prefetch" href="/blog/assets/js/category_mysql_index.html.26b31028.js" as="script"><link rel="prefetch" href="/blog/assets/js/category_netty_index.html.fa203ef0.js" as="script"><link rel="prefetch" href="/blog/assets/js/category_nginx_index.html.407b8d93.js" as="script"><link rel="prefetch" href="/blog/assets/js/category_redis_index.html.4cbc3ebc.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_jenkins_index.html.2191329b.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_算法_力扣_字符串_index.html.58b0837e.js" as="script"><link rel="prefetch" href="/blog/assets/js/category_nacos_index.html.c1176a12.js" as="script"><link rel="prefetch" href="/blog/assets/js/Database_MySQL_MyCat安装文档_index.html.76c9f340.js" as="script"><link rel="prefetch" href="/blog/assets/js/Database_MySQL_MyCat配置文件_index.html.a7c285e2.js" as="script"><link rel="prefetch" href="/blog/assets/js/Database_MySQL_MySQL学习笔记_index.html.be35453d.js" as="script"><link rel="prefetch" href="/blog/assets/js/Database_MySQL_MySQL安全配置_index.html.aafb2055.js" as="script"><link rel="prefetch" href="/blog/assets/js/Database_MySQL_MySQL故障修复_index.html.aca33ef0.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_arthas_index.html.3a80533f.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_lombok_index.html.df6bbda8.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_rebase_index.html.7fb84a87.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_spring_index.html.159371bd.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_tomcat_index.html.202f6e83.js" as="script"><link rel="prefetch" href="/blog/assets/js/category_java_index.html.9d6f99cf.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_Java_热点面试题_index.html.1992ee3f.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_黑马Java2021_01基础篇_index.html.b31021c1.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_黑马Java2021_02并发篇_index.html.d71d4fdc.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_黑马Java2021_03虚拟机_index.html.79412479.js" as="script"><link rel="prefetch" href="/blog/assets/js/SSM_03-Maven高级笔记_index.html.23d2c968.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_log4j2_index.html.3ec8af8c.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_Java_05-Spring面试题_index.html.16859e1b.js" as="script"><link rel="prefetch" href="/blog/assets/js/Linux_1.安装与配置_index.html.409252b0.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_Java_06-MySQL面试题_index.html.97ec8c59.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_黑马Java2021_04框架篇_index.html.5df17691.js" as="script"><link rel="prefetch" href="/blog/assets/js/Linux_5.软件包管理_index.html.56426779.js" as="script"><link rel="prefetch" href="/blog/assets/js/category_git_index.html.5580a9b7.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_error_index.html.653dfe72.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_linux_index.html.a2b86b09.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_merge_index.html.591e3107.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_seata_index.html.78f4240a.js" as="script"><link rel="prefetch" href="/blog/assets/js/Spring_index.html.1f301026.js" as="script"><link rel="prefetch" href="/blog/assets/js/category_aop_index.html.6d2b723a.js" as="script"><link rel="prefetch" href="/blog/assets/js/category_jvm_index.html.92fde854.js" as="script"><link rel="prefetch" href="/blog/assets/js/category_vue_index.html.10b01273.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_hprof_index.html.c4aa97c7.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_mysql_index.html.19e39304.js" as="script"><link rel="prefetch" href="/blog/assets/js/设计模式_A创建型_index.html.f1927c50.js" as="script"><link rel="prefetch" href="/blog/assets/js/设计模式_B结构型_index.html.d2b8e86f.js" as="script"><link rel="prefetch" href="/blog/assets/js/设计模式_C行为型_index.html.0bed5114.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_Java_07-Redis面试题_index.html.dc9fd3e0.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_栈_index.html.2e806965.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_堆_index.html.95c45ee9.js" as="script"><link rel="prefetch" href="/blog/assets/js/category_es_index.html.c387c936.js" as="script"><link rel="prefetch" href="/blog/assets/js/category_gc_index.html.05e6980c.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_cicd_index.html.b68870fd.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_java_index.html.85792326.js" as="script"><link rel="prefetch" href="/blog/assets/js/SSM_02-SpringMVC笔记_SpringMVC_day02_index.html.708dfdbe.js" as="script"><link rel="prefetch" href="/blog/assets/js/Java_入门到起飞_index.html.061d0c61.js" as="script"><link rel="prefetch" href="/blog/assets/js/SSM_02-SpringMVC笔记_SpringMVC_day01_index.html.4400276d.js" as="script"><link rel="prefetch" href="/blog/assets/js/SSM_03-Maven高级笔记_随笔_index.html.fe7944a7.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_aop_index.html.481d66e7.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_bug_index.html.d3c9f1e6.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_cms_index.html.2b12fb9c.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_git_index.html.5530e766.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_jdk_index.html.8c3ed87a.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_jfr_index.html.41078f2a.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_jmc_index.html.1e6c3b4c.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_jmm_index.html.7d4fe930.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_jvm_index.html.f9e6a3ef.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_mat_index.html.cd8218e7.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_oom_index.html.54f599ba.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_sql_index.html.d516984a.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_zgc_index.html.18159c57.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_api_index.html.d4b193c8.js" as="script"><link rel="prefetch" href="/blog/assets/js/SSM_05-Mybatisplus笔记_index.html.73c75f79.js" as="script"><link rel="prefetch" href="/blog/assets/js/Database_Redis_课前资料_index.html.2dc54da9.js" as="script"><link rel="prefetch" href="/blog/assets/js/SSM_04-SpringBoot笔记_index.html.a8139618.js" as="script"><link rel="prefetch" href="/blog/assets/js/计算机基础_index.html.16af6a45.js" as="script"><link rel="prefetch" href="/blog/assets/js/计算机基础_网络_index.html.59ade7a5.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_Java_09-MQ面试题_index.html.05a0bdae.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_g1_index.html.6f8e2ae6.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_gc_index.html.712d0144.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_mq_index.html.112d0856.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_面试答题卡_MySQL_index.html.ca7e6b9b.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_面试答题卡_Spring_index.html.6badc370.js" as="script"><link rel="prefetch" href="/blog/assets/js/Linux_2.文件系统_index.html.66b6860c.js" as="script"><link rel="prefetch" href="/blog/assets/js/Nginx_index.html.d6a4fd99.js" as="script"><link rel="prefetch" href="/blog/assets/js/SSM_02-SpringMVC笔记_index.html.3cf013f0.js" as="script"><link rel="prefetch" href="/blog/assets/js/42771.91a1b5e9.js" as="script"><link rel="prefetch" href="/blog/assets/js/SpringBoot_日志框架_index.html.b9d6f5fb.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_面试准备_index.html.ee010531.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_面试答题卡_Linux_index.html.77c49e79.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_面试记录_index.html.e7d672b3.js" as="script"><link rel="prefetch" href="/blog/assets/js/JVM_2.内存结构_index.html.afc97288.js" as="script"><link rel="prefetch" href="/blog/assets/js/Database_Redis_index.html.2dcb5bb3.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_Java_10-分布式_index.html.b5166b8d.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_面试答题卡_Java_index.html.c5f2754c.js" as="script"><link rel="prefetch" href="/blog/assets/js/SSM_01-Spring笔记_spring_day02_index.html.727b3c45.js" as="script"><link rel="prefetch" href="/blog/assets/js/SSM_01-Spring笔记_spring_day03_index.html.448dc846.js" as="script"><link rel="prefetch" href="/blog/assets/js/SSM_01-Spring笔记_spring_day01_index.html.06d1d668.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_黑马Java2021_index.html.ba029d6e.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_黑马Java2023_index.html.bc3840c0.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_面试答题卡_Git_index.html.ce1f374e.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_面试答题卡_JVM_index.html.e899bf15.js" as="script"><link rel="prefetch" href="/blog/assets/js/Java_唯手熟尔_index.html.5888d89e.js" as="script"><link rel="prefetch" href="/blog/assets/js/Java_核心类库_index.html.86b419fc.js" as="script"><link rel="prefetch" href="/blog/assets/js/SSM_02-SpringMVC笔记_随笔_index.html.715a478d.js" as="script"><link rel="prefetch" href="/blog/assets/js/SpringCloud_实用_MQ_安装_index.html.b52d30c4.js" as="script"><link rel="prefetch" href="/blog/assets/js/Database_MySQL_MySQL优化_index.html.4c7a55cb.js" as="script"><link rel="prefetch" href="/blog/assets/js/Database_MySQL_MySQL小白_index.html.04fb5ad7.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_面试答题卡_OS_index.html.a265aefd.js" as="script"><link rel="prefetch" href="/blog/assets/js/SSM_01-Spring笔记_随笔_index.html.8b6382c6.js" as="script"><link rel="prefetch" href="/blog/assets/js/SSM_01-Spring笔记_index.html.c25d12cf.js" as="script"><link rel="prefetch" href="/blog/assets/js/软件工程_UML图_index.html.ba92dd63.js" as="script"><link rel="prefetch" href="/blog/assets/js/Netty_index.html.65db1c6d.js" as="script"><link rel="prefetch" href="/blog/assets/js/category_index.html.155c8344.js" as="script"><link rel="prefetch" href="/blog/assets/js/项目实战_index.html.7d05baa1.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_算法_力扣_index.html.2b0d61cd.js" as="script"><link rel="prefetch" href="/blog/assets/js/SpringBoot_lombok注解_index.html.e64cc0ae.js" as="script"><link rel="prefetch" href="/blog/assets/js/timeline_index.html.7b2ea859.js" as="script"><link rel="prefetch" href="/blog/assets/js/设计模式_index.html.f6e07426.js" as="script"><link rel="prefetch" href="/blog/assets/js/软件工程_index.html.2a6c3928.js" as="script"><link rel="prefetch" href="/blog/assets/js/SpringCloud_高级_Sentinel_index.html.c5d06934.js" as="script"><link rel="prefetch" href="/blog/assets/js/装机_N1盒子_index.html.ed425b9e.js" as="script"><link rel="prefetch" href="/blog/assets/js/Docker_index.html.1c24ae43.js" as="script"><link rel="prefetch" href="/blog/assets/js/Mybatis_Mybatis Plus_接口_index.html.0f5efd49.js" as="script"><link rel="prefetch" href="/blog/assets/js/Mybatis_Mybatis Plus_注解_index.html.8b185c03.js" as="script"><link rel="prefetch" href="/blog/assets/js/Docker_私有云_index.html.075064de.js" as="script"><link rel="prefetch" href="/blog/assets/js/Database_Redis_1.入门_index.html.5b9e9ef9.js" as="script"><link rel="prefetch" href="/blog/assets/js/Database_Redis_2.实战_index.html.6be686a7.js" as="script"><link rel="prefetch" href="/blog/assets/js/Database_Redis_3.高级_index.html.5a335cba.js" as="script"><link rel="prefetch" href="/blog/assets/js/Database_Redis_4.原理_index.html.b2e59685.js" as="script"><link rel="prefetch" href="/blog/assets/js/Java_Java8特性_index.html.eecfb5cd.js" as="script"><link rel="prefetch" href="/blog/assets/js/Java_面试题_index.html.117bb112.js" as="script"><link rel="prefetch" href="/blog/assets/js/article_index.html.569e8c23.js" as="script"><link rel="prefetch" href="/blog/assets/js/tag_index.html.2856d096.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_SQL刷题_index.html.0dc0ebdc.js" as="script"><link rel="prefetch" href="/blog/assets/js/Java_工具类_index.html.f33c625a.js" as="script"><link rel="prefetch" href="/blog/assets/js/SpringCloud_实用_Docker_index.html.865e8687.js" as="script"><link rel="prefetch" href="/blog/assets/js/SpringCloud_高级_Jmeter_index.html.59404b3f.js" as="script"><link rel="prefetch" href="/blog/assets/js/SpringCloud_高级_Sentinel_bug_index.html.cb4ac0bc.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_Java_A基础_index.html.f6081939.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_Java_B中等_index.html.50b4686d.js" as="script"><link rel="prefetch" href="/blog/assets/js/Mybatis_Mybatis Plus_index.html.07c14222.js" as="script"><link rel="prefetch" href="/blog/assets/js/SpringCloud_高级_Seata_index.html.cce0a084.js" as="script"><link rel="prefetch" href="/blog/assets/js/Database_MySQL_基础_index.html.cea81701.js" as="script"><link rel="prefetch" href="/blog/assets/js/Database_MySQL_工具_index.html.1773e91c.js" as="script"><link rel="prefetch" href="/blog/assets/js/Database_MySQL_进阶_index.html.742b1e03.js" as="script"><link rel="prefetch" href="/blog/assets/js/Database_MySQL_随笔_index.html.49062f21.js" as="script"><link rel="prefetch" href="/blog/assets/js/Database_Redis_随笔_index.html.a3746d8d.js" as="script"><link rel="prefetch" href="/blog/assets/js/SpringCloud_Alibaba-OSS_index.html.60c75623.js" as="script"><link rel="prefetch" href="/blog/assets/js/star_index.html.afb8a4ab.js" as="script"><link rel="prefetch" href="/blog/assets/js/Database_MySQL_运维_index.html.03942232.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_index.html.13f4f231.js" as="script"><link rel="prefetch" href="/blog/assets/js/Linux_0.笔记_index.html.3023fc28.js" as="script"><link rel="prefetch" href="/blog/assets/js/MQ_RabbitMQ_基础_index.html.54c2bd7a.js" as="script"><link rel="prefetch" href="/blog/assets/js/MQ_RabbitMQ_高级_index.html.b25db897.js" as="script"><link rel="prefetch" href="/blog/assets/js/SpringCloud_基础_index.html.af52f5a3.js" as="script"><link rel="prefetch" href="/blog/assets/js/SpringCloud_实用_index.html.794ad781.js" as="script"><link rel="prefetch" href="/blog/assets/js/SSM_01-Spring笔记_AOP_index.html.4c4da2e0.js" as="script"><link rel="prefetch" href="/blog/assets/js/SpringBoot_注解_index.html.4f4df5c6.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_算法_index.html.eda753a7.js" as="script"><link rel="prefetch" href="/blog/assets/js/Docker_随笔_index.html.8a138fac.js" as="script"><link rel="prefetch" href="/blog/assets/js/Python_基础_index.html.3d54bf3d.js" as="script"><link rel="prefetch" href="/blog/assets/js/SpringCloud_实用_ES_index.html.ec44908e.js" as="script"><link rel="prefetch" href="/blog/assets/js/SpringCloud_实用_MQ_index.html.11b9ddb1.js" as="script"><link rel="prefetch" href="/blog/assets/js/Spring_注解_index.html.899d1ded.js" as="script"><link rel="prefetch" href="/blog/assets/js/Python_爬虫_index.html.6b49fe8f.js" as="script"><link rel="prefetch" href="/blog/assets/js/Java_异常_index.html.7adb20a6.js" as="script"><link rel="prefetch" href="/blog/assets/js/Java_架构_index.html.dc66d304.js" as="script"><link rel="prefetch" href="/blog/assets/js/Java_队列_index.html.bac1c5b9.js" as="script"><link rel="prefetch" href="/blog/assets/js/Java_随笔_index.html.c49db34a.js" as="script"><link rel="prefetch" href="/blog/assets/js/Le Penseur_index.html.47c9d2d5.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_sanfene_index.html.c06543c4.js" as="script"><link rel="prefetch" href="/blog/assets/js/前端_node_index.html.cb067259.js" as="script"><link rel="prefetch" href="/blog/assets/js/前端_index.html.9f5f0777.js" as="script"><link rel="prefetch" href="/blog/assets/js/网络_index.html.fd93de38.js" as="script"><link rel="prefetch" href="/blog/assets/js/装机_index.html.11f29d09.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_Java_index.html.d4b1d0fc.js" as="script"><link rel="prefetch" href="/blog/assets/js/MQ_RabbitMQ_index.html.02e2b7c7.js" as="script"><link rel="prefetch" href="/blog/assets/js/Mybatis_Mybatis_index.html.527c3a0a.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_Spring_index.html.fed455af.js" as="script"><link rel="prefetch" href="/blog/assets/js/Interview_MySQL_index.html.9854a4ab.js" as="script"><link rel="prefetch" href="/blog/assets/js/Database_index.html.01e6f15b.js" as="script"><link rel="prefetch" href="/blog/assets/js/Spring_Junit_index.html.6d8317b3.js" as="script"><link rel="prefetch" href="/blog/assets/js/Java_String_index.html.23f21b58.js" as="script"><link rel="prefetch" href="/blog/assets/js/Mybatis_index.html.6296d9d5.js" as="script"><link rel="prefetch" href="/blog/assets/js/MQ_Kafka_index.html.196b4b76.js" as="script"><link rel="prefetch" href="/blog/assets/js/Bug_Java_index.html.6665c673.js" as="script"><link rel="prefetch" href="/blog/assets/js/Netty_API_index.html.104827b3.js" as="script"><link rel="prefetch" href="/blog/assets/js/VCS_Git_index.html.4bfded9d.js" as="script"><link rel="prefetch" href="/blog/assets/js/CICD_index.html.779a49fe.js" as="script"><link rel="prefetch" href="/blog/assets/js/Bug_index.html.48809fbd.js" as="script"><link rel="prefetch" href="/blog/assets/js/VCS_index.html.2dd3e119.js" as="script"><link rel="prefetch" href="/blog/assets/js/404.html.7b058f71.js" as="script"><link rel="prefetch" href="/blog/assets/js/MQ_index.html.03446d9b.js" as="script"><link rel="prefetch" href="/blog/assets/js/52666.bc9abe6c.js" as="script"><link rel="prefetch" href="/blog/assets/js/78070.ebbf2996.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="vp-skip-link sr-only">跳至主要內容</a><!--]--><div class="theme-container external-link-icon has-toc" vp-container><!--[--><header id="navbar" class="vp-navbar" vp-navbar><div class="vp-navbar-start"><button type="button" class="vp-toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!----><!--[--><a class="route-link vp-brand" href="/blog/" aria-label="带我回家"><img class="vp-nav-logo" src="/blog/assets/images/avatar.png" alt><!----><span class="vp-site-name hide-in-pad">小满</span></a><!--]--><!----></div><div class="vp-navbar-center"><!----><!--[--><nav class="vp-nav-links"><div class="vp-nav-item hide-in-mobile"><a class="route-link auto-link" href="/blog/" aria-label="主页"><!--[--><span class="font-icon icon fa-fw fa-sm fas fa-home" style=""></span><!--]-->主页<!----></a></div><div class="vp-nav-item hide-in-mobile"><div class="vp-dropdown-wrapper"><button type="button" class="vp-dropdown-title" aria-label="后端"><!--[--><span class="font-icon icon fa-fw fa-sm fas fa-code" style=""></span>后端<!--]--><span class="arrow"></span><ul class="vp-dropdown"><li class="vp-dropdown-item"><a class="route-link auto-link" href="/blog/Java/" aria-label="Java"><!--[--><span class="font-icon icon fa-fw fa-sm fa-brands fa-java" style=""></span><!--]-->Java<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/blog/Python/" aria-label="Python"><!--[--><span class="font-icon icon fa-fw fa-sm fa-brands fa-python" style=""></span><!--]-->Python<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/blog/JVM/" aria-label="JVM"><!--[--><span class="font-icon icon fa-fw fa-sm fa-solid fa-microchip" style=""></span><!--]-->JVM<!----></a></li></ul></button></div></div><div class="vp-nav-item hide-in-mobile"><a class="route-link auto-link" href="/blog/Vue/" aria-label="Vue"><!--[--><span class="font-icon icon fa-fw fa-sm fa-brands fa-vuejs" style=""></span><!--]-->Vue<!----></a></div><div class="vp-nav-item hide-in-mobile"><div class="vp-dropdown-wrapper"><button type="button" class="vp-dropdown-title" aria-label="Spring"><!--[--><span class="font-icon icon fa-fw fa-sm fa-solid fa-leaf" style=""></span>Spring<!--]--><span class="arrow"></span><ul class="vp-dropdown"><li class="vp-dropdown-item"><a class="route-link auto-link" href="/blog/Spring/" aria-label="Spring"><!--[--><span class="font-icon icon fa-fw fa-sm fa-solid fa-leaf" style=""></span><!--]-->Spring<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/blog/SpringBoot/" aria-label="SpringBoot"><!--[--><span class="font-icon icon fa-fw fa-sm fa-solid fa-leaf" style=""></span><!--]-->SpringBoot<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/blog/SpringMVC/" aria-label="SpringMVC"><!--[--><span class="font-icon icon fa-fw fa-sm fa-solid fa-leaf" style=""></span><!--]-->SpringMVC<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/blog/SSM/" aria-label="SSM"><!--[--><span class="font-icon icon fa-fw fa-sm fa-solid fa-leaf" style=""></span><!--]-->SSM<!----></a></li></ul></button></div></div><div class="vp-nav-item hide-in-mobile"><div class="vp-dropdown-wrapper"><button type="button" class="vp-dropdown-title" aria-label="SpringCloud"><!--[--><span class="font-icon icon fa-fw fa-sm fa-solid fa-cloud" style=""></span>SpringCloud<!--]--><span class="arrow"></span><ul class="vp-dropdown"><li class="vp-dropdown-item"><a class="route-link auto-link" href="/blog/SpringCloud/%E9%AB%98%E7%BA%A7/" aria-label="高级篇"><!--[--><span class="font-icon icon fa-fw fa-sm fa-brands fa-web-awesome" style=""></span><!--]-->高级篇<!----></a></li></ul></button></div></div><div class="vp-nav-item hide-in-mobile"><div class="vp-dropdown-wrapper"><button type="button" class="vp-dropdown-title" aria-label="数据库"><!--[--><span class="font-icon icon fa-fw fa-sm fa-solid fa-database" style=""></span>数据库<!--]--><span class="arrow"></span><ul class="vp-dropdown"><li class="vp-dropdown-item"><a class="route-link auto-link" href="/blog/Database/MySQL/" aria-label="MySQL"><!--[--><span class="font-icon icon fa-fw fa-sm fa-solid fa-database" style=""></span><!--]-->MySQL<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/blog/Database/Redis/" aria-label="Redis"><!--[--><span class="font-icon icon fa-fw fa-sm fa-solid fa-server" style=""></span><!--]-->Redis<!----></a></li></ul></button></div></div><div class="vp-nav-item hide-in-mobile"><a class="route-link auto-link" href="/blog/Docker/" aria-label="Docker"><!--[--><span class="font-icon icon fa-fw fa-sm fa-brands fa-docker" style=""></span><!--]-->Docker<!----></a></div><div class="vp-nav-item hide-in-mobile"><div class="vp-dropdown-wrapper"><button type="button" class="vp-dropdown-title" aria-label="Linux"><!--[--><span class="font-icon icon fa-fw fa-sm fa-brands fa-linux" style=""></span>Linux<!--]--><span class="arrow"></span><ul class="vp-dropdown"><li class="vp-dropdown-item"><a class="route-link auto-link" href="/blog/Linux/" aria-label="Linux"><!--[--><span class="font-icon icon fa-fw fa-sm fa-brands fa-linux" style=""></span><!--]-->Linux<!----></a></li></ul></button></div></div><div class="vp-nav-item hide-in-mobile"><a class="route-link auto-link" href="/blog/Netty/" aria-label="Netty"><!--[--><span class="font-icon icon fa-fw fa-sm fa-solid fa-n" style=""></span><!--]-->Netty<!----></a></div><div class="vp-nav-item hide-in-mobile"><div class="vp-dropdown-wrapper"><button type="button" class="vp-dropdown-title" aria-label="项目实战"><!--[--><span class="font-icon icon fa-fw fa-sm fa-brands fa-product-hunt" style=""></span>项目实战<!--]--><span class="arrow"></span><ul class="vp-dropdown"><li class="vp-dropdown-item"><a class="route-link auto-link" href="/blog/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E/" aria-label="谷粒商城"><!--[--><span class="font-icon icon fa-fw fa-sm fa-brands fa-codepen" style=""></span><!--]-->谷粒商城<!----></a></li></ul></button></div></div><div class="vp-nav-item hide-in-mobile"><a class="route-link auto-link" href="/blog/Interview/" aria-label="面试题"><!--[--><span class="font-icon icon fa-fw fa-sm fa-solid fa-book-tanakh" style=""></span><!--]-->面试题<!----></a></div></nav><!--]--><!----></div><div class="vp-navbar-end"><!----><!--[--><!----><div class="vp-nav-item vp-action"><a class="vp-action-link" href="https://github.com/JL-20191210/blog" target="_blank" rel="noopener noreferrer" aria-label="GitHub"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="github icon" name="github" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></svg></a></div><div class="vp-nav-item hide-in-mobile"><button type="button" class="vp-outlook-button" tabindex="-1" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" class="icon outlook-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="outlook icon" name="outlook"><path d="M224 800c0 9.6 3.2 44.8 6.4 54.4 6.4 48-48 76.8-48 76.8s80 41.6 147.2 0 134.4-134.4 38.4-195.2c-22.4-12.8-41.6-19.2-57.6-19.2C259.2 716.8 227.2 761.6 224 800zM560 675.2l-32 51.2c-51.2 51.2-83.2 32-83.2 32 25.6 67.2 0 112-12.8 128 25.6 6.4 51.2 9.6 80 9.6 54.4 0 102.4-9.6 150.4-32l0 0c3.2 0 3.2-3.2 3.2-3.2 22.4-16 12.8-35.2 6.4-44.8-9.6-12.8-12.8-25.6-12.8-41.6 0-54.4 60.8-99.2 137.6-99.2 6.4 0 12.8 0 22.4 0 12.8 0 38.4 9.6 48-25.6 0-3.2 0-3.2 3.2-6.4 0-3.2 3.2-6.4 3.2-6.4 6.4-16 6.4-16 6.4-19.2 9.6-35.2 16-73.6 16-115.2 0-105.6-41.6-198.4-108.8-268.8C704 396.8 560 675.2 560 675.2zM224 419.2c0-28.8 22.4-51.2 51.2-51.2 28.8 0 51.2 22.4 51.2 51.2 0 28.8-22.4 51.2-51.2 51.2C246.4 470.4 224 448 224 419.2zM320 284.8c0-22.4 19.2-41.6 41.6-41.6 22.4 0 41.6 19.2 41.6 41.6 0 22.4-19.2 41.6-41.6 41.6C339.2 326.4 320 307.2 320 284.8zM457.6 208c0-12.8 12.8-25.6 25.6-25.6 12.8 0 25.6 12.8 25.6 25.6 0 12.8-12.8 25.6-25.6 25.6C470.4 233.6 457.6 220.8 457.6 208zM128 505.6C128 592 153.6 672 201.6 736c28.8-60.8 112-60.8 124.8-60.8-16-51.2 16-99.2 16-99.2l316.8-422.4c-48-19.2-99.2-32-150.4-32C297.6 118.4 128 291.2 128 505.6zM764.8 86.4c-22.4 19.2-390.4 518.4-390.4 518.4-22.4 28.8-12.8 76.8 22.4 99.2l9.6 6.4c35.2 22.4 80 12.8 99.2-25.6 0 0 6.4-12.8 9.6-19.2 54.4-105.6 275.2-524.8 288-553.6 6.4-19.2-3.2-32-19.2-32C777.6 76.8 771.2 80 764.8 86.4z"></path></svg><div class="vp-outlook-dropdown"><!----></div></button></div><!----><!--]--><!----><button type="button" class="vp-toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span><span class="vp-top"></span><span class="vp-middle"></span><span class="vp-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow start"></span></div><aside id="sidebar" class="vp-sidebar" vp-sidebar><!----><ul class="vp-sidebar-links"><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable active" type="button"><span class="font-icon icon fa-fw fa-sm fa-brands fa-java" style=""></span><span class="vp-sidebar-title">Java</span><span class="vp-arrow down"></span></button><ul class="vp-sidebar-links"><li><a class="route-link auto-link vp-sidebar-link" href="/blog/Interview/Java/" aria-label="Java"><!--[--><span class="font-icon icon fa-fw fa-sm fa-brands fa-java" style=""></span><!--]-->Java<!----></a></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">01 Java基础面试题</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">02 Java集合面试题</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">03 Java并发编程面试题</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">04 Java虚拟机面试题</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">05 Spring面试题</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">06 My SQL面试题</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable active" type="button"><!----><span class="vp-sidebar-title">07 Redis面试题</span><span class="vp-arrow down"></span></button><ul class="vp-sidebar-links"><li><a class="route-link auto-link vp-sidebar-link" href="/blog/Interview/Java/07-Redis%E9%9D%A2%E8%AF%95%E9%A2%98/7.Redis%E9%9D%A2%E8%AF%95%E9%A2%98.html" aria-label="Redis面试题"><!---->Redis面试题<!----></a></li><li><a class="route-link route-link-active auto-link vp-sidebar-link active" href="/blog/Interview/Java/07-Redis%E9%9D%A2%E8%AF%95%E9%A2%98/7.Redis%E9%9D%A2%E8%AF%95%E9%A2%98A.html" aria-label="Redis面试题A货"><!---->Redis面试题A货<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/blog/Interview/Java/07-Redis%E9%9D%A2%E8%AF%95%E9%A2%98/7.Redis%E9%9D%A2%E8%AF%95%E9%A2%98B.html" aria-label="面渣逆袭-Redis"><!---->面渣逆袭-Redis<!----></a></li></ul></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">08 数据结构面试题</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">09 MQ面试题</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">10 分布式</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">A基础</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">B中等</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">热点面试题</span><span class="vp-arrow end"></span></button><!----></section></li></ul></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">My SQL</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">Sanfene</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">Spring</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">SQL刷题</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">算法</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">面试准备</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><span class="font-icon icon fa-fw fa-sm fa-solid fa-file-pen" style=""></span><span class="vp-sidebar-title">面试答题卡</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">面试记录</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">黑马 Java2021</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">黑马 Java2023</span><span class="vp-arrow end"></span></button><!----></section></li></ul><!----></aside><!--[--><main id="main-content" class="vp-page"><!--[--><!----><!----><nav class="vp-breadcrumb disable"></nav><div class="vp-page-title"><h1><!---->Redis面试题A货</h1><div class="page-info"><span class="page-author-info" aria-label="作者🖊" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="author icon" name="author"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><span class="page-author-item">来杯冰柠檬</span></span><span property="author" content="来杯冰柠檬"></span></span><!----><!----><!----><span class="page-reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon" name="timer"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 102 分钟</span><meta property="timeRequired" content="PT102M"></span><!----><!----></div><hr></div><div class="vp-toc-placeholder"><aside id="toc"><!----><div class="vp-toc-header">此页内容<button type="button" class="print-button" title="打印"><svg xmlns="http://www.w3.org/2000/svg" class="icon print-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="print icon" name="print"><path d="M819.2 364.8h-44.8V128c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v236.8h-44.8C145.067 364.8 96 413.867 96 473.6v192c0 59.733 49.067 108.8 108.8 108.8h44.8V896c0 17.067 14.933 32 32 32h460.8c17.067 0 32-14.933 32-32V774.4h44.8c59.733 0 108.8-49.067 108.8-108.8v-192c0-59.733-49.067-108.8-108.8-108.8zM313.6 160h396.8v204.8H313.6V160zm396.8 704H313.6V620.8h396.8V864zM864 665.6c0 25.6-19.2 44.8-44.8 44.8h-44.8V588.8c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v121.6h-44.8c-25.6 0-44.8-19.2-44.8-44.8v-192c0-25.6 19.2-44.8 44.8-44.8h614.4c25.6 0 44.8 19.2 44.8 44.8v192z"></path></svg></button><div class="arrow end"></div></div><div class="vp-toc-wrapper"><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#基础">基础</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_1-说说什么是-redis">1.说说什么是 Redis?</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_2-redis-可以用来干什么">2.Redis 可以用来干什么？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_3-redis-有哪些数据类型">3.Redis 有哪些数据类型？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_4-redis-为什么快呢">4.Redis 为什么快呢？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_5-能说一下-i-o-多路复用吗">5.能说一下 I/O 多路复用吗？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_6-redis-为什么早期选择单线程">6. Redis 为什么早期选择单线程？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_7-redis-6-0-使用多线程是怎么回事">7.Redis 6.0 使用多线程是怎么回事?</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_8-说说-redis-常用命令">8.🌟说说 Redis 常用命令</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_9-单线程-redis-的-qps-是多少">9.单线程 Redis 的 QPS 是多少？</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#持久化">持久化</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_10-redis-持久化方式有哪些-有什么区别">10.Redis 持久化⽅式有哪些？有什么区别？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_11-rdb-和-aof-各自有什么优缺点">11.RDB 和 AOF 各自有什么优缺点？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_12-rdb-和-aof-如何选择">12.RDB 和 AOF 如何选择？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_13-redis-的数据恢复">13.Redis 的数据恢复？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_14-redis-4-0-的混合持久化了解吗">14.Redis 4.0 的混合持久化了解吗？</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#高可用">高可用</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_15-主从复制了解吗">15.主从复制了解吗？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_16-redis-主从有几种常见的拓扑结构">16.Redis 主从有几种常见的拓扑结构？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_17-redis-的主从复制原理了解吗">17.Redis 的主从复制原理了解吗？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_18-说说主从数据同步的方式">18.说说主从数据同步的方式？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_19-主从复制存在哪些问题呢">19.主从复制存在哪些问题呢？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_20-redis-哨兵了解吗">20.Redis 哨兵了解吗？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_21-redis-哨兵实现原理知道吗">21.Redis 哨兵实现原理知道吗？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_22-领导者-sentinel-节点选举了解吗">22.领导者 Sentinel 节点选举了解吗？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_23-新的主节点是怎样被挑选出来的">23.新的主节点是怎样被挑选出来的？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_24-redis-集群了解吗">24.Redis 集群了解吗？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_25-redis-cluster了解吗">25.Redis Cluster了解吗?</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_26-集群中数据如何分区">26.集群中数据如何分区？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_27-能说说-redis-集群的原理吗">27.能说说 Redis 集群的原理吗？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_28-说说集群的伸缩">28.说说集群的伸缩？</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#缓存设计">缓存设计</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_29-缓存击穿、缓存穿透、缓存雪崩了解吗">29.🌟缓存击穿、缓存穿透、缓存雪崩了解吗？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_30-能说说布隆过滤器吗">30.能说说布隆过滤器吗？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_31-如何保证缓存和数据库的数据一致性">31.如何保证缓存和数据库的数据⼀致性？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_32-如何保证本地缓存和分布式缓存的一致">32.如何保证本地缓存和分布式缓存的一致？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_33-怎么处理热-key">33.怎么处理热 key？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_34-缓存预热怎么做呢">34.缓存预热怎么做呢？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_35-热点-key-重建-问题-解决">35.热点 key 重建？问题？解决？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_36-无底洞问题吗-如何解决">36.无底洞问题吗？如何解决？</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#redis-运维">Redis 运维</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_37-redis-报内存不足怎么处理">37.Redis 报内存不足怎么处理？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_38-redis-key-过期策略有哪些">38.Redis key 过期策略有哪些？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_39-redis-有哪些内存淘汰策略">39.Redis 有哪些内存淘汰策略？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_40-redis-阻塞-怎么解决">40.Redis 阻塞？怎么解决？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_41-大-key-问题了解吗">41.大 key 问题了解吗？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_42-redis-常见性能问题和解决方案">42.Redis 常见性能问题和解决方案？</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#redis-应用">Redis 应用</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_43-使用-redis-如何实现异步队列">43.使用 Redis 如何实现异步队列？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_44-redis-如何实现延时队列">44.Redis 如何实现延时队列?</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_45-redis-支持事务吗">45.Redis 支持事务吗？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_46-有-lua-脚本操作-redis-的经验吗">46.有 Lua 脚本操作 Redis 的经验吗？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_47-redis-的管道pipeline了解吗">47.Redis 的管道Pipeline了解吗？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_48-redis-实现分布式锁了解吗">48.Redis 实现分布式锁了解吗？</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#底层结构">底层结构</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_49-说说-redis-底层数据结构">49.说说 Redis 底层数据结构？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_50-redis-的-sds-和-c-中字符串相比有什么优势">50.Redis 的 SDS 和 C 中字符串相比有什么优势？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_51-字典是如何实现的-rehash-了解吗">51.字典是如何实现的？Rehash 了解吗？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_52-跳表是如何实现的-原理">52.跳表是如何实现的？原理？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_53-压缩列表了解吗">53.压缩列表了解吗？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_54-快速列表-quicklist-了解吗">54.快速列表 quicklist 了解吗？</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#补充">补充</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_55-假如-redis-里面有-1-亿个-key-其中有-10w-个-key-是以某个固定的已知的前缀开头的-如何将它们全部找出来">55.假如 Redis 里面有 1 亿个 key，其中有 10w 个 key 是以某个固定的已知的前缀开头的，如何将它们全部找出来？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_56-redis-的秒杀场景下扮演了什么角色-补充">56.Redis 的秒杀场景下扮演了什么角色？（补充）</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_57-客户端宕机后-redis-服务端如何感知到">57. 客户端宕机后 Redis 服务端如何感知到？</a></li><!----><!--]--></ul></li><!--]--></ul><div class="vp-toc-marker" style="top:-1.7rem;"></div></div><!----></aside></div><!----><div class="theme-hope-content" vp-content><h1 id="redis面试题a货" tabindex="-1"><a class="header-anchor" href="#redis面试题a货"><span>Redis面试题A货</span></a></h1><h2 id="基础" tabindex="-1"><a class="header-anchor" href="#基础"><span>基础</span></a></h2><h3 id="_1-说说什么是-redis" tabindex="-1"><a class="header-anchor" href="#_1-说说什么是-redis"><span>1.说说什么是 Redis?</span></a></h3><figure><img src="/blog/assets/img/redis-96e079f9-49a3-4c55-b0a4-47d043732b62.0e72076e.png" alt="Redis图标" tabindex="0" loading="lazy"><figcaption>Redis图标</figcaption></figure><p>Redis 全称是 <strong>Re</strong>mote <strong>Di</strong>ctionary <strong>S</strong>ervice，它是一个基于键值对的 <strong>高性能 NoSQL 数据库</strong>。</p><p>相比传统的键值存储（比如 <code>HashMap</code>），Redis 的 <code>value</code> 不仅支持 <code>String</code>，还支持 <code>Hash</code>、<code>List</code>、<code>Set</code>、<code>ZSet</code>、<code>Bitmap</code>、<code>HyperLogLog</code>、<code>GEO</code> 等丰富的数据结构，能够满足更多业务场景。</p><p>Redis 的 <strong>核心优势</strong>在于数据存放在内存中，读写性能非常高，同时它也支持 <strong>持久化机制</strong>（RDB 和 AOF），保证数据在宕机后不会丢失。</p><p>除此之外，Redis 还提供了 <strong>键过期、发布订阅、事务、流水线、Lua 脚本</strong>等高级功能，因此在互联网系统中被广泛用作 <strong>缓存、分布式锁、消息队列以及排行榜</strong> 等场景。</p><h4 id="redis-和-mysql-的区别" tabindex="-1"><a class="header-anchor" href="#redis-和-mysql-的区别"><span>Redis 和 MySQL 的区别？</span></a></h4><ul><li>Redis：数据存储在内存中的 NoSQL 数据库，读写性能非常好，是互联网技术领域中使用最广泛的缓存中间件。</li><li>MySQL：数据存储在硬盘中的关系型数据库，适用于需要事务支持和复杂查询的场景。</li></ul><h4 id="部署过-redis-吗" tabindex="-1"><a class="header-anchor" href="#部署过-redis-吗"><span>部署过 Redis 吗？</span></a></h4><p>我是直接在本地部署的单机版，只需要下载 Redis 的安装包，解压后运行 <code>redis-server</code> 命令即可。</p><p>也可以通过 Docker 拉取 Redis 镜像，然后运行容器。</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">docker</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> run</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -d</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> --name</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> redis</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -p</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> 6379:6379</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> redis</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="_2-redis-可以用来干什么" tabindex="-1"><a class="header-anchor" href="#_2-redis-可以用来干什么"><span>2.Redis 可以用来干什么？</span></a></h3><p>Redis 可以用来做缓存、排行榜、分布式锁等等。</p><p>①、缓存</p><p>缓存是 Redis 最常见的用途，由于 Redis 的数据存储在内存中，所以读写速度非常快，远超基于磁盘存储的数据库。使用 Redis 缓存可以极大地提高应用的响应速度和吞吐量。</p><figure><img src="/blog/assets/img/redis-d44c2397-5994-452f-8b7b-eb85d2b87685.a50f4578.png" alt="Redis缓存" tabindex="0" loading="lazy"><figcaption>Redis缓存</figcaption></figure><p>②、排行榜/计数器</p><p>Redis 的 ZSet 非常适合用来实现排行榜的功能，可以根据 score（分值）进行排序，实时展示用户的活跃度。</p><figure><img src="/blog/assets/img/redis-20240420100012.c2e0986b.png" alt="阅读活跃榜" tabindex="0" loading="lazy"><figcaption>阅读活跃榜</figcaption></figure><p>同时 Redis 的原子递增操作可以用来实现计数器功能。</p><p>③、分布式锁</p><p>Redis 可以实现分布式锁，用来控制跨多个进程的资源访问。</p><h3 id="_3-redis-有哪些数据类型" tabindex="-1"><a class="header-anchor" href="#_3-redis-有哪些数据类型"><span>3.Redis 有哪些数据类型？</span></a></h3><p>Redis 有五种基本数据类型，这五种数据类型分别是：string（字符串）、hash（哈希）、list（列表）、set（集合）、sorted set（有序集合，也叫 zset）。</p><figure><img src="/blog/assets/img/redis-10434dc7-c7a3-4c1a-b484-de3fb37669ee.b6df263e.png" alt="Redis基本数据类型" tabindex="0" loading="lazy"><figcaption>Redis基本数据类型</figcaption></figure><h4 id="简单介绍下-string" tabindex="-1"><a class="header-anchor" href="#简单介绍下-string"><span>简单介绍下 string？</span></a></h4><p>字符串是最基础的数据类型，key 是一个字符串，不用多说，value 可以是：</p><ul><li>字符串（简单的字符串、复杂的字符串（例如 JSON、XML））</li><li>数字 （整数、浮点数）</li><li>甚至是二进制（图片、音频、视频），但最大不能超过 512MB。</li></ul><p>字符串主要有以下几个典型的使用场景：</p><ul><li>缓存功能</li><li>计数</li><li>共享 Session</li><li>限速</li></ul><h4 id="简单介绍下-hash" tabindex="-1"><a class="header-anchor" href="#简单介绍下-hash"><span>简单介绍下 hash？</span></a></h4><p>键值对集合，key 是字符串，value 是一个 Map 集合，比如说 <code>value = {name: &#39;隔壁老王&#39;, age: 18}</code>，name 和 age 属于字段 field，隔壁老王 和 18 属于值 value。</p><p>哈希主要有以下两个典型应用场景：</p><ul><li>缓存用户信息</li><li>缓存对象</li></ul><h4 id="什么时候使用-hash-类型而不使用-string-类型序列化存储" tabindex="-1"><a class="header-anchor" href="#什么时候使用-hash-类型而不使用-string-类型序列化存储"><span>什么时候使用 hash 类型而不使用 string 类型序列化存储？</span></a></h4><p>来感受一下，使用字符串类型存储用户信息和使用哈希类型存储用户信息的区别：</p><figure><img src="/blog/assets/img/redis-20240315115713.d52fea38.png" alt=" Java 进阶之路" tabindex="0" loading="lazy"><figcaption> Java 进阶之路</figcaption></figure><p>可以看得出，使用 hash 比使用 string 更便于进行序列化，我们可以将一整个用户对象序列化，然后作为一个 value 存储在 Redis 中，存取更加便捷。</p><h4 id="简单介绍下-list" tabindex="-1"><a class="header-anchor" href="#简单介绍下-list"><span>简单介绍下 list？</span></a></h4><p>list 是一个简单的字符串列表，按照插入顺序排序。可以添加一个元素到列表的头部（左边）或者尾部（右边）。</p><p>列表主要有以下两个使用场景：</p><ul><li>消息队列</li><li>文章列表</li></ul><h4 id="简单介绍下-set" tabindex="-1"><a class="header-anchor" href="#简单介绍下-set"><span>简单介绍下 set？</span></a></h4><p>Set 是一个无序集合，元素是唯一的，不允许重复。</p><h4 id="简单介绍下-zset" tabindex="-1"><a class="header-anchor" href="#简单介绍下-zset"><span>简单介绍下 zset？</span></a></h4><p>Zset 是有序集合，比 set 多了一个排序属性 score。</p><figure><img src="/blog/assets/img/redis-20240315120652.c5090976.png" alt=" Java 进阶之路" tabindex="0" loading="lazy"><figcaption> Java 进阶之路</figcaption></figure><p>可以用来实现排行榜，比如<a href="https://javabetter.cn/zhishixingqiu/paicoding.html" target="_blank" rel="noopener noreferrer">实战项目</a>中，我们就使用了 Zset 来实现用户活跃排行榜。</p><h3 id="_4-redis-为什么快呢" tabindex="-1"><a class="header-anchor" href="#_4-redis-为什么快呢"><span>4.Redis 为什么快呢？</span></a></h3><p>Redis 的速度⾮常快，单机的 Redis 就可以⽀撑每秒十几万的并发，性能是 MySQL 的⼏⼗倍。原因主要有⼏点：</p><p>①、<strong>基于内存的数据存储</strong>，Redis 将数据存储在内存当中，使得数据的读写操作避开了磁盘 I/O。而内存的访问速度远超硬盘，这是 Redis 读写速度快的根本原因。</p><p>②、<strong>单线程模型</strong>，Redis 使用单线程模型来处理客户端的请求，这意味着在任何时刻只有一个命令在执行。这样就避免了线程切换和锁竞争带来的消耗。</p><p>③、<strong>IO 多路复⽤</strong>，基于 Linux 的 select/epoll 机制。该机制允许内核中同时存在多个监听套接字和已连接套接字，内核会一直监听这些套接字上的连接请求或者数据请求，一旦有请求到达，就会交给 Redis 处理，就实现了所谓的 Redis 单个线程处理多个 IO 读写的请求。</p><figure><img src="/blog/assets/img/redis-e05bca61-4600-495c-b92a-25ac822e034e.a9a17b9f.png" alt="Redis使用IO多路复用和自身事件模型" tabindex="0" loading="lazy"><figcaption>Redis使用IO多路复用和自身事件模型</figcaption></figure><p>④、<strong>高效的数据结构</strong>，Redis 提供了多种高效的数据结构，如字符串（String）、列表（List）、集合（Set）、有序集合（Sorted Set）等，这些数据结构经过了高度优化，能够支持快速的数据操作。</p><h3 id="_5-能说一下-i-o-多路复用吗" tabindex="-1"><a class="header-anchor" href="#_5-能说一下-i-o-多路复用吗"><span>5.能说一下 I/O 多路复用吗？</span></a></h3><p>IO 多路复用是一种高效管理多个 IO 事件的技术，通过单线程监控多个文件描述符（fd），实现高并发的 IO 操作。</p><p>常见的 I/O 多路复用机制包括 select、poll 和 epoll 等。</p><table><thead><tr><th>特性</th><th><code>select</code></th><th><code>poll</code></th><th><code>epoll</code></th></tr></thead><tbody><tr><td>文件描述符限制</td><td>受 <code>FD_SETSIZE</code> 限制</td><td>无限制</td><td>无限制</td></tr><tr><td>时间复杂度</td><td>O(n)</td><td>O(n)</td><td>O(1)</td></tr><tr><td>数据复制</td><td>需要</td><td>需要</td><td>不需要</td></tr><tr><td>工作方式</td><td>线性扫描</td><td>线性扫描</td><td>事件通知</td></tr><tr><td>内核支持</td><td>所有 UNIX 系统</td><td>所有 UNIX 系统</td><td>Linux 2.6 及以上版本</td></tr><tr><td>适用场景</td><td>少量连接</td><td>中等连接</td><td>大量并发连接</td></tr></tbody></table><p>比如说你是一名数学老师，上课时提出了一个问题：“今天谁来证明一下勾股定律？”</p><p>同学小王举手，你就让小王回答；小李举手，你就让小李回答；小张举手，你就让小张回答。</p><p>这种模式就是 IO 多路复用，你只需要在讲台上等，谁举手谁回答，不需要一个一个去问。</p><figure><img src="/blog/assets/img/redis-20240918114125.5466df46.png" alt="有盐先生：IO 多路复用" tabindex="0" loading="lazy"><figcaption>有盐先生：IO 多路复用</figcaption></figure><p>Redis 就是使用 epoll 这样的 I/O 多路复用机制，在单线程模型下实现高效的网络 I/O，从而支持高并发的请求处理。</p><h4 id="举例子说一下-i-o-多路复用" tabindex="-1"><a class="header-anchor" href="#举例子说一下-i-o-多路复用"><span>举例子说一下 I/O 多路复用？</span></a></h4><p>假设你是一个老师，让 30 个学生解答一道题目，然后检查学生做的是否正确，你有下面几个选择：</p><ul><li>第一种选择：按顺序逐个检查，先检查 A，然后是 B，之后是 C、D。。。这中间如果有一个学生卡住，全班都会被耽误。这种模式就好比，你用循环挨个处理 socket，根本不具有并发能力。</li><li>第二种选择：你创建 30 个分身，每个分身检查一个学生的答案是否正确。 这种类似于为每一个用户创建一个进程或者线程处理连接。</li><li>第三种选择，你站在讲台上等，谁解答完谁举手。这时 C、D 举手，表示他们解答问题完毕，你下去依次检查 C、D 的答案，然后继续回到讲台上等。此时 E、A 又举手，然后去处理 E 和 A。</li></ul><p>第一种就是阻塞 IO 模型，第三种就是 I/O 复用模型。</p><figure><img src="/blog/assets/img/redis-eb541432-d68a-4dd9-b427-96c4dd607d64.10ee83cd.png" alt="图片来源于网络：多路复用模型" tabindex="0" loading="lazy"><figcaption>图片来源于网络：多路复用模型</figcaption></figure><p>Linux 系统有三种方式实现 IO 多路复用：select、poll 和 epoll。</p><p>例如 epoll 方式是将用户 socket 对应的 fd 注册进 epoll，然后 epoll 帮你监听哪些 socket 上有消息到达，这样就避免了大量的无用操作。此时的 socket 应该采用非阻塞模式。</p><p>这样，整个过程只在进行 select、poll、epoll 这些调用的时候才会阻塞，收发客户消息是不会阻塞的，整个进程或者线程就被充分利用起来，这就是事件驱动，所谓的 reactor 模式。</p><h4 id="select、poll-和-epoll-的实现原理" tabindex="-1"><a class="header-anchor" href="#select、poll-和-epoll-的实现原理"><span>select、poll 和 epoll 的实现原理？</span></a></h4><p>select 使用位图管理 fd，每次调用都需要将 fd 集合从用户态复制到内核态。最大支持 1024 个文件描述符。</p><p>poll 使用动态数组管理 fd，突破了 select 的数量限制。</p><p>epoll 使用红黑树和链表管理 fd，每次调用只需要将 fd 集合从用户态复制到内核态一次，不需要重复复制。</p><h3 id="_6-redis-为什么早期选择单线程" tabindex="-1"><a class="header-anchor" href="#_6-redis-为什么早期选择单线程"><span>6. Redis 为什么早期选择单线程？</span></a></h3><p>官方解释：https://redis.io/topics/faq</p><p><img src="/blog/assets/img/redis-344b8461-98d4-495b-a697-70275b0abad6.ac23eb94.png" alt="官方单线程解释" loading="lazy"> 官方 FAQ 表示，因为 Redis 是基于内存的操作，CPU 成为 Redis 的瓶颈的情况很少见，Redis 的瓶颈最有可能是内存的大小或者网络限制。</p><p>如果想要最大程度利用 CPU，可以在一台机器上启动多个 Redis 实例。</p><p>PS：网上有这样的回答，吐槽官方的解释有些敷衍，其实就是历史原因，开发者嫌多线程麻烦，后来这个 CPU 的利用问题就被抛给了使用者。</p><p>同时 FAQ 里还提到了， Redis 4.0 之后开始变成多线程，除了主线程外，它也有后台线程在处理一些较为缓慢的操作，例如清理脏数据、无用连接的释放、大 Key 的删除等等。</p><blockquote><p>Redis 早期选择单线程是因为它主要在内存中操作数据，性能瓶颈不在 CPU，而在网络 I/O。单线程避免了多线程的锁竞争和上下文切换开销，加上 I/O 多路复用机制，已经足以支撑高并发。</p></blockquote><h3 id="_7-redis-6-0-使用多线程是怎么回事" tabindex="-1"><a class="header-anchor" href="#_7-redis-6-0-使用多线程是怎么回事"><span>7.Redis 6.0 使用多线程是怎么回事?</span></a></h3><p>Redis6.0的多线程是⽤多线程来处理数据的读写和协议解析，但是Redis执⾏命令还是单线程的。</p><figure><img src="/blog/assets/img/redis-b7b24e25-d2dc-4457-994f-95bdb3674b8e.2ff41589.png" alt="Redis6.0多线程" tabindex="0" loading="lazy"><figcaption>Redis6.0多线程</figcaption></figure><p>这样做的⽬的是因为Redis的性能瓶颈在于网络IO而非CPU，使⽤多线程能提升IO读写的效率，从而整体提⾼Redis的性能。</p><h3 id="_8-说说-redis-常用命令" tabindex="-1"><a class="header-anchor" href="#_8-说说-redis-常用命令"><span>8.🌟说说 Redis 常用命令</span></a></h3><p>①、操作<code>字符串</code>的命令有：</p><ul><li><code>SET key value</code>：设置键 key 的值为 value。</li><li><code>GET key</code>：获取键 key 的值。</li><li><code>DEL key</code>：删除键 key。</li><li><code>INCR key</code>：将键 key 存储的数值增一。</li><li><code>DECR key</code>：将键 key 存储的数值减一。</li></ul><p>②、操作<code>列表</code>的命令有：</p><ul><li><code>LPUSH key value</code>：将一个值插入到列表 key 的头部。</li><li><code>RPUSH key value</code>：将一个值插入到列表 key 的尾部。</li><li><code>LPOP key</code>：移除并返回列表 key 的头元素。</li><li><code>RPOP key</code>：移除并返回列表 key 的尾元素。</li><li><code>LRANGE key start stop</code>：获取列表 key 中指定范围内的元素。</li></ul><p>③、操作<code>集合</code>的命令有：</p><ul><li><code>SADD key member</code>：向集合 key 添加一个元素。</li><li><code>SREM key member</code>：从集合 key 中移除一个元素。</li><li><code>SMEMBERS key</code>：返回集合 key 中的所有元素。</li></ul><p>④、操作<code>有序集合</code>的命令有：</p><ul><li><code>ZADD key score member</code>：向有序集合 key 添加一个成员，或更新其分数。</li><li><code>ZRANGE key start stop [WITHSCORES]</code>：按照索引区间返回有序集合 key 中的成员，可选 WITHSCORES 参数返回分数。</li><li><code>ZREVRANGE key start stop [WITHSCORES]</code>：返回有序集合 key 中，指定区间内的成员，按分数递减。</li><li><code>ZREM key member</code>：移除有序集合 key 中的一个或多个成员。</li></ul><p>⑤、操作<code>哈希</code>的命令有：</p><ul><li><code>HSET key field value</code>：向键为 key 的哈希表中设置字段 field 的值为 value。</li><li><code>HGET key field</code>：获取键为 key 的哈希表中字段 field 的值。</li><li><code>HGETALL key</code>：获取键为 key 的哈希表中所有的字段和值。</li><li><code>HDEL key field</code>：删除键为 key 的哈希表中的一个或多个字段。</li></ul><h4 id="详细说说-set-命令" tabindex="-1"><a class="header-anchor" href="#详细说说-set-命令"><span>详细说说 set 命令？</span></a></h4><p>在 Redis 中，设置键值对的命令是 set。set 命令有几个常用的参数：</p><p>①、可以通过 EX 或 PX 为键设置过期时间（秒或毫秒）</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">redis-cli</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> SET</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> session_id</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;xyz&quot;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> EX</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 3600</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  # 设置键 session_id，值为 &quot;xyz&quot;，过期时间为 3600 秒</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>②、NX 选项表示只有键不存在时才设置</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">redis-cli</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> SET</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> lock_key</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;locked&quot;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> NX</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>③、XX 选项表示只有键存在时才设置</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">redis-cli</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> SET</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> config</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;new_config&quot;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> XX</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h4 id="sadd-命令的时间复杂度是多少" tabindex="-1"><a class="header-anchor" href="#sadd-命令的时间复杂度是多少"><span>sadd 命令的时间复杂度是多少？</span></a></h4><p>向指定 Set 中添加 1 个或多个 member，如果指定 Set 不存在，会自动创建一个。<strong>时间复杂度 O(N)</strong> ，N 为添加的 member 个数。</p><h4 id="incr命令了解吗" tabindex="-1"><a class="header-anchor" href="#incr命令了解吗"><span>incr命令了解吗？</span></a></h4><p>INCR 命令是 Redis 中的一个原子操作，用于将存储在 key 中的数值加 1。</p><p>Redis 的单线程模型确保了每个命令都是原子执行的，不会被其他命令打断。</p><h3 id="_9-单线程-redis-的-qps-是多少" tabindex="-1"><a class="header-anchor" href="#_9-单线程-redis-的-qps-是多少"><span>9.单线程 Redis 的 QPS 是多少？</span></a></h3><p>Redis 的 QPS（Queries Per Second，每秒查询率）受多种因素影响，包括硬件配置（如 CPU、内存、网络带宽）、数据模型、命令类型、网络延迟等。</p><p>根据官方的基准测试，一个普通服务器的 Redis 实例通常可以达到每秒数万到几十万的 QPS。</p><p>可以通过 <code>redis-benchmark</code> 命令进行基准测试：</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">redis-benchmark</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -h</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 127.0.0.1</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -p</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 6379</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -c</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 50</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -n</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 10000</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li><code>-h</code>：指定 Redis 服务器的地址，默认是 127.0.0.1。</li><li><code>-p</code>：指定 Redis 服务器的端口，默认是 6379。</li><li><code>-c</code>：并发连接数，即同时有多少个客户端在进行测试。</li><li><code>-n</code>：请求总数，即测试过程中总共要执行多少个请求。</li></ul><p>我本机是一台 macOS，4 GHz 四核 Intel Core i7，32 GB 1867 MHz DDR3，测试结果如下：</p><figure><img src="/blog/assets/img/redis-20240408100900.5cbdddc3.png" alt=" Java 进阶之路" tabindex="0" loading="lazy"><figcaption> Java 进阶之路</figcaption></figure><h2 id="持久化" tabindex="-1"><a class="header-anchor" href="#持久化"><span>持久化</span></a></h2><h3 id="_10-redis-持久化方式有哪些-有什么区别" tabindex="-1"><a class="header-anchor" href="#_10-redis-持久化方式有哪些-有什么区别"><span>10.Redis 持久化⽅式有哪些？有什么区别？</span></a></h3><p>Redis 的持久化机制保证了 Redis 服务器在重启后数据不丢失，通过 RDB 和 AOF 文件来恢复内存中原有的数据。</p><p>这两种持久化方式可以单独使用，也可以同时使用。</p><figure><img src="/blog/assets/img/redis-3bda4a46-adc3-4f0d-a135-b8ae5d4c0d5d.805eb922.png" alt="Redis持久化的两种方式" tabindex="0" loading="lazy"><figcaption>Redis持久化的两种方式</figcaption></figure><h4 id="说一下-rdb" tabindex="-1"><a class="header-anchor" href="#说一下-rdb"><span>说一下 RDB？</span></a></h4><p>RDB持久化是把当前进程数据⽣成快照保存到硬盘的过程，触发RDB持久化过程分为⼿动触发和⾃动 触发。</p><p>RDB⽂件是⼀个压缩的⼆进制⽂件，通过它可以还原某个时刻数据库的状态。由于RDB⽂件是保存在 硬盘上的，所以即使Redis崩溃或者退出，只要RDB⽂件存在，就可以⽤它来恢复还原数据库的状态。</p><p><strong>手动触发分别对应save和bgsave命令:</strong></p><figure><img src="/blog/assets/img/redis-ffe56e32-34c5-453d-8859-c2febbe6a038.22a30fd2.png" alt="save和bgsave" tabindex="0" loading="lazy"><figcaption>save和bgsave</figcaption></figure><ul><li><code>save</code>命令：阻塞当前Redis服务器，直到RDB过程完成为⽌，对于内存⽐较⼤的实例会造成长时间阻塞，线上环境不建议使⽤。</li><li><code>bgsave</code>命令：Redis进程执行fork操作创建⼦进程，RDB持久化过程由⼦进程负责，完成后⾃动结束。阻塞只发⽣在fork阶段，⼀般时间很短。</li></ul><blockquote><p>以下场景会自动触发 RDB 持久化：</p></blockquote><ul><li>使⽤save相关配置，如“save m n”。表⽰m秒内数据集存在n次修改时，⾃动触发bgsave。</li><li>如果从节点执⾏全量复制操作，主节点⾃动执⾏bgsave⽣成RDB⽂件并发送给从节点</li><li>执⾏debug reload命令重新加载Redis时，也会⾃动触发save操作</li><li>默认情况下执⾏shutdown命令时，如果没有开启AOF持久化功能则⾃动执⾏bgsave。</li></ul><h4 id="说一下-aof" tabindex="-1"><a class="header-anchor" href="#说一下-aof"><span>说一下 AOF？</span></a></h4><p>AOF（append only file）持久化：以独⽴⽇志的⽅式记录每次写命令， 重启时再重新执⾏AOF⽂件中的命令达到恢复数据的⽬的。AOF的主要作⽤是解决了数据持久化的实时性，⽬前已经是Redis持久化的主流⽅式。</p><p>AOF的⼯作流程操作：命令写⼊ （append）、⽂件同步（sync）、⽂件重写（rewrite）、重启加载 （load）</p><figure><img src="/blog/assets/img/redis-a9fb6202-b1a1-484d-a4fa-fef519090b44.e5c85336.png" alt="AOF工作流程" tabindex="0" loading="lazy"><figcaption>AOF工作流程</figcaption></figure><p>1）当 AOF 持久化机制被启用时，Redis 服务器会将接收到的所有写命令追加到 AOF 缓冲区的末尾。</p><p>2）接着将缓冲区中的命令刷新到磁盘的 AOF 文件中，刷新策略有三种：</p><ul><li>always：每次写命令都会同步到 AOF 文件。</li><li>everysec（默认）：每秒同步一次。如果系统崩溃，可能会丢失最后一秒的数据。</li><li>no：在这种模式下，如果发生宕机，那么丢失的数据量由操作系统内核的缓存冲洗策略决定。</li></ul><p>3）随着 AOF 文件的不断增长，Redis 会启用重写机制来生成一个更小的 AOF 文件：</p><ul><li>将内存中每个键值对的当前状态转换为一条最简单的 Redis 命令，写入到一个新的 AOF 文件中。即使某个键被修改了多次，在新的 AOF 文件中也只会保留最终的状态。</li><li>Redis 会 fork 一个子进程，子进程负责重写 AOF 文件，主进程不会被阻塞。</li></ul><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>主进程（fork）  </span></span>
<span class="line"><span>   │  </span></span>
<span class="line"><span>   ├─→ 子进程（生成新的 AOF 文件）  </span></span>
<span class="line"><span>   │       │  </span></span>
<span class="line"><span>   │       ├─→ 内存快照  </span></span>
<span class="line"><span>   │       ├─→ 写入临时 AOF 文件  </span></span>
<span class="line"><span>   │       ├─→ 通知主进程完成  </span></span>
<span class="line"><span>   │  </span></span>
<span class="line"><span>   ├─→ 主进程（追加缓冲区到新 AOF 文件）  </span></span>
<span class="line"><span>   ├─→ 替换旧 AOF 文件  </span></span>
<span class="line"><span>   ├─→ 重写完成</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>4）当 Redis 服务器重启时，会读取 AOF 文件中的所有命令并重新执行它们，以恢复重启前的内存状态。</p><h4 id="aof-文件存储的是什么类型的数据" tabindex="-1"><a class="header-anchor" href="#aof-文件存储的是什么类型的数据"><span>AOF 文件存储的是什么类型的数据？</span></a></h4><p>AOF 文件存储的是 Redis 所有的写操作命令，比如 SET、HSET、INCR 等。</p><figure><img src="/blog/assets/img/redis-20241208204853.6dac53ab.png" alt="Java 进阶之路：AOF文件内容" tabindex="0" loading="lazy"><figcaption>Java 进阶之路：AOF文件内容</figcaption></figure><h4 id="aof重写期间命令可能会写入两次-会造成什么影响" tabindex="-1"><a class="header-anchor" href="#aof重写期间命令可能会写入两次-会造成什么影响"><span>AOF重写期间命令可能会写入两次，会造成什么影响？</span></a></h4><p>AOF 重写期间，Redis 会将新的写命令同时写入旧的 AOF 文件和重写缓冲区。</p><p>这样会带来额外的磁盘开销。</p><p>但可以防止在 AOF 重写尚未完成时，Redis 发生崩溃，导致数据丢失。即使重写失败，旧的 AOF 文件仍然是完整的。</p><p>当重写完成后，会通过原子操作将新的 AOF 文件替换旧的 AOF 文件。</p><h3 id="_11-rdb-和-aof-各自有什么优缺点" tabindex="-1"><a class="header-anchor" href="#_11-rdb-和-aof-各自有什么优缺点"><span>11.RDB 和 AOF 各自有什么优缺点？</span></a></h3><blockquote><p>RDB | 优点</p></blockquote><ol><li>只有⼀个紧凑的⼆进制⽂件 dump.rdb ，⾮常适合备份、全量复制的场景。</li><li>容灾性好，可以把RDB⽂件拷贝到远程机器或者⽂件系统中，⽤于容灾恢复。</li><li>恢复速度快，RDB恢复数据的速度远远快于AOF的⽅式</li></ol><blockquote><p>RDB | 缺点</p></blockquote><ol><li>实时性低，RDB 是间隔⼀段时间进⾏持久化，没法做到实时持久化/秒级持久化。如果在这⼀间 隔事件发⽣故障，数据会丢失。</li><li>存在兼容问题，Redis演进过程存在多个格式的RDB版本，存在⽼版本Redis⽆法兼容新版本 RDB的问题。</li></ol><blockquote><p>AOF | 优点</p></blockquote><ol><li>实时性好，aof 持久化可以配置 appendfsync 属性，有 always ，每进⾏⼀次命令操作就记录 到 aof ⽂件中⼀次。</li><li>通过 append 模式写⽂件，即使中途服务器宕机，可以通过 redis-check-aof ⼯具解决数据⼀致 性问题。</li></ol><blockquote><p>AOF | 缺点</p></blockquote><ol><li>AOF ⽂件⽐ RDB ⽂件⼤，且恢复速度慢。</li><li>数据集⼤的时候，比 RDB 启动效率低。</li></ol><h3 id="_12-rdb-和-aof-如何选择" tabindex="-1"><a class="header-anchor" href="#_12-rdb-和-aof-如何选择"><span>12.RDB 和 AOF 如何选择？</span></a></h3><p>在选择 Redis 持久化方案时，会从业务需求和技术特性两个维度来考虑。 如果是缓存场景，可以接受一定程度的数据丢失，会倾向于选择 RDB 或者完全不使用持久化。RDB 的快照方式对性能影响小，而且恢复速度快，非常适合这类场景。</p><p>Redis 做缓存 但如果是处理订单或者支付这样的核心业务，数据丢失将造成严重后果，那么 AOF 就成为必然选择。通过配置每秒同步一次，可以将潜在的数据丢失风险限制在可接受范围内。</p><p>reids 在秒杀中的应用 在实际的项目当中，我更偏向于使用 RDB + AOF 的混合模式。RDB 作为冷备，AOF 作为实时同步 appendonly yes # 开启 AOF appendfsync everysec # 每秒刷盘一次 aof-use-rdb-preamble yes # 开启混合持久化，重启时优先加载 RDB，RDB 作为冷备，AOF 作为实时同步</p><h3 id="_13-redis-的数据恢复" tabindex="-1"><a class="header-anchor" href="#_13-redis-的数据恢复"><span>13.Redis 的数据恢复？</span></a></h3><p>当 Redis 中的数据丢失时，可以从 RDB 或者 AOF 中恢复数据。</p><p>可以将 RDB 文件或者 AOF 文件复制到 Redis 的数据目录下，然后重启 Redis 服务，Redis 会自动加载数据文件并恢复数据。</p><figure><img src="/blog/assets/img/redis-f9aab5e9-a875-4316-9ec9-0c5650afe5c1.5cad6a50.png" alt="Redis启动加载数据" tabindex="0" loading="lazy"><figcaption>Redis启动加载数据</figcaption></figure><p><strong>Redis</strong> 启动时加载数据的流程：</p><ol><li>AOF 开启且存在 AOF 文件时，优先加载 AOF 文件。</li><li>AOF 关闭或者 AOF 文件不存在时，加载 RDB 文件。</li></ol><h3 id="_14-redis-4-0-的混合持久化了解吗" tabindex="-1"><a class="header-anchor" href="#_14-redis-4-0-的混合持久化了解吗"><span>14.Redis 4.0 的混合持久化了解吗？</span></a></h3><p>重启 Redis 时，我们很少使⽤ RDB 来恢复内存状态，因为会丢失⼤量数据。我们通常使⽤ AOF 日志重放，但是重放 AOF 日志性能相对RDB来说要慢很多，这样在 Redis 实例很⼤的情况下，启动需要花费很长的时间。</p><p>Redis 4.0 为了解决这个问题，带来了⼀个新的持久化选项——混合持久化。将 rdb ⽂件的内容和增量的 AOF ⽇志⽂件存在⼀起。这⾥的 AOF ⽇志不再是全量的⽇志，⽽是⾃持久化开始到持久化结束的这段时间发⽣的增量AOF⽇志，通常这部分 AOF 日志很小：</p><figure><img src="/blog/assets/img/redis-19c531e5-da95-495a-a4c4-d63a0b8bba95.a53c7988.png" alt="混合持久化" tabindex="0" loading="lazy"><figcaption>混合持久化</figcaption></figure><p>于是在 Redis 重启的时候，可以先加载 rdb 的内容，然后再重放增量 AOF ⽇志就可以完全替代之前的 AOF 全量⽂件重放，重启效率因此⼤幅得到提升。</p><h4 id="如何设置持久化模式" tabindex="-1"><a class="header-anchor" href="#如何设置持久化模式"><span>如何设置持久化模式？</span></a></h4><p>可以通过编辑 Redis 的配置文件 redis.conf 来进行设置，或者在运行时通过 Redis 命令行动态调整。</p><p>RDB 持久化通过在配置文件中设置快照（snapshotting）规则来启用。这些规则定义了在多少秒内如果有多少个键被修改，则自动执行一次持久化操作。</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">save</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 900</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">      # 如果至少有1个键被修改，900秒后自动保存一次</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">save</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 300</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 10</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">     # 如果至少有10个键被修改，300秒后自动保存一次</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">save</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 60</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 10000</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">   # 如果至少有10000个键被修改，60秒后自动保存一次</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>AOF 持久化是通过在配置文件中设置 appendonly 参数为 yes 来启用的：</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">appendonly</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> yes</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>此外，还可以配置 AOF 文件的写入频率，这是通过 appendfsync 设置的：</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">appendfsync</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> always</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    # 每次写入数据都同步，保证数据不丢失，但性能较低</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">appendfsync</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> everysec</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  # 每秒同步一次，折衷方案</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">appendfsync</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> no</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        # 由操作系统决定何时同步，性能最好，但数据安全性最低</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为了优化 AOF 文件的大小，Redis 允许自动或手动重写 AOF 文件。可以在配置文件中设置重写的触发条件：</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">auto-aof-rewrite-percentage</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 100</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  # 增长到原大小的100%时触发重写</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">auto-aof-rewrite-min-size</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> 64mb</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">   # AOF 文件至少达到64MB时才考虑重写</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>手动执行 AOF 重写的命令是：</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">redis-cli</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> bgrewriteaof</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>如果决定同时使用 RDB 和 AOF，可以在配置文件中同时启用两者。</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">save</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 900</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">appendonly</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> yes</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>还可以在运行时动态更改：</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">redis-cli</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> config</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> set</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> save</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;900 1 300 10 60 10000&quot;</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">redis-cli</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> config</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> set</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> appendonly</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> yes</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">redis-cli</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> config</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> set</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> appendfsync</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> everysec</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="高可用" tabindex="-1"><a class="header-anchor" href="#高可用"><span>高可用</span></a></h2><p>Redis 除了单机部署外，还可以通过主从复制、哨兵模式和集群模式来实现高可用。</p><p><strong>主从复制</strong>：允许一个 Redis 服务器（主节点）将数据复制到一个或多个 Redis 服务器（从节点）。这种方式可以实现读写分离，适合读多写少的场景。</p><p><strong>哨兵模式</strong>：用于监控主节点和从节点的状态，实现自动故障转移。如果主节点发生故障，哨兵可以自动将一个从节点升级为新的主节点。</p><p><strong>集群模式</strong>：Redis 集群通过分片的方式存储数据，每个节点存储数据的一部分，用户请求可以并行处理。集群模式支持自动分区、故障转移，并且可以在不停机的情况下进行节点增加或删除。</p><h3 id="_15-主从复制了解吗" tabindex="-1"><a class="header-anchor" href="#_15-主从复制了解吗"><span>15.主从复制了解吗？</span></a></h3><p>主从复制是指将一台 Redis 服务器的数据，复制到其他的 Redis 服务器。</p><p>前者称为主节点 master，后者称为从节点slave。且数据的复制是单向的，只能由主节点到从节点。</p><figure><img src="/blog/assets/img/redis-60497f1e-8afb-44b3-bb7a-d4c29e5ac484.f0ef1573.png" alt="Redis主从复制简图" tabindex="0" loading="lazy"><figcaption>Redis主从复制简图</figcaption></figure><p>在 Redis 主从架构中，主节点负责处理所有的写操作，并将这些操作异步复制到从节点。从节点主要用于读取操作，以分担主节点的压力和提高读性能。</p><h4 id="主从复制主要的作用是什么" tabindex="-1"><a class="header-anchor" href="#主从复制主要的作用是什么"><span>主从复制主要的作用是什么?</span></a></h4><ul><li>数据冗余： 主从复制实现了数据的热备份，是持久化之外的⼀种数据冗余⽅式。</li><li>故障恢复： 当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复 (实际上是⼀种 服务的冗余)。</li><li>负载均衡： 在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写 Redis 数据时应⽤连接主节点，读 Redis 数据时应⽤连接从节点），分担服务器负载。 尤其是在写少读多的场景下，通过多个从节点分担读负载，可以⼤⼤提⾼ Redis 服务器的并发量。</li><li>高可用基石：除了上述作⽤以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是 Redis⾼可⽤的基础。</li></ul><h4 id="主从复制出现数据不一致怎么办" tabindex="-1"><a class="header-anchor" href="#主从复制出现数据不一致怎么办"><span>主从复制出现数据不一致怎么办？</span></a></h4><p>Redis 的主从复制是异步进行的，这意味着主节点在执行完写操作后，会立即返回给客户端，而不是等待从节点完成数据同步。</p><p>在主节点将数据同步到从节点的过程中，可能会出现网络延迟或中断，从而导致从节点的数据滞后于主节点。</p><p>为了解决数据不一致的问题，应该尽量保证主从节点之间的网络连接状况良好，比如说避免在不同机房之间部署主从节点，以减少网络延迟。但可能会带来新的问题，就是整个机房都挂掉的情况。</p><p>此外，Redis 本身也提供了一些机制来解决数据不一致的问题，比如说通过 Redis 的 <code>INFO replication</code> 命令监控主从节点的复制进度，及时发现和处理复制延迟。</p><p>具体做法是获取主节点的 master_repl_offset 和从节点的 slave_repl_offset，计算两者的差值。如果差值超过预设的阈值，采取措施（如停止从节点的数据读取）以减少读到不一致数据的情况。</p><figure><img src="/blog/assets/img/redis-20240709135618.eb19fb0a.png" alt="极客时间：Redis 核心技术与实战" tabindex="0" loading="lazy"><figcaption>极客时间：Redis 核心技术与实战</figcaption></figure><h4 id="redis解决单点故障主要靠什么" tabindex="-1"><a class="header-anchor" href="#redis解决单点故障主要靠什么"><span>Redis解决单点故障主要靠什么？</span></a></h4><p>主从复制，当主节点发生故障时，可以通过手动或自动方式将某个从节点提升为新的主节点，继续对外提供服务，从而避免单点故障。</p><p>Redis 的哨兵机制（Sentinel）可以实现自动化的故障转移，当主节点宕机时，哨兵会自动将一个从节点升级为新的主节点。</p><p>另外，集群模式下，当某个节点发生故障时，Redis Cluster 会自动将请求路由到其他节点，并通过从节点进行故障恢复。</p><h3 id="_16-redis-主从有几种常见的拓扑结构" tabindex="-1"><a class="header-anchor" href="#_16-redis-主从有几种常见的拓扑结构"><span>16.Redis 主从有几种常见的拓扑结构？</span></a></h3><p>Redis 的复制拓扑结构可以支持单层或多层复制关系，根据拓扑复杂性可以分为以下三种：一主一从、一主多从、树状主从结构。</p><p>1.一主一从结构</p><p>一主一从结构是最简单的复制拓扑结构，用于主节点出现宕机时从节点提供故障转移支持。</p><p><img src="/blog/assets/img/redis-5d91a67c-dbff-4a8d-bf9d-1fe7602d5a27.f1cf06d6.png" alt="一主一从结构" loading="lazy"> 2.一主多从结构</p><p>一主多从结构（又称为星形拓扑结构）使得应用端可以利用多个从节点实现读写分离（见图 6-5）。对于读占比较大的场景，可以把读命令发送到从节点来分担主节点压力。</p><p><img src="/blog/assets/img/redis-71074254-699a-480b-bbb0-c68f364a380b.9c8247f7.png" alt="一主多从结构" loading="lazy"> 3.树状主从结构</p><p>树状主从结构（又称为树状拓扑结构）使得从节点不但可以复制主节点数据，同时可以作为其他从节点的主节点继续向下层复制。通过引入复制中间层，可以有效降低主节点负载和需要传送给从节点的数据量。</p><figure><img src="/blog/assets/img/redis-dff14203-5e01-4d1b-a775-10ee444ada54.3c78e2ae.png" alt="树状主从结构" tabindex="0" loading="lazy"><figcaption>树状主从结构</figcaption></figure><h3 id="_17-redis-的主从复制原理了解吗" tabindex="-1"><a class="header-anchor" href="#_17-redis-的主从复制原理了解吗"><span>17.Redis 的主从复制原理了解吗？</span></a></h3><p>Redis 主从复制的工作流程大概可以分为如下几步： <img src="/blog/assets/img/redis-21123b1e-68b4-436b-ac84-3365a49a81bd.8391e951.png" alt="Redis主从复制工作流程" loading="lazy"></p><ol><li>保存主节点（master）信息 这一步只是保存主节点信息，保存主节点的 ip 和 port。</li><li>主从建立连接 从节点（slave）发现新的主节点后，会尝试和主节点建立网络连接。</li><li>发送 ping 命令 连接建立成功后从节点发送 ping 请求进行首次通信，主要是检测主从之间网络套接字是否可用、主节点当前是否可接受处理命令。</li><li>权限验证 如果主节点要求密码验证，从节点必须正确的密码才能通过验证。</li><li>同步数据集 主从复制连接正常通信后，主节点会把持有的数据全部发送给从节点。</li><li>命令持续复制 接下来主节点会持续地把写命令发送给从节点，保证主从数据一致性。</li></ol><h3 id="_18-说说主从数据同步的方式" tabindex="-1"><a class="header-anchor" href="#_18-说说主从数据同步的方式"><span>18.说说主从数据同步的方式？</span></a></h3><p>Redis 在 2.8 及以上版本使用 psync 命令完成主从数据同步，同步过程分为：全量复制和部分复制。</p><figure><img src="/blog/assets/img/redis-7518f715-6dee-4e70-b972-8aed9879e451.b7a3e4d2.png" alt="主从数据同步方式" tabindex="0" loading="lazy"><figcaption>主从数据同步方式</figcaption></figure><p><strong>全量复制</strong> 一般用于初次复制场景，Redis 早期支持的复制功能只有全量复制，它会把主节点全部数据一次性发送给从节点，当数据量较大时，会对主从节点和网络造成很大的开销。</p><p>全量复制的完整运行流程如下： <img src="/blog/assets/img/redis-aa8d2960-b341-49cc-b04c-201241fd15de.747f39bc.png" alt="全量复制" loading="lazy"></p><ol><li><p><strong>从节点发送 <code>PSYNC</code> 命令</strong></p><ul><li><p>从节点连接主节点时，发送 <code>PSYNC {runid} {offset}</code>。</p></li><li><p><code>runid</code>：上一次连接时主节点的唯一标识（第一次为 <code>?</code>）。</p></li><li><p><code>offset</code>：从节点已复制的偏移量（第一次为 <code>-1</code>）。</p></li></ul></li><li><p><strong>主节点判断能否部分复制</strong></p><ul><li>如果主节点不认识这个 <code>runid</code> 或者从节点 <code>offset</code> 太旧（超出 backlog），则返回 <code>FULLRESYNC</code>。</li></ul></li><li><p><strong>主节点创建 RDB 快照</strong></p><ul><li><p>主节点 fork 出子进程生成 RDB 文件（快照）</p></li><li><p>同时把后续写命令写入 <strong>复制积压缓冲区（backlog buffer）</strong></p></li></ul></li><li><p><strong>主节点发送 RDB 给从节点</strong></p><ul><li><p>从节点清空旧数据</p></li><li><p>接收 RDB 并加载到内存</p></li></ul></li><li><p><strong>主节点发送 backlog 缓冲区里的增量命令</strong></p><ul><li>保证 RDB 生成期间遗漏的写操作也能补齐</li></ul></li><li><p><strong>进入命令传播阶段</strong></p><ul><li><p>主节点把之后的写命令实时发送给从节点</p></li><li><p>保持主从数据一致</p></li></ul></li></ol><blockquote><p>**复制积压缓冲区:**主节点维护的一个定长环形队列，决定了从节点断线后能否部分复制</p><p>可以看做一张可重复擦写的纸，如果旧数据已经被擦除还没有同步到从节点则需要全部复制</p></blockquote><p><strong>部分复制</strong> 部分复制主要是 Redis 针对全量复制的过高开销做出的一种优化措施， 使用 psync{runId}{offset}命令实现。当从节点（slave）正在复制主节点 （master）时，如果出现网络闪断或者命令丢失等异常情况时，从节点会向 主节点要求补发丢失的命令数据，如果主节点的复制积压缓冲区内存在这部分数据则直接发送给从节点，这样就可以保持主从节点复制的一致性。</p><figure><img src="/blog/assets/img/redis-87600c72-cc6a-4656-81b2-e71864c97f23.9d830897.png" alt="部分复制" tabindex="0" loading="lazy"><figcaption>部分复制</figcaption></figure><ol><li><strong>从节点重连时发送 <code>PSYNC {runid} {offset}</code></strong><ul><li>runid：之前的主节点 ID</li><li>offset：上次复制到的位置</li></ul></li><li><strong>主节点检查</strong><ul><li>如果 runid 匹配，并且 offset 在 <strong>backlog buffer</strong> 中还在（没有被覆盖），就可以部分复制</li><li>主节点返回 <code>CONTINUE</code> 表示支持部分复制</li></ul></li><li><strong>主节点发送 backlog 中缺失的命令</strong><ul><li>从 offset+1 开始，把缺失的数据补发给从节点</li></ul></li><li><strong>进入命令传播阶段</strong><ul><li>后续实时同步写命令</li></ul></li></ol><h3 id="_19-主从复制存在哪些问题呢" tabindex="-1"><a class="header-anchor" href="#_19-主从复制存在哪些问题呢"><span>19.主从复制存在哪些问题呢？</span></a></h3><p>主从复制虽好，但也存在⼀些问题：</p><ul><li>⼀旦主节点出现故障，需要⼿动将⼀个从节点晋升为主节点，同时需要修改应⽤⽅的主节点地址， 还需要命令其他从节点去复制新的主节点，整个过程都需要⼈⼯⼲预。</li><li>主节点的写能⼒受到单机的限制。</li><li>主节点的存储能⼒受到单机的限制。</li></ul><p>第⼀个问题是Redis的⾼可⽤问题，第⼆、三个问题属于Redis的分布式问题。</p><h4 id="脑裂问题了解吗" tabindex="-1"><a class="header-anchor" href="#脑裂问题了解吗"><span>脑裂问题了解吗？</span></a></h4><p>Redis 的脑裂问题是指在主从模式或集群模式下，由于网络分区或节点故障，可能导致系统中出现多个主节点，从而引发数据不一致、数据丢失等问题。</p><p>可以通过 Sentinel 模式和 Cluster 模式中的投票机制和强制下线机制来解决。</p><h3 id="_20-redis-哨兵了解吗" tabindex="-1"><a class="header-anchor" href="#_20-redis-哨兵了解吗"><span>20.Redis 哨兵了解吗？</span></a></h3><p>哨兵（Sentinel）机制是 Redis 提供的一个高可用性解决方案，主要用来监控 Redis 主从架构中的实例，并在主节点出现故障时，自动进行故障转移。</p><figure><img src="/blog/assets/img/redis-8b1a055c-f077-49ff-9432-c194d4fc3639.6c7f5440.png" alt="Redis Sentinel" tabindex="0" loading="lazy"><figcaption>Redis Sentinel</figcaption></figure><p>Redis Sentinel ，它由两部分组成，哨兵节点和数据节点：</p><ul><li><p>哨兵节点： 哨兵系统由⼀个或多个哨兵节点组成，哨兵节点是特殊的 Redis 节点，不存储数据， 对数据节点进⾏监控。</p></li><li><p>数据节点： 主节点和从节点都是数据节点；</p></li></ul><p>在复制的基础上，哨兵实现了⾃动化的故障恢复功能，下⾯是官⽅对于哨兵功能的描述：</p><ul><li>监控（Monitoring）： 哨兵会不断地检查主节点和从节点是否运作正常。</li><li>⾃动故障转移（Automatic failover）：当主节点不能正常⼯作时，哨兵会开始⾃动故障转移 操作，它会将失效主节点的其中⼀个从节点升级为新的主节点，并让其他从节点改为复制新的主节点。</li><li>配置提供者（Configuration provider）：客户端在初始化时，通过连接哨兵来获得当前 Redis 服务的主节点地址。</li><li>通知（Notification）： 哨兵可以将故障转移的结果发送给客户端。 其中，监控和⾃动故障转移功能，使得哨兵可以及时发现主节点故障并完成转移。⽽配置提供者和通知功能，则需要在与客户端的交互中才能体现。</li></ul><h3 id="_21-redis-哨兵实现原理知道吗" tabindex="-1"><a class="header-anchor" href="#_21-redis-哨兵实现原理知道吗"><span>21.Redis 哨兵实现原理知道吗？</span></a></h3><p>哨兵的工作流程包括定时监控、主观下线和客观下线、领导者 Sentinel 节点选举、故障转移等。</p><figure><img src="/blog/assets/img/redis-4074d72a-886a-4892-8f55-80112005aad8.8aba3cf2.png" alt="Redis Sentinel工作流程" tabindex="0" loading="lazy"><figcaption>Redis Sentinel工作流程</figcaption></figure><p>每个 Sentinel 实例会定期通过 PING 命令向主节点和从节点发送心跳包。</p><figure><img src="/blog/assets/img/redis-e7708f8d-ef34-4255-b5d0-cb300c649716.15ce7444.png" alt="三个定时任务" tabindex="0" loading="lazy"><figcaption>三个定时任务</figcaption></figure><p>如果一个节点长时间没有响应 PING 命令，Sentinel 会将该节点标记为主观下线。当多个 Sentinel 同时认为一个节点不可用时，该节点被标记为客观下线。</p><figure><img src="/blog/assets/img/redis-11839a24-9249-48a5-8c9d-888aa80d91dc.e32a2e73.png" alt="主观下线和客观下线" tabindex="0" loading="lazy"><figcaption>主观下线和客观下线</figcaption></figure><p>当主节点被确认下线后，Sentinel 之间会通过类似 Raft 的选举算法进行协商，选出一个领导者 Sentinel 来负责执行故障转移。</p><figure><img src="/blog/assets/img/redis-0618a5e2-e94f-40d7-888a-e78019ba8f93.084a6538.png" alt="故障转移" tabindex="0" loading="lazy"><figcaption>故障转移</figcaption></figure><ol><li>在从节点列表中选出⼀个节点作为新的主节点，这⼀步是相对复杂⼀些的⼀步</li><li>Sentinel领导者节点会对第⼀步选出来的从节点执⾏slaveof no one命令让其成为主节点</li><li>Sentinel领导者节点会向剩余的从节点发送命令，让它们成为新主节点的从节点</li><li>Sentinel节点集合会将原来的主节点更新为从节点，并保持着对其关注，当其恢复后命令它去复制新的主节点</li></ol><h3 id="_22-领导者-sentinel-节点选举了解吗" tabindex="-1"><a class="header-anchor" href="#_22-领导者-sentinel-节点选举了解吗"><span>22.领导者 Sentinel 节点选举了解吗？</span></a></h3><p>Redis 使用 Raft 算法实现领导者选举的：当主节点挂掉后，新的主节点是由剩余的从节点发起选举后晋升的。</p><figure><img src="/blog/assets/img/redis-20240819112712.d2ce9053.png" alt=" Java 进阶之路：领导者Sentinel节点选举" tabindex="0" loading="lazy"><figcaption> Java 进阶之路：领导者Sentinel节点选举</figcaption></figure><ol><li>每个在线的Sentinel节点都有资格成为领导者，当它确认主节点主观 下线时候，会向其他 Sentinel节点发送sentinel is-master-down-by-addr命令， 要求将⾃⼰设置为领导者。</li><li>收到命令的Sentinel节点，如果没有同意过其他Sentinel节点的sentinel is-master-down-by addr命令，将同意该请求，否则拒绝。</li><li>如果该Sentinel节点发现⾃⼰的票数已经⼤于等于max（quorum， num（sentinels）/2+1）， 那么它将成为领导者。</li><li>如果此过程没有选举出领导者，将进⼊下⼀次选举。</li></ol><blockquote><p><code>quorum</code>：配置文件里设置的法定票数(至少有多少 Sentinel 认为主节点下线，才触发故障转移)</p><p><code>num（sentinels）/2+1</code>：得票超过半数</p><p><strong>两个条件都满足</strong> 时</p><p>超时时间指从节点在没有收到主节点的心跳信号或日志追加请求后，等待多长时间才会认为主节点已挂掉，从而进入候选状态并发起选举。</p></blockquote><blockquote><p><strong>领导者选举</strong>：在 <strong>Sentinel 节点</strong>中选出一个 <strong>Leader Sentinel</strong> 来主导故障转移</p><p><strong>主节点晋升</strong>：由 Leader Sentinel 在 <strong>从节点</strong>中挑选一个最优的，晋升为新的主节点</p></blockquote><h3 id="_23-新的主节点是怎样被挑选出来的" tabindex="-1"><a class="header-anchor" href="#_23-新的主节点是怎样被挑选出来的"><span>23.新的主节点是怎样被挑选出来的？</span></a></h3><p>选出新的主节点，大概分为这么几步： <img src="/blog/assets/img/redis-03976d35-20b6-4efe-aa9c-7d3759460d34.a78a39cb.png" alt="新的主节点" loading="lazy"></p><ol><li>过滤：“不健康”（主观下线、断线）、5秒内没有回复过Sentinel节点ping响应、与主节点失联超过down-after-milliseconds*10秒。</li><li>选择slave-priority（从节点优先级）最⾼的从节点列表，如果存在则返回，不存在则继续。</li><li>选择复制偏移量最⼤的从节点（复制的最完整），如果存在则返回，不存在则继续。</li><li>选择runid最⼩的从节点。</li></ol><h3 id="_24-redis-集群了解吗" tabindex="-1"><a class="header-anchor" href="#_24-redis-集群了解吗"><span>24.Redis 集群了解吗？</span></a></h3><p>前面说到了主从存在高可用和分布式的问题，哨兵解决了高可用的问题，而集群就是终极方案，一举解决高可用和分布式问题。</p><figure><img src="/blog/assets/img/redis-5cbc6009-251e-4d5b-8f22-8d543938eccb.88b1032d.png" alt="Redis 集群示意图" tabindex="0" loading="lazy"><figcaption>Redis 集群示意图</figcaption></figure><ol><li><p><strong>数据分区：</strong> 数据分区 <em>(或称数据分片)</em> 是集群最核心的功能。集群将数据分散到多个节点，一方面 突破了 <code>Redis</code> 单机内存大小的限制，<strong>存储容量大大增加</strong>；<strong>另一方面</strong> 每个主节点都可以对外提供读服务和写服务，<strong>大大提高了集群的响应能力</strong>。</p></li><li><p><strong>高可用：</strong> 集群支持主从复制和主节点的 <strong>自动故障转移</strong> <em>（与哨兵类似）</em>，当任一节点发生故障时，集群仍然可以对外提供服务。</p></li></ol><h3 id="_25-redis-cluster了解吗" tabindex="-1"><a class="header-anchor" href="#_25-redis-cluster了解吗"><span>25.Redis Cluster了解吗?</span></a></h3><p>切片集群是一种将数据分片存储在多个 Redis 实例上的集群架构，每个 Redis 实例负责存储部分数据。比如说把 25G 的数据平均分为 5 份，每份 5G，然后启动 5 个 Redis 实例，每个实例保存一份数据。</p><figure><img src="/blog/assets/img/redis-20240408104101.d2190720.png" alt="极客时间：切片集群架构图" tabindex="0" loading="lazy"><figcaption>极客时间：切片集群架构图</figcaption></figure><p>在 Redis 3.0 之前，官方并没有针对切片集群提供具体的解决方案；</p><p>但是在 Redis 3.0 之后，官方提供了 Redis Cluster，数据和实例之间的映射通过哈希槽（hash slot）来实现。</p><p>Redis Cluster 有 <code>16384 个哈希槽</code>，每个键根据其名字的 CRC16 值被映射到这些哈希槽上。然后，这些哈希槽会被均匀地分配到所有的 Redis 实例上。</p><blockquote><p>CRC16 是一种哈希算法，它可以将任意长度的输入数据映射为一个 16 位的哈希值。</p></blockquote><figure><img src="/blog/assets/img/redis-e0ed9d62-3406-40db-8b01-c931f1020612.84ba7373.png" alt="槽" tabindex="0" loading="lazy"><figcaption>槽</figcaption></figure><p>例如，如果我们有 3 个 Redis 实例，那么每个实例可能会负责大约 5461 个哈希槽。</p><p>当需要存储或检索一个键值对时，Redis Cluster 会先计算这个键的哈希槽，然后找到负责这个哈希槽的 Redis 实例，最后在这个实例上进行操作。</p><h3 id="_26-集群中数据如何分区" tabindex="-1"><a class="header-anchor" href="#_26-集群中数据如何分区"><span>26.集群中数据如何分区？</span></a></h3><p>在 Redis 集群中，数据分区是通过将数据分散到不同的节点来实现的，常见的数据分区规则有三种：节点取余分区、一致性哈希分区、虚拟槽分区。</p><figure><img src="/blog/assets/img/redis-ceb49e41-dfd7-4d1e-91f9-c299437227d2.5f7ab8fc.png" alt="分布式数据分区" tabindex="0" loading="lazy"><figcaption>分布式数据分区</figcaption></figure><h4 id="方案一-节点取余分区" tabindex="-1"><a class="header-anchor" href="#方案一-节点取余分区"><span>⽅案⼀：节点取余分区</span></a></h4><p>节点取余分区，⾮常好理解，使⽤特定的数据，⽐如Redis的键，或者⽤户ID之类，对响应的hash值取余：hash（key）%N，来确定数据映射到哪⼀个节点上。 不过该⽅案最⼤的问题是，当节点数量变化时，如扩容或收缩节点，数据节点映射关系需要重新计算，会导致数据的重新迁移。</p><figure><img src="/blog/assets/img/redis-8b1fcaec-37e6-420a-9ca2-03615232af17.bdbecef4.png" alt="节点取余分区" tabindex="0" loading="lazy"><figcaption>节点取余分区</figcaption></figure><h4 id="说说一致性哈希分区" tabindex="-1"><a class="header-anchor" href="#说说一致性哈希分区"><span>说说一致性哈希分区</span></a></h4><p>将整个 Hash 值空间组织成⼀个虚拟的圆环，然后将缓存节点的 IP 地址或者主机名做 Hash 取值后， 放置在这个圆环上。当我们需要确定某⼀个 Key 需要存取到哪个节点上的时候，先对这个 Key 做同样的 Hash 取值，确定在环上的位置，然后按照顺时针⽅向在环上“⾏⾛”，遇到的第⼀个缓存节点就是要访问的节点。 ⽐如说下⾯这张图⾥⾯，Key 1 和 Key 2 会落⼊到 Node 1 中，Key 3、Key 4 会落⼊到 Node 2 中，Key 5 落⼊到 Node 3 中，Key 6 落⼊到 Node 4 中。</p><figure><img src="/blog/assets/img/redis-89bd1c1c-251c-4f53-bba3-fe945b2ae9e2.7202931e.png" alt="一致性哈希分区" tabindex="0" loading="lazy"><figcaption>一致性哈希分区</figcaption></figure><p>这种⽅式相⽐节点取余最⼤的好处在于加⼊和删除节点只影响哈希环中相邻的节点，对其他节点⽆影响。</p><p>但它还是存在问题：</p><ul><li>缓存节点在圆环上分布不平均，会造成部分缓存节点的压⼒较⼤</li><li>当某个节点故障时，这个节点所要承担的所有访问都会被顺移到另⼀个节点上，会对后⾯这个节点造成压力。</li></ul><h4 id="方案三-hash槽分区" tabindex="-1"><a class="header-anchor" href="#方案三-hash槽分区"><span>⽅案三：HASH槽分区</span></a></h4><p>这个⽅案在⼀致性哈希分区的基础上，引⼊了 <code>虚拟节点</code> 的概念。Redis 集群使⽤的便是该⽅案，其中的虚拟节点称为 <code>槽（slot）</code>。槽是介于数据和实际节点之间的虚拟概念，每个实际节点包含⼀定数量的槽，每个槽包含哈希值在⼀定范围内的数据。</p><figure><img src="/blog/assets/img/redis-e0ed9d62-3406-40db-8b01-c931f1020612.84ba7373.png" alt="虚拟槽分配" tabindex="0" loading="lazy"><figcaption>虚拟槽分配</figcaption></figure><p>在使⽤了槽的⼀致性哈希分区中，槽是数据管理和迁移的基本单位。槽解耦了数据和实际节点 之间的关系，增加或删除节点对系统的影响很⼩。仍以上图为例，系统中有 4 个实际节点，假设为其分配 16 个槽(0-15)；</p><ul><li>槽 0-3 位于 node1；4-7 位于 node2；以此类推....</li></ul><p>如果此时删除 node2 ，只需要将槽 4-7 重新分配即可，例如槽 4-5 分配给 node3 ，槽 7 分配给 node4 ，数据在其他节点的分布仍然较为均衡。</p><blockquote><p><strong>16384 个槽必须全部分配</strong>，否则集群不可用。</p><p><strong>分配不一定均匀</strong>，但推荐均匀分配以避免数据和请求倾斜。</p></blockquote><h3 id="_27-能说说-redis-集群的原理吗" tabindex="-1"><a class="header-anchor" href="#_27-能说说-redis-集群的原理吗"><span>27.能说说 Redis 集群的原理吗？</span></a></h3><p>Redis 集群通过数据分区来实现数据的分布式存储，通过自动故障转移实现高可用。</p><h5 id="集群创建" tabindex="-1"><a class="header-anchor" href="#集群创建"><span>集群创建</span></a></h5><p>数据分区是在集群创建的时候完成的。</p><figure><img src="/blog/assets/img/redis-046a512c-baab-4e3a-9409-2af58088cceb.53f3576c.png" alt="集群创建" tabindex="0" loading="lazy"><figcaption>集群创建</figcaption></figure><p><strong>设置节点</strong> Redis 集群一般由多个节点组成，节点数量至少为 6 个才能保证组成完整高可用的集群。每个节点需要开启配置 cluster-enabled yes，让 Redis 运行在集群模式下。</p><figure><img src="/blog/assets/img/redis-e6064ba6-fd6f-4270-92f9-68c0bb98fd4b.665ab6a7.png" alt="节点和握手" tabindex="0" loading="lazy"><figcaption>节点和握手</figcaption></figure><p><strong>节点握手</strong> 节点握手是指一批运行在集群模式下的节点通过 Gossip 协议彼此通信， 达到感知对方的过程。节点握手是集群彼此通信的第一步，由客户端发起命 令：cluster meet{ip}{port}。完成节点握手之后，一个个的 Redis 节点就组成了一个多节点的集群。</p><p><strong>分配槽（slot）</strong> Redis 集群把所有的数据映射到 16384 个槽中。每个节点对应若干个槽，只有当节点分配了槽，才能响应和这些槽关联的键命令。通过 cluster addslots 命令为节点分配槽。</p><figure><img src="/blog/assets/img/redis-15341792-e7a6-428c-a109-22827e02be5f.b5e9b82e.png" alt="分配槽" tabindex="0" loading="lazy"><figcaption>分配槽</figcaption></figure><h5 id="故障转移" tabindex="-1"><a class="header-anchor" href="#故障转移"><span>故障转移</span></a></h5><p>Redis 集群的故障转移和哨兵的故障转移类似，但是 Redis 集群中所有的节点都要承担状态维护的任务。</p><p><strong>故障发现</strong> Redis 集群内节点通过 ping/pong 消息实现节点通信，集群中每个节点都会定期向其他节点发送 ping 消息，接收节点回复 pong 消息作为响应。如果在 cluster-node-timeout 时间内通信一直失败，则发送节 点会认为接收节点存在故障，把接收节点标记为主观下线（pfail）状态。</p><figure><img src="/blog/assets/img/redis-84a2a89e-f9ea-4681-b748-1a4f1dee172b.6e779a13.png" alt="主观下线" tabindex="0" loading="lazy"><figcaption>主观下线</figcaption></figure><p>当某个节点判断另一个节点主观下线后，相应的节点状态会跟随消息在集群内传播。通过 Gossip 消息传播，集群内节点不断收集到故障节点的下线报告。当 半数以上持有槽的主节点都标记某个节点是主观下线时。触发客观下线流程。</p><figure><img src="/blog/assets/img/redis-b61a6109-7aea-45ab-a53c-267eebb9180a.3c98cfcd.png" alt="主观下线和客观下线" tabindex="0" loading="lazy"><figcaption>主观下线和客观下线</figcaption></figure><p><strong>故障恢复</strong></p><p>故障节点变为客观下线后，如果下线节点是持有槽的主节点则需要在它的从节点中选出一个替换它，从而保证集群的高可用。</p><figure><img src="/blog/assets/img/redis-0e5a49b3-cb5a-4aef-a81f-fce50a012a39.8494f886.png" alt="故障恢复流程" tabindex="0" loading="lazy"><figcaption>故障恢复流程</figcaption></figure><ol><li><p>资格检查 每个从节点都要检查最后与主节点断线时间，判断是否有资格替换故障的主节点。</p></li><li><p>准备选举时间 当从节点符合故障转移资格后，更新触发故障选举的时间，只有到达该时间后才能执行后续流程。</p></li><li><p>发起选举 当从节点定时任务检测到达故障选举时间（failover_auth_time）到达后，发起选举流程。</p></li><li><p>选举投票 持有槽的主节点处理故障选举消息。投票过程其实是一个领导者选举的过程，如集群内有 N 个持有槽的主节点代表有 N 张选票。由于在每个<code>配置纪元（config epoch）</code>内持有槽的主节点只能投票给一个从节点，因此只能有一个从节点获得 N/2+1 的选票，保证能够找出唯一的从节点。</p><figure><img src="/blog/assets/img/redis-d0e16ea3-6683-43f4-82a3-80478703ae06.0e9668ce.png" alt="选举投票" tabindex="0" loading="lazy"><figcaption>选举投票</figcaption></figure></li><li><p>替换主节点 当从节点收集到足够的选票之后，触发替换主节点操作。</p></li></ol><blockquote><p><strong>配置纪元（config epoch）</strong> 每次发生故障转移，都会进入一个新的纪元（类似于版本号），这个纪元内，每个主节点（拥有槽的节点）只能投票一次，并且只能投票给一个候选从节点。</p></blockquote><h4 id="部署-redis-集群至少需要几个物理节点" tabindex="-1"><a class="header-anchor" href="#部署-redis-集群至少需要几个物理节点"><span>部署 Redis 集群至少需要几个物理节点？</span></a></h4><p>在投票选举的环节，故障主节点也算在投票数内，假设集群内节点规模是 3 主 3 从，其中有 2 个主节点部署在一台机器上，当这台机器宕机时，由于从节点无法收集到 3/2+1 个主节点选票将导致故障转移失败。这个问题也适用于故障发现环节。因此部署集群时所有主节点最少需要部署在 <strong>3 台物理机</strong>上才能避免单点问题。</p><h3 id="_28-说说集群的伸缩" tabindex="-1"><a class="header-anchor" href="#_28-说说集群的伸缩"><span>28.说说集群的伸缩？</span></a></h3><p>Redis集群提供了灵活的节点扩容和收缩⽅案，可以在不影响集群对外服务的情况下，为集群添加节点 进⾏扩容也可以下线部分节点进⾏缩容。</p><figure><img src="/blog/assets/img/redis-dd3e9494-eddb-4861-85f7-2646018d93f6.a72d8702.png" alt="集群的伸缩" tabindex="0" loading="lazy"><figcaption>集群的伸缩</figcaption></figure><p>其实，集群扩容和缩容的关键点，就在于槽和节点的对应关系，扩容和缩容就是将⼀部分槽和数据迁移给新节点。</p><p>例如下⾯⼀个集群，每个节点对应若⼲个槽，每个槽对应⼀定的数据，如果希望加⼊1个节点希望实现集群扩容时，需要通过相关命令把⼀部分槽和内容迁移给新节点。缩容也是类似，先把槽和数据迁移到其它节点，再把对应的节点下线。</p><figure><img src="/blog/assets/img/redis-1d24bb63-2b05-4db9-bd6b-983f16a4830e.48cda673.png" alt="扩容实例" tabindex="0" loading="lazy"><figcaption>扩容实例</figcaption></figure><h2 id="缓存设计" tabindex="-1"><a class="header-anchor" href="#缓存设计"><span>缓存设计</span></a></h2><h3 id="_29-缓存击穿、缓存穿透、缓存雪崩了解吗" tabindex="-1"><a class="header-anchor" href="#_29-缓存击穿、缓存穿透、缓存雪崩了解吗"><span>29.🌟缓存击穿、缓存穿透、缓存雪崩了解吗？</span></a></h3><p>缓存穿透、缓存击穿和缓存雪崩是指在使用 Redis 做缓存时可能遇到的三种高并发场景下的问题。</p><h4 id="什么是缓存击穿" tabindex="-1"><a class="header-anchor" href="#什么是缓存击穿"><span>什么是缓存击穿？</span></a></h4><p>⼀个并发访问量⽐较⼤的key在某个时间<strong>过期</strong>，导致所有的请求直接打在DB上，导致数据库瞬间压力过大。</p><figure><img src="/blog/assets/img/redis-86579ee6-9dae-4274-a5cc-af6812f48da4.908a7517.png" alt="缓存击穿" tabindex="0" loading="lazy"><figcaption>缓存击穿</figcaption></figure><p>解决⽅案：</p><p>①、加锁更新，⽐如请求查询 A，发现缓存中没有，对 A 这个 key 加锁，同时去数据库查询数据，写⼊缓存，再返回给⽤户，这样后⾯的请求就可以从缓存中拿到数据了。</p><figure><img src="/blog/assets/img/redis-cf63911a-8501-493e-a375-8b47a9f33358.0778bcc7.png" alt="加锁更新" tabindex="0" loading="lazy"><figcaption>加锁更新</figcaption></figure><p>②、将过期时间组合写在 value 中，通过异步的⽅式<strong>不断的刷新</strong>过期时间，防⽌此类现象。</p><h4 id="什么是缓存穿透" tabindex="-1"><a class="header-anchor" href="#什么是缓存穿透"><span>什么是缓存穿透？</span></a></h4><p>缓存穿透指的查询缓存和数据库中<strong>都不存在的数据</strong>，这样每次请求直接打到数据库，就好像缓存不存在 ⼀样。</p><figure><img src="/blog/assets/img/redis-029951e6-8b99-4364-a570-010853deb594.be900301.png" alt="缓存穿透" tabindex="0" loading="lazy"><figcaption>缓存穿透</figcaption></figure><p>缓存穿透意味着缓存失去了减轻数据压力的意义。缓存穿透可能有两种原因：</p><ol><li>自身业务代码问题</li><li>恶意攻击，爬虫造成空命中</li></ol><blockquote><p>它主要有两种解决办法：</p></blockquote><p>①、<strong>缓存空值/默认值</strong></p><p>⼀种⽅式是在数据库不命中之后，把⼀个空对象或者默认值保存到缓存，之后再访问这个数据，就会从 缓存中获取，这样就保护了数据库。</p><figure><img src="/blog/assets/img/redis-288af5a2-ae5a-427a-95e9-b4a658b01386.8c8a7507.png" alt="缓存空值/默认值" tabindex="0" loading="lazy"><figcaption>缓存空值/默认值</figcaption></figure><p>代码示例：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> cacheKey </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;product::&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> +</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> productId</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> result </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> cache</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">get</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(cacheKey);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (result </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">==</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    result </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> database</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">queryProductById</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(productId);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (result </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">==</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 缓存空值，设置较短的过期时间</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        cache</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">set</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(cacheKey, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;null&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, shortTTL);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    } </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">else</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 缓存有效数据</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        cache</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">set</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(cacheKey, result, longTTL);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>缓存空值有两⼤问题：</p><ol><li>空值做了缓存，意味着缓存层中存了更多的键，需要更多的内存空间（如果是攻击，问题更严重），⽐较有效的⽅法是针对这类数据设置⼀个较短的过期时间，让其⾃动剔除。</li><li>缓存层和存储层的数据会有⼀段时间窗口的不⼀致，可能会对业务有⼀定影响。 例如过期时间设置为5分钟，如果此时存储层添加了这个数据，那此段时间就会出现缓存层和存储层数据的不⼀致。 <code>这时候可以利用消息队列或者其它异步方式清理缓存中的空对象</code>。</li></ol><p>②、<strong>布隆过滤器</strong></p><p>除了缓存空对象，我们还可以在存储和缓存之前，加⼀个布隆过滤器，做⼀层过滤。</p><ul><li>如果布隆过滤器认为该键不存在，直接返回空，不会查询数据库。</li><li>如果布隆过滤器认为该键可能存在，则查询缓存和数据库。</li></ul><figure><img src="/blog/assets/img/redis-0e18ea40-a2e5-4fa6-989e-e771f6e4b0fc.0e8ceb5a.png" alt="布隆过滤器" tabindex="0" loading="lazy"><figcaption>布隆过滤器</figcaption></figure><p>代码示例：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">BloomFilter</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> bloomFilter </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> BloomFilter</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(expectedInsertions</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> fpp)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 期望插入量和误判率</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">bloomFilter</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">put</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;valid_key_1&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">bloomFilter</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">put</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;valid_key_2&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 判断请求的键是否存在于布隆过滤器中</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">!</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">bloomFilter</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">mightContain</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(requestedKey)</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 如果布隆过滤器认为该键不存在，则直接返回空</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">} </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">else</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 继续正常的缓存查询和数据库查询流程</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>两种解决方案的对比：</p><figure><img src="/blog/assets/img/redis-e8a382c9-4379-44ab-b1dc-fb598a228105.745d3709.png" alt="缓存空对象和布隆过滤器方案" tabindex="0" loading="lazy"><figcaption>缓存空对象和布隆过滤器方案</figcaption></figure><h4 id="什么是缓存雪崩" tabindex="-1"><a class="header-anchor" href="#什么是缓存雪崩"><span>什么是缓存雪崩？</span></a></h4><p>某⼀时刻发⽣⼤规模的缓存失效的情况，例如缓存服务宕机、⼤量key在同⼀时间过期，这样的后果就 是⼤量的请求进来直接打到DB上，可能导致整个系统的崩溃，称为雪崩。</p><figure><img src="/blog/assets/img/redis-1464fe22-c463-4850-8989-b899510cb10e.e039e3ec.png" alt="缓存雪崩" tabindex="0" loading="lazy"><figcaption>缓存雪崩</figcaption></figure><p>缓存雪崩是三⼤缓存问题⾥最严重的⼀种，我们来看看怎么预防和处理。</p><h4 id="如何解决缓存雪崩呢" tabindex="-1"><a class="header-anchor" href="#如何解决缓存雪崩呢"><span>如何解决缓存雪崩呢？</span></a></h4><blockquote><p>第一种：提高缓存可用性</p></blockquote><p><strong>01、集群部署</strong>：采用分布式缓存而不是单一缓存服务器，可以降低单点故障的风险。即使某个缓存节点发生故障，其他节点仍然可以提供服务，从而避免对数据库的大量直接访问。</p><p>可以利用 Redis Cluster。</p><figure><img src="/blog/assets/img/redis-20240326220634.38450cd4.png" alt="Rajat Pachauri：Redis Cluster" tabindex="0" loading="lazy"><figcaption>Rajat Pachauri：Redis Cluster</figcaption></figure><p>或者第三方集群方案 Codis。</p><figure><img src="/blog/assets/img/redis-20240326220408.bfd2218c.png" alt="极客时间：Codis" tabindex="0" loading="lazy"><figcaption>极客时间：Codis</figcaption></figure><p><strong>02多级缓存</strong>：设置多级缓存，第⼀级缓存失效的基础上，访问⼆级缓存，每⼀级缓存的失效时间都不同。</p><blockquote><p>第二种：过期时间</p></blockquote><ol><li>均匀过期：为了避免⼤量的缓存在同⼀时间过期，可以把不同的 key 过期时间随机⽣成，避免过期时间太过集中。</li><li>热点数据永不过期。</li></ol><blockquote><p>第三种：限流和降级</p></blockquote><ol><li>服务熔断：当缓存服务器宕机或超时响应时，为了防⽌整个系统出现雪崩，暂时停⽌业务服务访问缓存系统。</li><li>服务降级：当出现⼤量缓存失效，⽽且处在⾼并发⾼负荷的情况下，在业务系统内部暂时舍弃对⼀些⾮核⼼的接口和数据的请求，⽽直接返回⼀个提前准备好的 fallback（退路）错误处理信息。</li></ol><h3 id="_30-能说说布隆过滤器吗" tabindex="-1"><a class="header-anchor" href="#_30-能说说布隆过滤器吗"><span>30.能说说布隆过滤器吗？</span></a></h3><blockquote><p>元素可能有</p><p>元素一定没有</p></blockquote><p>布隆过滤器是一种 <strong>空间效率很高的概率型数据结构</strong>，主要用来判断某个元素是否存在于一个集合中。 它的特点是：</p><ul><li><strong>可能存在假阳性（false positive）</strong>：说某个元素在集合里，但实际上可能不在。</li><li><strong>绝不会有假阴性（false negative）</strong>：如果布隆过滤器说某个元素不在，那它一定不在。</li></ul><p>👉 适用于海量数据的快速存在性检测（如去重、缓存穿透拦截）。</p><figure><img src="/blog/assets/img/redis-d0b8d85c-85dc-4843-b4be-d5d48338a44e.dca183a7.png" alt="布隆过滤器" tabindex="0" loading="lazy"><figcaption>布隆过滤器</figcaption></figure><p>布隆过滤器由一个长度为 m 的位数组和 k 个哈希函数组成。</p><ul><li>开始时，布隆过滤器的每个位都被设置为 0。</li><li>当一个元素被添加到过滤器中时，它会被 k 个哈希函数分别计算得到 k 个位置，然后将位数组中对应的位设置为 1。</li><li>当检查一个元素是否存在于过滤器中时，同样使用 k 个哈希函数计算位置，如果任一位置的位为 0，则该元素肯定不在过滤器中；如果所有位置的位都为 1，则该元素可能在过滤器中。</li></ul><p>我们判断缓存key是否存在，同样，K个哈希函数，映射到bit列表上的K个点，判断是不是1：</p><ul><li>如果全不是1，那么key不存在；</li><li>如果都是1，也只是表⽰key可能存在。</li></ul><blockquote><p>布隆过滤器也有⼀些缺点：</p></blockquote><ol><li>它在判断元素是否在集合中时是有⼀定错误⼏率，因为哈希算法有⼀定的碰撞的概率。</li><li>不⽀持删除元素。</li></ol><h4 id="布隆过滤器存在误判吗" tabindex="-1"><a class="header-anchor" href="#布隆过滤器存在误判吗"><span>布隆过滤器存在误判吗？</span></a></h4><p>布隆过滤器的优点是空间效率和查询时间都远远超过一般的算法，缺点是存在误判和删除困难。</p><figure><img src="/blog/assets/img/redis-20241019191741.1b85ab0c.png" alt="勇哥：布隆过滤器" tabindex="0" loading="lazy"><figcaption>勇哥：布隆过滤器</figcaption></figure><p>当布隆过滤器保存的元素越多，被置为 1 的 bit 位就会越多。假设元素 x 没有存储过，但其他元素的哈希函数映射到位数组的三个位刚好都为 1 且恰好覆盖了元素 x 映射的位置，那么对于布隆过滤器来讲，元素 x 这个值就是存在的，也就是说布隆过滤器存在一定的误判率。</p><p>布隆过滤器的误判率取决于以下几个因素：</p><ol><li>位数组的大小（m）：位数组的大小决定了可以存储的标志位数量。如果位数组过小，那么哈希碰撞的几率就会增加，从而导致更高的误判率。</li><li>哈希函数的数量（k）：哈希函数的数量决定了每个元素在位数组中标记的位数。哈希函数越多，碰撞的概率也会相应变化。如果哈希函数太少，则过滤器很快会变得不精确；如果太多，误判率也会升高，效率下降。</li><li>存入的元素数量（n）：存入的元素越多，哈希碰撞的几率越大，从而导致更高的误判率。</li></ol><figure><img src="/blog/assets/img/redis-20241019192648.c0b91cf8.png" alt="勇哥：布隆过滤器的误判" tabindex="0" loading="lazy"><figcaption>勇哥：布隆过滤器的误判</figcaption></figure><p>误判率公式如下：</p><p>$$ f(k) = \left( 1 - e^{- \frac{kn}{m}} \right)^k $$</p><p>虽然布隆过滤器会产生误判，但在很多场景下一定的误判率是可以接受的，这是因为布隆过滤器的主要优点是其高效的查询速度和低内存占用。相比其他精确的集合数据结构（如哈希表、树等），布隆过滤器可以在空间效率和查询速度上表现更优。</p><h4 id="布隆过滤器支持删除吗" tabindex="-1"><a class="header-anchor" href="#布隆过滤器支持删除吗"><span>布隆过滤器支持删除吗？</span></a></h4><p>布隆过滤器其实并不支持删除元素，因为多个元素可能哈希到一个布隆过滤器的同一个位置，如果直接删除该位置的元素，则会影响其他元素的判断。</p><h4 id="为什么不能用哈希表而是用布隆过滤器" tabindex="-1"><a class="header-anchor" href="#为什么不能用哈希表而是用布隆过滤器"><span>为什么不能用哈希表而是用布隆过滤器？</span></a></h4><p>布隆过滤器是一种基于位数组和多个哈希函数的概率型数据结构，适合在内存资源有限、数据量大且能容忍一定误判的场景下使用。</p><p>相比哈希表，布隆过滤器的内存开销非常小，能快速判断一个元素是否存在。虽然它存在误判，但不会漏报，因此在防止缓存穿透、黑名单过滤和推荐系统去重等场景中广泛使用。</p><p>哈希表虽然可以精准判断元素存在与否，但需要存储实际数据，内存开销大，不适合大规模数据存储。</p><h4 id="布隆过滤器的优点" tabindex="-1"><a class="header-anchor" href="#布隆过滤器的优点"><span>布隆过滤器的优点？</span></a></h4><ol><li><strong>内存效率高</strong>：布隆过滤器只需要存储每个元素的哈希值，而不需要存储元素本身，因此内存占用非常小。</li><li><strong>查询速度快</strong>：布隆过滤器只需要将元素通过多个哈希函数映射到位数组，并检查位状态即可。它不需要哈希表那样的复杂键值操作，时间复杂度接近常数时间，速度非常快。</li></ol><h3 id="_31-如何保证缓存和数据库的数据一致性" tabindex="-1"><a class="header-anchor" href="#_31-如何保证缓存和数据库的数据一致性"><span>31.如何保证缓存和数据库的数据⼀致性？</span></a></h3><p>根据CAP理论，在保证可⽤性和分区容错性的前提下，⽆法保证⼀致性，所以缓存和数据库的绝对⼀ 致是不可能实现的，只能尽可能保存缓存和数据库的最终⼀致性。</p><p>选择合适的缓存更新策略</p><ol><li>删除缓存⽽不是更新缓存</li></ol><p>当⼀个线程对缓存的key进⾏写操作的时候，如果其它线程进来读数据库的时候，读到的就是脏数据，产⽣了数据不⼀致问题。 相⽐较⽽⾔，删除缓存的速度⽐更新缓存的速度快很多，所⽤时间相对也少很多，读脏数据的概率也⼩很多。</p><figure><img src="/blog/assets/img/redis-ebad0a67-3012-4466-a4dc-e834104c48f8.0c713069.png" alt="删除缓存和更新缓存" tabindex="0" loading="lazy"><figcaption>删除缓存和更新缓存</figcaption></figure><ol start="2"><li>先写数据库，后删缓存</li></ol><h4 id="那再说说为什么要先更新数据库-再删除缓存" tabindex="-1"><a class="header-anchor" href="#那再说说为什么要先更新数据库-再删除缓存"><span>那再说说为什么要先更新数据库，再删除缓存</span></a></h4><p>因为更新数据库的速度比删除缓存的速度要慢得多。因为更新 MySQL 是磁盘 IO 操作，而 Redis 是内存操作。内存操作比磁盘 IO 快得多（这是硬件层面的天然差距）。</p><p>那假如是先删除缓存，再更新数据库，就会造成这样的情况：</p><p>缓存中不存在，数据库又没有完成更新，此时有请求进来读取数据，并写入到缓存，那么在更新完缓存后，缓存中这个 key 就成了一个脏数据。</p><figure><img src="/blog/assets/img/redis-5c929a9e-a723-43b3-8f3c-f22c83765f9d.71df7143.png" alt="先更数据库还是先删缓存" tabindex="0" loading="lazy"><figcaption>先更数据库还是先删缓存</figcaption></figure><p>目前最流行的缓存读写策略 Cache Aside Pattern(<strong>旁路缓存模式</strong>)就是采用的先写数据库，再删缓存的方式。</p><ul><li>失效：应用程序先从缓存读取数据，如果数据不存在，再从数据库中读取数据，成功后，放入缓存。</li><li>命中：应用程序从缓存读取数据，如果数据存在，直接返回。</li><li>更新：先把数据写入数据库，成功后，再让缓存失效。</li></ul><figure><img src="/blog/assets/img/redis-20240325224814.0f86ba51.png" alt="左耳朵耗子：Cache Aside Pattern" tabindex="0" loading="lazy"><figcaption>左耳朵耗子：Cache Aside Pattern</figcaption></figure><h4 id="那假如对一致性要求很高-该怎么办呢" tabindex="-1"><a class="header-anchor" href="#那假如对一致性要求很高-该怎么办呢"><span>那假如对一致性要求很高，该怎么办呢？</span></a></h4><p>如果不是并发特别⾼，对缓存依赖性很强，其实⼀定程序的不⼀致是可以接受的。</p><p>但是如果对⼀致性要求⽐较⾼，那就得想办法保证缓存和数据库中数据⼀致。</p><p>缓存和数据库数据不⼀致常见的两种原因：</p><ul><li>缓存key删除失败</li><li>并发导致写⼊了脏数据</li></ul><p>那通常有四种方案可以解决。</p><figure><img src="/blog/assets/img/redis-20240325225250.75480228.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>①、引入消息队列保证缓存被删除</strong></p><p>使用消息队列（如 Kafka、RabbitMQ）保证数据库更新和缓存更新之间的最终一致性。当数据库更新完成后，将更新事件发送到消息队列。有专门的服务监听这些事件并负责更新或删除缓存。</p><figure><img src="/blog/assets/img/redis-e4a61193-515a-409f-a436-2733abc3a86e.6e988d68.png" alt="消息队列保证key被删除" tabindex="0" loading="lazy"><figcaption>消息队列保证key被删除</figcaption></figure><p>这种方案很不错，缺点是对业务代码有一定的侵入，毕竟引入了消息队列嘛。</p><p><strong>②、数据库订阅+消息队列保证缓存被删除</strong></p><p>可以专门起一个服务（比如 <a href="https://github.com/alibaba/canal" target="_blank" rel="noopener noreferrer">Canal</a>，阿里巴巴 MySQL binlog 增量订阅&amp;消费组件）去监听 MySQL 的 binlog，获取需要操作的数据。</p><figure><img src="/blog/assets/img/redis-20240325225809.ef0f8975.png" alt="教程" tabindex="0" loading="lazy"><figcaption>教程</figcaption></figure><p>然后用一个公共的服务获取订阅程序传来的信息，进行缓存删除。</p><figure><img src="/blog/assets/img/redis-37c07418-9cd8-43d9-90e7-0cb43b329025.c58136a8.png" alt="数据库订阅+消息队列保证key被删除" tabindex="0" loading="lazy"><figcaption>数据库订阅+消息队列保证key被删除</figcaption></figure><p>这种方式虽然降低了对业务的侵入，但增加了整个系统的复杂度，适合基建完善的大厂。</p><p><strong>③、延时双删防止脏数据</strong></p><p>简单说，就是在第一次删除缓存之后，过一段时间之后，再次删除缓存。</p><p>主要针对缓存不存在，但写入了脏数据的情况。在先删缓存，再写数据库的更新策略下发生的比较多。</p><figure><img src="/blog/assets/img/redis-fab24753-9c53-4432-9413-5feba07ae1e3.8728c0e4.png" alt="延时双删" tabindex="0" loading="lazy"><figcaption>延时双删</figcaption></figure><p>这种方式的延时时间需要仔细考量和测试。</p><p><strong>④：设置缓存过期时间兜底</strong></p><p>这是一个朴素但有用的兜底策略，给缓存设置一个合理的过期时间，即使发生了缓存和数据库的数据不一致问题，也不会永远不一致下去，缓存过期后，自然就一致了。</p><h3 id="_32-如何保证本地缓存和分布式缓存的一致" tabindex="-1"><a class="header-anchor" href="#_32-如何保证本地缓存和分布式缓存的一致"><span>32.如何保证本地缓存和分布式缓存的一致？</span></a></h3><p>PS:这道题⾯试很少问，但实际⼯作中很常见。</p><p>在⽇常的开发中，我们常常采⽤两级缓存：本地缓存+分布式缓存。 所谓本地缓存，就是对应服务器的内存缓存，⽐如Caffeine，分布式缓存基本就是采⽤Redis。</p><p>那么问题来了，本地缓存和分布式缓存怎么保持数据⼀致？</p><figure><img src="/blog/assets/img/redis-6d4ab7e6-8337-4576-bbf0-79202a1c3331.19b53071.png" alt="延时双删" tabindex="0" loading="lazy"><figcaption>延时双删</figcaption></figure><p>Redis缓存，数据库发⽣更新，直接删除缓存的key即可，因为对于应⽤系统⽽⾔，它是⼀种中⼼化的 缓存。 但是本地缓存，它是⾮中⼼化的，散落在分布式服务的各个节点上，没法通过客户端的请求删除本地缓 存的key，所以得想办法通知集群所有节点，删除对应的本地缓存key。</p><p>为了保证本地缓存和 Redis 缓存的一致性，通常采用的策略有：</p><p>①、设置本地缓存的过期时间，这是最简单也是最直接的方法，当本地缓存过期时，就从 Redis 缓存中去同步。</p><p>②、使用 Redis 的 Pub/Sub 机制，当 Redis 缓存发生变化时，发布一个消息，本地缓存订阅这个消息，然后删除对应的本地缓存。</p><p>③、Redis 缓存发生变化时，引入消息队列，比如 RocketMQ、RabbitMQ 去更新本地缓存。</p><figure><img src="/blog/assets/img/redis-20c15f0d-fb3c-4922-94b1-edcd856658be.4509e9da.png" alt="本地缓存/分布式缓存保持一致" tabindex="0" loading="lazy"><figcaption>本地缓存/分布式缓存保持一致</figcaption></figure><h4 id="如果在项目中多个地方都要使用到二级缓存的逻辑-如何设计这一块" tabindex="-1"><a class="header-anchor" href="#如果在项目中多个地方都要使用到二级缓存的逻辑-如何设计这一块"><span>如果在项目中多个地方都要使用到二级缓存的逻辑，如何设计这一块？</span></a></h4><p>在设计时，应该清楚地区分何时使用一级缓存和何时使用二级缓存。通常情况下，对于频繁访问但不经常更改的数据，可以放在本地缓存中以提供最快的访问速度。而对于需要共享或者一致性要求较高的数据，应当放在一级缓存中。</p><h4 id="本地缓存和-redis-缓存的区别和效率对比" tabindex="-1"><a class="header-anchor" href="#本地缓存和-redis-缓存的区别和效率对比"><span>本地缓存和 Redis 缓存的区别和效率对比？</span></a></h4><p>Redis 可以部署在多个节点上，支持数据分片，适用于跨服务器的缓存共享。而本地缓存只能在单个服务器上使用。</p><p>Redis 还可以持久化数据，支持数据备份和恢复，适用于对数据安全性要求较高的场景。并且支持发布/订阅、事务、Lua 脚本等高级功能。</p><p>效率上，Redis 和本地缓存都是存储在内存中，读写速度都非常快。</p><h3 id="_33-怎么处理热-key" tabindex="-1"><a class="header-anchor" href="#_33-怎么处理热-key"><span>33.怎么处理热 key？</span></a></h3><p>推荐阅读：</p><ul><li><a href="https://help.aliyun.com/zh/redis/user-guide/identify-and-handle-large-keys-and-hotkeys" target="_blank" rel="noopener noreferrer">阿里：发现并处理 Redis 的大 Key 和热 Key</a></li><li><a href="https://dongzl.github.io/2021/01/14/03-Redis-Hot-Key/index.html" target="_blank" rel="noopener noreferrer">董宗磊：Redis 热 Key 发现以及解决办法</a></li></ul><p>所谓的热 key，就是指在很短时间内被频繁访问的键。</p><p>比如，热门新闻或热门商品，这类 key 通常会有大流量的访问，对存储这类信息的 Redis 来说，是不小的压力。</p><blockquote><p>某天某流量明星突然爆出一个大瓜，微博突然就崩了，这就是热 key 的压力。</p></blockquote><p>再比如说 Redis 是集群部署，热 key 可能会造成整体流量的不均衡（网络带宽、CPU 和内存资源），个别节点出现 OPS 过大的情况，极端情况下热点 key 甚至会超过 Redis 本身能够承受的 OPS。</p><blockquote><p>OPS（Operations Per Second）是 Redis 的一个重要指标，表示 Redis 每秒钟能够处理的命令数。</p></blockquote><p>通常以 Key 被请求的频率来判定，比如：</p><ul><li><strong>QPS 集中在特定的 Key</strong>：总的 QPS（每秒查询率）为 10000，其中一个 Key 的 QPS 飙到了 8000。</li><li><strong>带宽使用率集中在特定的 Key</strong>：一个拥有上千成员且总大小为 1M 的哈希 Key，每秒发送大量的 HGETALL 请求。</li><li><strong>CPU 使用率集中在特定的 Key</strong>：一个拥有数万个成员的 ZSET Key，每秒发送大量的 ZRANGE 请求。</li></ul><blockquote><ul><li>HGETALL 命令用于返回哈希表中，所有的字段和值。</li><li>ZRANGE 命令用于返回有序集中，指定区间内的成员。</li></ul></blockquote><h4 id="怎么处理热-key" tabindex="-1"><a class="header-anchor" href="#怎么处理热-key"><span>怎么处理热 key？</span></a></h4><figure><img src="/blog/assets/img/redis-6fa972ec-5531-48f2-a608-4465d79d4518.f9fc1d76.png" alt="热key处理" tabindex="0" loading="lazy"><figcaption>热key处理</figcaption></figure><p>对热 key 的处理，最关键的是对热 key 的监控:</p><p>①、客户端</p><p>客户端其实是距离 key“最近”的地方，因为 Redis 命令就是从客户端发出的，例如在客户端设置全局字典（key 和调用次数），每次调用 Redis 命令时，使用这个字典进行记录。</p><p>②、代理端</p><p>像 Twemproxy、Codis 这些基于代理的 Redis 分布式架构，所有客户端的请求都是通过代理端完成的，可以在代理端进行监控。</p><p>③、Redis 服务端</p><p>使用 monitor 命令统计热点 key 是很多开发和运维人员首先想到的方案，monitor 命令可以监控到 Redis 执行的所有命令。</p><blockquote><p>monitor 命令的使用：<code>redis-cli monitor</code></p></blockquote><figure><img src="/blog/assets/img/redis-20240309085135.ffe54fe1.png" alt=" Java 进阶之路：monitor" tabindex="0" loading="lazy"><figcaption> Java 进阶之路：monitor</figcaption></figure><p>还可以通过 bigkeys 参数来分析热 Key。</p><blockquote><p>bigkeys 命令的使用：<code>redis-cli --bigkeys</code></p></blockquote><figure><img src="/blog/assets/img/redis-20240309090340.b6b0086d.png" alt=" Java 进阶之路：bigkeys" tabindex="0" loading="lazy"><figcaption> Java 进阶之路：bigkeys</figcaption></figure><p>只要监控到了热 key，对热 key 的处理就简单了：</p><p>①、把热 key 打散到不同的服务器，降低压⼒。</p><p>基本思路就是给热 Key 加上前缀或者后缀，见下例：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// N 为 Redis 实例个数，M 为 N 的 2倍</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> M </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> N </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">*</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 2</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">//生成随机数</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">random </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> GenRandom</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> M)</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">//构造备份新 Key</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">bakHotKey </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> hotKey </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;_&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> +</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> random</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">data </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> redis</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">GET</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(bakHotKey)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> data </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">==</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> NULL {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    data </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> redis</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">GET</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(hotKey)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> data </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">==</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> NULL {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">        data </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> GetFromDB</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">()</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 可以利用原子锁来写入数据保证数据一致性</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        redis</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">SET</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(hotKey, data, expireTime)</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        redis</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">SET</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(bakHotKey, data, expireTime </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> GenRandom</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">5</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">))</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    } </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">else</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        redis</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">SET</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(bakHotKey, data, expireTime </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> GenRandom</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">5</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">))</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>②、加⼊⼆级缓存，当出现热 Key 后，把热 Key 加载到 JVM 中，后续针对这些热 Key 的请求，直接从 JVM 中读取。</p><p>这些本地的缓存工具有很多，比如 Caffeine、Guava 等，或者直接使用 HashMap 作为本地缓存都是可以的。</p><p>注意，如果对热 Key 进行本地缓存，需要防止本地缓存过大。</p><h3 id="_34-缓存预热怎么做呢" tabindex="-1"><a class="header-anchor" href="#_34-缓存预热怎么做呢"><span>34.缓存预热怎么做呢？</span></a></h3><p>所谓缓存预热，就是提前把数据库⾥的数据刷到缓存里，通常有这些⽅法：</p><ol><li>直接写个缓存刷新页⾯或者接口，上线时⼿动操作</li><li>数据量不大，可以在项⽬启动的时候⾃动进⾏加载</li><li>定时任务刷新缓存</li></ol><h3 id="_35-热点-key-重建-问题-解决" tabindex="-1"><a class="header-anchor" href="#_35-热点-key-重建-问题-解决"><span>35.热点 key 重建？问题？解决？</span></a></h3><p>开发的时候⼀般使⽤“缓存+过期时间”的策略，既可以加速数据读写，又保证数据的定期更新，这种模式基本能够满⾜绝⼤部分需求。</p><p>但是有两个问题如果同时出现，可能就会出现⽐较⼤的问题：</p><ul><li>当前key是⼀个热点key（例如⼀个热门的娱乐新闻），并发量⾮常⼤。</li><li>重建缓存不能在短时间完成，可能是⼀个复杂计算，例如复杂的 SQL、多次IO、多个依赖等。 在缓存失效的瞬间，有⼤量线程来重建缓存，造成后端负载加⼤，甚⾄可能会让应⽤崩溃。</li></ul><blockquote><p>怎么处理呢？</p></blockquote><p>要解决这个问题也不是很复杂，解决问题的要点在于：</p><ul><li>减少重建缓存的次数。</li><li>数据尽可能⼀致。</li><li>较少的潜在危险。</li></ul><blockquote><p>所以⼀般采⽤如下⽅式：</p></blockquote><ol><li>互斥锁（mutex key） 这种⽅法只允许⼀个线程重建缓存，其他线程等待重建缓存的线程执⾏完，重新从缓存获取数据即可。</li><li>永远不过期</li></ol><p>“永远不过期”包含两层意思：</p><ul><li>从缓存层⾯来看，确实没有设置过期时间，所以不会出现热点key过期后产⽣的问题，也就是“物理”不过期。</li><li>从功能层⾯来看，为每个value设置⼀个逻辑过期时间，当发现超过逻辑过期时间后，会使⽤单独的线程去构建缓存。</li></ul><h3 id="_36-无底洞问题吗-如何解决" tabindex="-1"><a class="header-anchor" href="#_36-无底洞问题吗-如何解决"><span>36.无底洞问题吗？如何解决？</span></a></h3><blockquote><p>什么是⽆底洞问题？</p></blockquote><p>2010年，Facebook的Memcache节点已经达到了3000个，承载着TB级别的缓存数据。但开发和运维⼈员发现了⼀个问题，为了满⾜业务要求添加了⼤量新Memcache节点，但是发现性能不但没有好转反⽽下降了，当时将这种现象称为缓存的“⽆底洞”现象。</p><blockquote><p>那么为什么会产⽣这种现象呢?</p></blockquote><p>通常来说添加节点使得Memcache集群性能应该更强了，但事实并⾮如此。键值数据库由于通常采⽤哈希函数将 key映射到各个节点上，造成key的分布与业务⽆关，但是由于数据量和访问量的持续增长，造成需要添加⼤量节点做⽔平扩容，导致键值分布到更多的节点上，所以⽆论是Memcache还是 Redis的分布式，批量操作通常需要从不同节点上获取，相⽐于单机批量操作只涉及⼀次⽹络操作，分布式批量操作会涉及多次⽹络时间。</p><blockquote><p>⽆底洞问题如何优化呢？</p></blockquote><p><strong>先分析⼀下⽆底洞问题：</strong></p><ul><li>客户端⼀次批量操作会涉及多次⽹络操作，也就意味着批量操作会随着节点的增多，耗时会不断增⼤。</li><li>⽹络连接数变多，对节点的性能也有⼀定影响。</li></ul><p><strong>常见的优化思路如下：</strong></p><ul><li>命令本⾝的优化，例如优化操作语句等。</li><li>减少⽹络通信次数。</li><li>降低接⼊成本，例如客户端使⽤长连/连接池、NIO等。</li></ul><h2 id="redis-运维" tabindex="-1"><a class="header-anchor" href="#redis-运维"><span>Redis 运维</span></a></h2><h3 id="_37-redis-报内存不足怎么处理" tabindex="-1"><a class="header-anchor" href="#_37-redis-报内存不足怎么处理"><span>37.Redis 报内存不足怎么处理？</span></a></h3><p>Redis 内存不足有这么几种处理方式：</p><ul><li>修改配置文件 redis.conf 的 maxmemory 参数，增加 Redis 可用内存</li><li>也可以通过命令 set maxmemory 动态设置内存上限</li><li>修改内存淘汰策略，及时释放内存空间</li><li>使用 Redis 集群模式，进行横向扩容。</li></ul><h3 id="_38-redis-key-过期策略有哪些" tabindex="-1"><a class="header-anchor" href="#_38-redis-key-过期策略有哪些"><span>38.Redis key 过期策略有哪些？</span></a></h3><p>Redis 的 key 过期回收策略主要有两种：惰性删除和定期删除。</p><figure><img src="/blog/assets/img/redis-20240326214119.c08086d5.png" alt=" Java 进阶之路：Redis 的过期淘汰策略" tabindex="0" loading="lazy"><figcaption> Java 进阶之路：Redis 的过期淘汰策略</figcaption></figure><blockquote><p>惰性删除</p></blockquote><p>惰性删除指的是当我们查询key的时候才对key进⾏检测，如果已经达到过期时间，则删除。显然，他有⼀个缺点就是如果这些过期的key没有被访问，那么他就⼀直⽆法被删除，⽽且⼀直占⽤内存。</p><blockquote><p>定期删除</p></blockquote><p>定期删除指的是Redis每隔⼀段时间对数据库做⼀次检查，删除⾥⾯的过期key。由于不可能对所有key 去做轮询来删除，所以Redis会每次随机取⼀些key去做检查和删除。</p><h4 id="拓展" tabindex="-1"><a class="header-anchor" href="#拓展"><span>拓展</span></a></h4><hr><p>可以通过 <code>config get hz</code> 命令查看 Redis 内部定时任务的频率。</p><figure><img src="/blog/assets/img/redis-20240326214800.491d32d9.png" alt=" Java 进阶之路：config get hz" tabindex="0" loading="lazy"><figcaption> Java 进阶之路：config get hz</figcaption></figure><p>结果显示 hz 的值为 &quot;10&quot;，意味着 Redis 服务器每秒执行定时任务的频率是 10 次。可以通过 <code>CONFIG SET hz 20</code> 进行调整。</p><figure><img src="/blog/assets/img/redis-20240326215240.271d01d1.png" alt="二哥本地 Redis 的配置文件路径和 hz 的默认值" tabindex="0" loading="lazy"><figcaption>二哥本地 Redis 的配置文件路径和 hz 的默认值</figcaption></figure><h3 id="_39-redis-有哪些内存淘汰策略" tabindex="-1"><a class="header-anchor" href="#_39-redis-有哪些内存淘汰策略"><span>39.Redis 有哪些内存淘汰策略？</span></a></h3><p>当内存使用接近 maxmemory 限制时，Redis 会依据内存淘汰策略来决定删除哪些 key 以缓解内存压力。</p><figure><img src="/blog/assets/img/1756627839456-1cb38e74-ce1d-4c43-8bf0-2e02ac159804.3d41d90c.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><blockquote><p>内存淘汰策略</p></blockquote><p>常用的内存淘汰策略有八种，分别是默认的 noeviction，内存不足时不会删除任何 key，直接返回错误信息，生产环境下基本上不会使用。</p><p>然后是针对所有 key 的 allkeys-lru、allkeys-lfu 和 allkeys-random。</p><ul><li><p>lru 会删除最近最少使用的 key，在纯缓存场景中最常用，能自动保留热点数据；</p></li><li><p>lfu 会删除访问频率最低的 key，更适合长期运行的系统；</p></li></ul><p>random 会随机删除一些 key，一般不推荐使用。</p><p>其次是针对设置了过期时间的 key，有 volatile-lru、volatile-lfu、volatile-ttl 和 volatile-random。</p><p>lru 在混合存储场景中经常使用。</p><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" data-title="plain" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>@Service</span></span>
<span class="line"><span>public class HybridStorageService {</span></span>
<span class="line"><span>    </span></span>
<span class="line"><span>    // 重要数据不设置过期时间，临时数据设置过期时间</span></span>
<span class="line"><span>    public void storeData(String key, Object data, DataImportance importance) {</span></span>
<span class="line"><span>        if (importance == DataImportance.HIGH) {</span></span>
<span class="line"><span>            // 重要数据不设置过期时间，在volatile-*策略下不会被淘汰</span></span>
<span class="line"><span>            redisTemplate.opsForValue().set(key, data);</span></span>
<span class="line"><span>        } else {</span></span>
<span class="line"><span>            // 临时数据设置过期时间，可以被volatile-*策略淘汰</span></span>
<span class="line"><span>            redisTemplate.opsForValue().set(key, data, Duration.ofHours(1));</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>lfu 适合需要保护某些重要数据不被淘汰的场景；ttl 优先删除即将过期的 key，在用户会话管理系统中推荐使用；random 仍然很少用。</p><blockquote><p>TTL，Time To Live，存活时间</p><p>LRU：页面置算法，最近最久未使用</p></blockquote><h4 id="lru-和-lfu-的区别是什么" tabindex="-1"><a class="header-anchor" href="#lru-和-lfu-的区别是什么"><span>LRU 和 LFU 的区别是什么？</span></a></h4><p>LRU（Least Recently Used）：基于时间维度，淘汰最近最少访问的键。适合访问具有时间特性的场景。</p><p>LFU（Least Frequently Used）：基于次数维度，淘汰访问频率最低的键。更适合长期热点数据场景。</p><h3 id="_40-redis-阻塞-怎么解决" tabindex="-1"><a class="header-anchor" href="#_40-redis-阻塞-怎么解决"><span>40.Redis 阻塞？怎么解决？</span></a></h3><p>Redis 发生阻塞，可以从以下几个方面排查： <img src="/blog/assets/img/redis-e6a35258-7a78-4489-90b7-e47a4190802b.de8591b8.png" alt="Redis阻塞排查" loading="lazy"></p><ul><li><p><strong>API 或数据结构使用不合理</strong></p><p>通常 Redis 执行命令速度非常快，但是不合理地使用命令，可能会导致执行速度很慢，导致阻塞，对于高并发的场景，应该尽量避免在大对象上执行算法复杂 度超过 O（n）的命令。</p><p>对慢查询的处理分为两步：</p><ol><li>发现慢查询： slowlog get{n}命令可以获取最近 的 n 条慢查询命令；</li><li>发现慢查询后，可以从两个方向去优化慢查询： 1）修改为低算法复杂度的命令，如 hgetall 改为 hmget 等，禁用 keys、sort 等命 令 2）调整大对象：缩减大对象数据或把大对象拆分为多个小对象，防止一次命令操作过多的数据。</li></ol></li><li><p><strong>CPU 饱和的问题</strong></p><p>单线程的 Redis 处理命令时只能使用一个 CPU。而 CPU 饱和是指 Redis 单核 CPU 使用率跑到接近 100%。</p><p>针对这种情况，处理步骤一般如下：</p><ol><li>判断当前 Redis 并发量是否已经达到极限，可以使用统计命令 redis-cli-h{ip}-p{port}--stat 获取当前 Redis 使用情况</li><li>如果 Redis 的请求几万+，那么大概就是 Redis 的 OPS 已经到了极限，应该做集群化水平扩展来分摊 OPS 压力</li><li>如果只有几百几千，那么就得排查命令和内存的使用</li></ol></li><li><p><strong>持久化相关的阻塞</strong></p><p>对于开启了持久化功能的 Redis 节点，需要排查是否是持久化导致的阻塞。</p><ol><li>fork 阻塞 fork 操作发生在 RDB 和 AOF 重写时，Redis 主线程调用 fork 操作产生共享内存的子进程，由子进程完成持久化文件重写工作。如果 fork 操作本身耗时过长，必然会导致主线程的阻塞。</li><li>AOF 刷盘阻塞 当我们开启 AOF 持久化功能时，文件刷盘的方式一般采用每秒一次，后台线程每秒对 AOF 文件做 fsync 操作。当硬盘压力过大时，fsync 操作需要等 待，直到写入完成。如果主线程发现距离上一次的 fsync 成功超过 2 秒，为了 数据安全性它会阻塞直到后台线程执行 fsync 操作完成。</li><li>HugePage 写操作阻塞 对于开启 Transparent HugePages 的 操作系统，每次写命令引起的复制内存页单位由 4K 变为 2MB，放大了 512 倍，会拖慢写操作的执行时间，导致大量写操作慢查询。</li></ol></li></ul><h3 id="_41-大-key-问题了解吗" tabindex="-1"><a class="header-anchor" href="#_41-大-key-问题了解吗"><span>41.大 key 问题了解吗？</span></a></h3><blockquote><p>大 key 是什么</p></blockquote><ul><li><p>单个简单的key存储的value很⼤，size超过10KB</p></li><li><p>hash， set，zset，list 中存储过多的元素（以万为单位）</p></li></ul><blockquote><p>⼤key会造成什么问题呢？</p></blockquote><ul><li><p>客户端耗时增加，甚⾄超时</p></li><li><p>对⼤key进⾏IO操作时，会严重占⽤带宽和CPU</p></li><li><p>造成Redis集群中数据倾斜</p></li><li><p>主动删除、被动删等，可能会导致阻塞</p></li></ul><blockquote><p>如何找到⼤key?</p></blockquote><ul><li><p>bigkeys命令：使⽤bigkeys命令以遍历的⽅式分析Redis实例中的所有Key，并返回整体统计信息与每个数据类型中Top1的⼤Key</p></li><li><p>redis-rdb-tools：redis-rdb-tools是由Python写的⽤来分析Redis的rdb快照⽂件⽤的⼯具，它可以把rdb快照⽂件⽣成json⽂件或者⽣成报表⽤来分析Redis的使⽤详情。</p></li></ul><blockquote><p>如何处理⼤key</p></blockquote><figure><img src="/blog/assets/img/redis-e4aaafda-fce1-47f0-8b2b-7261d47b720b.b924d654.png" alt="大key处理" tabindex="0" loading="lazy"><figcaption>大key处理</figcaption></figure><p>①、<strong>删除大 key</strong></p><ul><li>当 Redis 版本大于 4.0 时，可使用 UNLINK 命令安全地删除大 Key，该命令能够以非阻塞的方式，逐步地清理传入的大 Key。</li><li>当Redis版本⼩于4.0时，避免使⽤阻塞式命令KEYS，⽽是建议通过SCAN命令执⾏增量迭代 扫描key，然后判断进⾏删除。</li></ul><p>②、<strong>压缩和拆分 key</strong></p><ul><li>当vaule是string时，⽐较难拆分，则使⽤序列化、压缩算法将key的⼤⼩控制在合理范围内， 但是序列化和反序列化都会带来更多时间上的消耗。</li><li>当value是string，压缩之后仍然是⼤key，则需要进⾏拆分，⼀个⼤key分为不同的部分，记录每个部分的key，使⽤multiget等操作实现事务读取。</li><li>当value是list/set等集合类型时，根据预估的数据规模来进⾏分⽚，不同的元素计算后分到不同的⽚。</li></ul><h3 id="_42-redis-常见性能问题和解决方案" tabindex="-1"><a class="header-anchor" href="#_42-redis-常见性能问题和解决方案"><span>42.Redis 常见性能问题和解决方案？</span></a></h3><ol><li>Master 最好不要做任何持久化工作，包括内存快照和 AOF 日志文件，特别是不要启用内存快照做持久化。</li><li>如果数据比较关键，某个 Slave 开启 AOF 备份数据，策略为每秒同步一次。</li><li>为了主从复制的速度和连接的稳定性，Slave 和 Master 最好在同一个局域网内。</li><li>尽量避免在压力较大的主库上增加从库。</li><li>Master 调用 BGREWRITEAOF 重写 AOF 文件，AOF 在重写的时候会占大量的 CPU 和内存资源，导致服务 load 过高，出现短暂服务暂停现象。</li><li>为了 Master 的稳定性，主从复制不要用图状结构，用单向链表结构更稳定，即主从关系为：Master&lt;–Slave1&lt;–Slave2&lt;–Slave3…，这样的结构也方便解决单点故障问题，实现 Slave 对 Master 的替换，也即，如果 Master 挂了，可以立马启用 Slave1 做 Master，其他不变。</li></ol><h2 id="redis-应用" tabindex="-1"><a class="header-anchor" href="#redis-应用"><span>Redis 应用</span></a></h2><h3 id="_43-使用-redis-如何实现异步队列" tabindex="-1"><a class="header-anchor" href="#_43-使用-redis-如何实现异步队列"><span>43.使用 Redis 如何实现异步队列？</span></a></h3><p>我们知道 redis 支持很多种结构的数据，那么如何使用 redis 作为异步队列使用呢？ 一般有以下几种方式：</p><ul><li><strong>使用 list 作为队列，lpush 生产消息，rpop 消费消息</strong></li></ul><p>这种方式，消费者死循环 rpop 从队列中消费消息。但是这样，即使队列里没有消息，也会进行 rpop，会导致 Redis CPU 的消耗。 <img src="/blog/assets/img/redis-e4b192a1-3ba7-4f4e-98de-e93f437cff7c.8fa48328.png" alt="list作为队列" loading="lazy"> 可以通过让消费者休眠的方式的方式来处理，但是这样又会又消息的延迟问题。</p><p>-<strong>使用 list 作为队列，lpush 生产消息，brpop 消费消息</strong></p><p>brpop 是 rpop 的阻塞版本，list 为空的时候，它会一直阻塞，直到 list 中有值或者超时。 <img src="/blog/assets/img/redis-e9581e51-ffc8-4326-9af4-07816743dc88.2d52c4c0.png" alt="list作为队列，brpop" loading="lazy"></p><p>这种方式只能实现一对一的消息队列。</p><ul><li><strong>使用 Redis 的 pub/sub 来进行消息的发布/订阅</strong></li></ul><p>发布/订阅模式可以 1：N 的消息发布/订阅。发布者将消息发布到指定的频道频道（channel），订阅相应频道的客户端都能收到消息。</p><p><img src="/blog/assets/img/redis-bc6d05be-3701-4e23-b4ca-6330c949f020.006d0033.png" alt="pub/sub" loading="lazy"> 但是这种方式不是可靠的，它不保证订阅者一定能收到消息，也不进行消息的存储。</p><p>所以，一般的异步队列的实现还是交给专业的消息队列。</p><h3 id="_44-redis-如何实现延时队列" tabindex="-1"><a class="header-anchor" href="#_44-redis-如何实现延时队列"><span>44.Redis 如何实现延时队列?</span></a></h3><p>可以使用 Redis 的 zset（有序集合）来实现延时队列。</p><figure><img src="/blog/assets/img/redis-54bbcc36-0b00-4142-a6eb-bf2ef48c2213.5d409ff2.png" alt="zset实现延时队列" tabindex="0" loading="lazy"><figcaption>zset实现延时队列</figcaption></figure><p>第一步，将任务添加到 zset 中，score 为任务的执行时间戳，value 为任务的内容。</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">ZADD</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> delay_queue</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1617024000</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> task1</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>第二步，定期（例如每秒）从 zset 中获取 score 小于当前时间戳的任务，然后执行任务。</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">ZREMRANGEBYSCORE</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> delay_queue</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -inf</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1617024000</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>第三步，任务执行后，从 zset 中删除任务。</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">ZREM</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> delay_queue</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> task1</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="_45-redis-支持事务吗" tabindex="-1"><a class="header-anchor" href="#_45-redis-支持事务吗"><span>45.Redis 支持事务吗？</span></a></h3><p>Redis提供了简单的事务，但它对事务ACID的⽀持并不完备。</p><p>multi命令代表事务开始，exec命令代表事务结束，它们之间的命令是原⼦顺序执⾏的</p><p>主要通过 multi、exec、discard、watch 等命令来实现：</p><ul><li>multi：标记一个事务块的开始</li><li>exec：执行所有事务块内的命令</li><li>discard：取消事务，放弃执行事务块内的所有命令</li><li>watch：监视一个或多个 key，如果在事务执行之前这个 key 被其他命令所改动，那么事务将被打断</li></ul><figure><img src="/blog/assets/img/redis-20240314101439.1338ca0e.png" alt=" Java 进阶之路：Redis 事务" tabindex="0" loading="lazy"><figcaption> Java 进阶之路：Redis 事务</figcaption></figure><h4 id="说一下-redis-事务的原理" tabindex="-1"><a class="header-anchor" href="#说一下-redis-事务的原理"><span>说一下 Redis 事务的原理？</span></a></h4><figure><img src="/blog/assets/img/redis-2ed7ae21-16a6-4716-ac89-117a8c76d3db.9732bcfc.png" alt="Redis事务" tabindex="0" loading="lazy"><figcaption>Redis事务</figcaption></figure><ul><li>使用 MULTI 命令开始一个事务。从这个命令执行之后开始，所有的后续命令都不会立即执行，而是被放入一个队列中。在这个阶段，Redis 只是记录下了这些命令。</li><li>使用 EXEC 命令触发事务的执行。一旦执行了 EXEC，之前 MULTI 后队列中的所有命令会被原子地（atomic）执行。这里的“原子”意味着这些命令要么全部执行，要么（在出现错误时）全部不执行。</li><li>如果在执行 EXEC 之前决定不执行事务，可以使用 DISCARD 命令来取消事务。这会清空事务队列并退出事务状态。</li><li>WATCH 命令用于实现乐观锁。WATCH 命令可以监视一个或多个键，如果在执行事务的过程中（即在执行 MULTI 之后，执行 EXEC 之前），被监视的键被其他命令改变了，那么当执行 EXEC 时，事务将被取消，并且返回一个错误。</li></ul><h4 id="redis-事务的注意点有哪些" tabindex="-1"><a class="header-anchor" href="#redis-事务的注意点有哪些"><span>Redis 事务的注意点有哪些？</span></a></h4><ul><li><p>Redis 事务是不⽀持回滚的，不像 MySQL 的事务⼀样，要么都执⾏要么都不执⾏；</p></li><li><p>Redis 服务端在执⾏事务的过程中，不会被其他客户端发送来的命令请求打断。直到事务命令全部执⾏完毕才会执⾏其他客户端的命令。</p></li></ul><h4 id="redis-事务为什么不支持回滚" tabindex="-1"><a class="header-anchor" href="#redis-事务为什么不支持回滚"><span>Redis 事务为什么不支持回滚？</span></a></h4><p>引入事务回滚机制会大大增加 Redis 的复杂性，因为需要跟踪事务中每个命令的状态，并在发生错误时逆向执行命令以恢复原始状态。</p><p>Redis 是一个基于内存的数据存储系统，其设计重点是实现高性能。事务回滚需要额外的资源和时间来管理和执行，这与 Redis 的设计目标相违背。因此，Redis 选择不支持事务回滚。</p><p>换句话说，<strong>就是我 Redis 不想支持事务，也没有这个必要</strong>。</p><h4 id="redis-事务的-acid-特性如何体现" tabindex="-1"><a class="header-anchor" href="#redis-事务的-acid-特性如何体现"><span>Redis 事务的 ACID 特性如何体现？</span></a></h4><p>ACID 一般指 MySQL 事务中的四个特性：原子性、一致性、隔离性、持久性。虽然 Redis 提供了事务的支持，但它在 ACID 上的表现与 MySQL 有所不同。</p><p>Redis 事务中，所有命令会依次执行，但并不支持部分失败后的自动回滚。因此 Redis 在事务层面并不能保证一致性，我们必须通过程序逻辑来进行优化。</p><p>Redis 事务在一定程度上提供了隔离性，事务中的命令会按顺序执行，不会被其他客户端的命令插入。</p><p>Redis 的持久性依赖于其持久化机制（如 RDB 和 AOF），而不是事务本身。</p><h4 id="redis事务满足原子性吗-要怎么改进" tabindex="-1"><a class="header-anchor" href="#redis事务满足原子性吗-要怎么改进"><span>Redis事务满足原子性吗？要怎么改进？</span></a></h4><p>不满足，Redis 事务不支持回滚，一旦 EXEC 命令被调用，所有命令都会被执行，即使有些命令可能执行失败。</p><p>可以通过 Lua 脚本来实现事务的原子性，Lua 脚本在 Redis 中是原子执行的，执行过程中间不会插入其他命令。</p><h3 id="_46-有-lua-脚本操作-redis-的经验吗" tabindex="-1"><a class="header-anchor" href="#_46-有-lua-脚本操作-redis-的经验吗"><span>46.有 Lua 脚本操作 Redis 的经验吗？</span></a></h3><blockquote><p><strong>Lua</strong> 是一种轻量级、可扩展的脚本语言，常被嵌入到其他程序中（例如 Redis、Nginx、游戏引擎等），用来进行灵活的逻辑控制。</p></blockquote><p>Redis的事务功能⽐较简单，平时的开发中，可以利⽤Lua脚本来增强Redis的命令。</p><p>Lua脚本能给开发⼈员带来这些好处：</p><ul><li><p>Lua脚本在Redis中是原⼦执⾏的，执⾏过程中间不会插⼊其他命令。</p></li><li><p>Lua脚本可以帮助开发和运维⼈员创造出⾃⼰定制的命令，并可以将这些命令常驻在Redis内存中，实现复⽤的效果。</p></li><li><p>Lua脚本可以将多条命令⼀次性打包，有效地减少⽹络开销。</p></li></ul><p>⽐如这⼀段很（烂）经（⼤）典（街）的秒杀系统利⽤lua扣减Redis库存的脚本：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">--</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> 库存未预热</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">redis</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">call</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;exists&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">KEYS</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">])</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> ==</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) then</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> -</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">9</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">end</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">--</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> 秒杀商品库存存在</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">redis</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">call</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;exists&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">KEYS</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">])</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> ==</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) then</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    local stock </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> tonumber</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">redis</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">call</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;get&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">KEYS</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">])</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    local num </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> tonumber</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">ARGV</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">[</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">])</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    --</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> 剩余库存少于请求数量</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (stock </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> num) then</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> -</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">3</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    end</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    --</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> 扣减库存</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (stock </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> num) then</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        redis</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">call</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;incrby&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">KEYS</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">], </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> -</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> num);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        --</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> 扣减成功</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    end</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> -</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">end</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">--</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> 秒杀商品库存不存在</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">return</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> -</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_47-redis-的管道pipeline了解吗" tabindex="-1"><a class="header-anchor" href="#_47-redis-的管道pipeline了解吗"><span>47.Redis 的管道Pipeline了解吗？</span></a></h3><p>Redis 提供三种将客户端多条命令**打包发送给服务端执⾏**的⽅式：</p><p>Pipelining(管道) 、 Transactions(事务) 和 Lua Scripts(Lua 脚本) 。</p><blockquote><p>Pipelining（管道）</p></blockquote><p>Pipeline 是 Redis 提供的一种优化手段，允许客户端一次性向服务器发送多个命令，而不必等待每个命令的响应，从而减少网络延迟。它的工作原理类似于批量操作，即多个命令一次性打包发送，Redis 服务器依次执行后再将结果一次性返回给客户端。</p><p>通常在 Redis 中，每个请求都会遵循以下流程：</p><ol><li>客户端发送命令到服务器。</li><li>服务器执行命令并将结果返回给客户端。</li><li>客户端接收返回结果。</li></ol><p>每一个请求和响应之间存在一次网络通信的往返时间（RTT，Round-Trip Time），如果大量请求依次发送，网络延迟会显著增加请求的总执行时间。</p><p>有了 Pipeline 后，流程变为：</p><blockquote><p>发送命令1、命令2、命令3…… -&gt; 服务器处理 -&gt; 一次性返回所有结果。</p></blockquote><p>例如，批量写入大量数据或执行一系列查询时，可以将这些操作打包通过 Pipeline 执行。</p><figure><img src="/blog/assets/img/redis-38aee4c1-efd2-495e-8a6d-164d21a129b1.8d0dba64.png" alt="Pipelining示意图" tabindex="0" loading="lazy"><figcaption>Pipelining示意图</figcaption></figure><p>在 Pipeline 模式下，客户端不会在每条命令发送后立即等待 Redis 的响应，而是将多个命令依次写入 TCP 缓冲区，所有命令一起发送到 Redis 服务器。</p><p>Redis 服务器接收到批量命令后，依次执行每个命令。</p><p>Redis 服务器执行完所有命令后，将每条命令的结果一次性打包通过 TCP 返回给客户端。</p><p>客户端一次性接收所有返回结果，并解析每个命令的执行结果。</p><p>在性能⽅⾯， Pipelining 有下⾯两个优势：</p><ul><li><p>节省了RTT：将多条命令打包⼀次性发送给服务端，减少了客户端与服务端之间的⽹络调⽤次数</p></li><li><p>减少了上下⽂切换：当客户端/服务端需要从⽹络中读写数据时，都会产⽣⼀次系统调⽤，系统调⽤是⾮常耗时的操作，其中设计到程序由⽤户态切换到内核态，再从内核态切换回⽤户态的过程。 当我们执⾏ 10 条 redis 命令的时候，就会发⽣ 10 次⽤户态到内核态的上下⽂切换，但如果我们 使⽤ Pipeining 将多条命令打包成⼀条⼀次性发送给服务端，就只会产⽣⼀次上下⽂切换。</p></li></ul><h3 id="_48-redis-实现分布式锁了解吗" tabindex="-1"><a class="header-anchor" href="#_48-redis-实现分布式锁了解吗"><span>48.Redis 实现分布式锁了解吗？</span></a></h3><blockquote><p>分布式锁是一种用于控制多个不同进程在分布式系统中访问共享资源的锁机制。</p></blockquote><p>它确保在同一时刻，只有一个节点可以对资源进行访问，从而避免并发问题。</p><p><strong>可以使用 Redis 的 SET 命令实现分布式锁</strong>。同时添加过期时间，以防止死锁的发生。</p><figure><img src="/blog/assets/img/redis-710cdd19-98ea-4e96-b579-ff1ebb0d5de9.19cb312c.png" alt="set原子命令" tabindex="0" loading="lazy"><figcaption>set原子命令</figcaption></figure><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>SET key value NX PX 30000</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li><code>key</code> 是锁名。</li><li><code>value</code> 是锁的持有者标识，可以使用 UUID 作为 value。</li><li><code>NX</code> 只在 key 不存在时才创建（避免覆盖锁）。</li><li><code>PX 30000</code>：设置锁的过期时间为 30 秒（防止死锁）。</li></ul><p>用 Java 来实现就是：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> lockKey </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;lock:order:123&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> uniqueId </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> UUID</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">randomUUID</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">().</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">toString</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">boolean</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> isLocked </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> redisTemplate</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">opsForValue</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    .</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">setIfAbsent</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(lockKey, uniqueId, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">10</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">TimeUnit</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">SECONDS</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (isLocked) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    try</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 执行业务逻辑</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    } </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">finally</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 释放锁</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="什么是-setnx" tabindex="-1"><a class="header-anchor" href="#什么是-setnx"><span>什么是 setnx？</span></a></h4><p><strong>setnx 从 Redis 版本 2.6.12 开始被弃用，因为可以通过 set 命令的 NX 选项来实现相同的功能。</strong></p><figure><img src="/blog/assets/img/redis-20241122182250.2f5698cd.png" alt="截图来自Redis docs" tabindex="0" loading="lazy"><figcaption>截图来自Redis docs</figcaption></figure><p>使用 setnx 创建分布式锁时，虽然设置过期时间可以避免死锁问题，但可能存在这样的问题：</p><p>线程 A 获取锁后开始任务，如果任务执行时间超过锁的过期时间，锁会提前释放，导致线程 B 也获取了锁并开始执行任务。这会破坏锁的独占性，导致并发访问资源，进而造成数据不一致。</p><figure><img src="/blog/assets/img/redis-20241122191044.2eac0825.png" alt="：Redis 锁" tabindex="0" loading="lazy"><figcaption>：Redis 锁</figcaption></figure><p>可以引入锁的自动续约机制，在任务执行过程中定期续期，确保锁在任务完成之前不会过期。</p><figure><img src="/blog/assets/img/redis-20241122192038.70c4afa0.png" alt="：redisson 看门狗" tabindex="0" loading="lazy"><figcaption>：redisson 看门狗</figcaption></figure><p>比如说 Redisson 的 RedissonLock 就支持自动续期，通过看门狗机制定期续期锁的有效期。</p><figure><img src="/blog/assets/img/redis-20241122192708.4336b8ec.png" alt="Java 进阶之路：renewExpirationAsync" tabindex="0" loading="lazy"><figcaption>Java 进阶之路：renewExpirationAsync</figcaption></figure><h4 id="redisson-了解吗" tabindex="-1"><a class="header-anchor" href="#redisson-了解吗"><span>Redisson 了解吗？</span></a></h4><p>开发中，我们可以使用专业的轮子——<a href="https://xie.infoq.cn/article/d8e897f768eb1a358a0fd6300" target="_blank" rel="noopener noreferrer">Redisson</a>。</p><figure><img src="/blog/assets/img/redis-20240308174708.f7a31229.png" alt="图片来源于网络" tabindex="0" loading="lazy"><figcaption>图片来源于网络</figcaption></figure><p>Redisson 是一个基于 Redis 的 Java 驻内存数据网格，提供了一系列 API 用来操作 Redis，其中最常用的功能就是分布式锁。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">RLock</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> lock </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> redisson</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getLock</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;lock&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">lock</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">lock</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">try</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // do something</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">} </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">finally</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">    lock</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">unlock</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实现源码在 RedissonLock 类中，通过 Lua 脚本封装 Redis 命令来实现，比如说 tryLockInnerAsync 源码：</p><figure><img src="/blog/assets/img/redis-20240425120229.73973c7a.png" alt=" Java 进阶之路：RedissonLock" tabindex="0" loading="lazy"><figcaption> Java 进阶之路：RedissonLock</figcaption></figure><p>其中 hincrby 命令用于对哈希表中的字段值执行自增操作，pexpire 命令用于设置键的过期时间。</p><h4 id="pmhub-系统里面的分布式锁是怎么做的" tabindex="-1"><a class="header-anchor" href="#pmhub-系统里面的分布式锁是怎么做的"><span>PmHub 系统里面的分布式锁是怎么做的？</span></a></h4><p>主要通过 Redisson 框架实现的 RedLock 来完成的。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 创建 Redisson 客户端配置</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Config</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> config </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> Config</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">config</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">useClusterServers</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        .</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">addNodeAddress</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;redis://127.0.0.1:6379&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">                &quot;redis://127.0.0.1:6380&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">                &quot;redis://127.0.0.1:6381&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 假设有三个 Redis 节点</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 创建 Redisson 客户端实例</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">RedissonClient</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> redissonClient </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> Redisson</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">create</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(config);</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 创建 RedLock 对象</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">RLock</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> redLock </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> redissonClient</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getLock</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;lock_key&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">try</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 尝试获取分布式锁，最多尝试 5 秒获取锁，并且锁的有效期为 5000 毫秒</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    boolean</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> lockAcquired </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> redLock</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">tryLock</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">5</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">5000</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">TimeUnit</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">MILLISECONDS</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (lockAcquired) {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 加锁成功，执行业务代码...</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    } </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">else</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;Failed to acquire the lock!&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">} </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">catch</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">InterruptedException</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> e</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">    Thread</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">currentThread</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">().</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">interrupt</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">    System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">err</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;Interrupted while acquiring the lock&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">} </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">finally</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 无论是否成功获取到锁，在业务逻辑结束后都要释放锁</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">redLock</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">isLocked</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        redLock</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">unlock</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 关闭 Redisson 客户端连接</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">    redissonClient</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">shutdown</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="你提到了redlock-那它机制是怎么样的" tabindex="-1"><a class="header-anchor" href="#你提到了redlock-那它机制是怎么样的"><span>你提到了Redlock，那它机制是怎么样的？</span></a></h4><p>Redlock 是 Redis 作者提出的一种分布式锁实现方案，用于确保在分布式环境下安全可靠地获取锁。它的目标是在分布式系统中提供一种高可用、高容错的锁机制，确保在同一时刻，只有一个客户端能够成功获得锁，从而实现对共享资源的互斥访问。</p><p>Redisson 中的 RedLock 是基于 RedissonMultiLock（联锁）实现的。</p><figure><img src="/blog/assets/img/redis-20240816113330.18312755.png" alt=" Java 进阶之路：RedissonRedLock" tabindex="0" loading="lazy"><figcaption> Java 进阶之路：RedissonRedLock</figcaption></figure><p>RedissonMultiLock 的 tryLock 方法会在指定的 Redis 实例上逐一尝试获取锁。</p><p>在获取锁的过程中，Redlock 会根据配置的 waitTime（最大等待时间）和 leaseTime（锁的持有时间）进行灵活控制。比如，如果获取锁的时间小于锁的有效期（通过TTL命令获取锁的剩余时间），则表示获取锁成功。</p><p>通常，至少需要多数（如 5 个实例中的 3 个）实例成功获取锁，才能认为整个锁获取成功。</p><p>如果指定了锁的持有时间（leaseTime），在成功获取锁后，Redlock 会为锁进行续期，以防止锁在操作完成之前意外失效。</p><h4 id="红锁能不能保证百分百上锁" tabindex="-1"><a class="header-anchor" href="#红锁能不能保证百分百上锁"><span>红锁能不能保证百分百上锁？</span></a></h4><p>Redlock 不能保证百分百上锁，因为在分布式系统中，网络延迟、时钟漂移、Redis 实例宕机等因素都可能导致锁的获取失败。</p><h4 id="加分布式锁时redis如何保证不会发生冲突" tabindex="-1"><a class="header-anchor" href="#加分布式锁时redis如何保证不会发生冲突"><span>加分布式锁时Redis如何保证不会发生冲突？</span></a></h4><p>①、使用 SET NX PX 或 SETNX 命令确保锁的获取是一个原子操作，同时设置锁的过期时间防止死锁。</p><p>比如说 <code>SET lock_key unique_value NX PX 5000</code> 命令，其中 <code>NX</code> 确保了原子操作，，如果 lock_key 已存在，SET 操作会返回 nil；<code>PX 5000</code> 设置过期时间为 5000 毫秒，避免死锁。</p><p>②、使用 Lua 脚本将锁的检查和释放操作封装为一个原子操作，确保安全地释放锁。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>EVAL &quot;if redis.call(&#39;get&#39;, KEYS[1]) == ARGV[1] then return redis.call(&#39;del&#39;, KEYS[1]) else return 0 end&quot; 1 lock_key unique_value</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>③、使用 Redlock 算法确保锁的正确获取和释放。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">RLock</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> lock </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> redisson</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getLock</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;lock_key&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">try</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 500ms 等待时间，10000ms 锁过期时间</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    boolean</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> isLocked </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> lock</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">tryLock</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">500</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">10000</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">TimeUnit</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">MILLISECONDS</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (isLocked) {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 执行需要同步的操作</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">} </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">finally</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">    lock</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">unlock</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="redisson-中的看门狗机制了解吗" tabindex="-1"><a class="header-anchor" href="#redisson-中的看门狗机制了解吗"><span>Redisson 中的看门狗机制了解吗？</span></a></h4><p>Redisson 提供的分布式锁是支持锁自动续期的，也就是说，如果线程在锁到期之前还没有执行完，那么 Redisson 会自动给锁续期。</p><figure><img src="/blog/assets/img/redis-20240918110433.00c61eb1.png" alt="郭慕荣博客园：看门狗" tabindex="0" loading="lazy"><figcaption>郭慕荣博客园：看门狗</figcaption></figure><p>这被称为“看门狗”机制。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> RedissonWatchdogExample</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> main</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[] </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">args</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 配置 Redisson 客户端</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        Config</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> config</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> Config</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        config</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">useSingleServer</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">().</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">setAddress</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;redis://127.0.0.1:6379&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        RedissonClient</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> redisson</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> Redisson</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">create</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(config);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 获取锁对象</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        RLock</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> lock</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> redisson</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getLock</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;myLock&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        try</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">            // 获取锁，默认看门狗机制会启动</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">            lock</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">lock</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">            // 模拟任务执行</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">            System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;Task is running...&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">            Thread</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">sleep</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">40000</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">); </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 模拟长时间任务（40秒）</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">            System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;Task completed.&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        } </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">catch</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">InterruptedException</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> e</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">            e</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">printStackTrace</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        } </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">finally</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">            // 释放锁</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">            lock</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">unlock</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 关闭 Redisson 客户端</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        redisson</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">shutdown</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>看门狗启动后，每隔 10 秒会刷新锁的过期时间，将其延长到 30 秒，确保在锁持有期间不会因为过期而释放。</p><p>当任务执行完成时，客户端调用 <code>unlock()</code> 方法释放锁，看门狗也随之停止。</p><h4 id="检查锁的过程是原子操作吗" tabindex="-1"><a class="header-anchor" href="#检查锁的过程是原子操作吗"><span>检查锁的过程是原子操作吗？</span></a></h4><p>在 Redis 的看门狗机制中，检查锁的过程并不是单独的一个步骤，而是与锁的续期操作绑定在一起，通过 Lua 脚本完成的。因此，检查与续期是一个整体的原子操作，以确保只有持有锁的客户端才能成功续期。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">if</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> redis</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">call</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;get&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">KEYS</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">])</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> ==</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> ARGV</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">[</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">] then</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> redis</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">call</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;expire&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">KEYS</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">], </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">ARGV</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">])</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">else</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">end</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="底层结构" tabindex="-1"><a class="header-anchor" href="#底层结构"><span>底层结构</span></a></h2><p>这一部分就比较深了，如果不是简历上写了精通 Redis，应该不会怎么问。</p><h3 id="_49-说说-redis-底层数据结构" tabindex="-1"><a class="header-anchor" href="#_49-说说-redis-底层数据结构"><span>49.说说 Redis 底层数据结构？</span></a></h3><p>Redis 的底层数据结构有<strong>动态字符串(sds)</strong>、<strong>链表(list)</strong>、<strong>字典(ht)</strong>、<strong>跳跃表(skiplist)</strong>、<strong>整数集合(intset)</strong>、<strong>压缩列表(ziplist)</strong> 等。</p><figure><img src="/blog/assets/img/redis-a1b2d2f9-6895-4749-9bda-9314f08bca68.a8928379.png" alt="Redis Object对应的映射" tabindex="0" loading="lazy"><figcaption>Redis Object对应的映射</figcaption></figure><p>比如说 string 是通过 SDS 实现的，list 是通过链表实现的，hash 是通过字典实现的，set 是通过字典实现的，zset 是通过跳跃表实现的。</p><figure><img src="/blog/assets/img/redis-7cf91aa9-8db5-4abe-803e-a9e8f3bcb9e4.1efe928e.png" alt="类型-编码-结构" tabindex="0" loading="lazy"><figcaption>类型-编码-结构</figcaption></figure><h4 id="简单介绍下-sds" tabindex="-1"><a class="header-anchor" href="#简单介绍下-sds"><span>简单介绍下 SDS？</span></a></h4><p>Redis 是通过 C 语言实现的，但 Redis 并没有直接使用 C 语言的字符串，而是自己实现了一种叫做动态字符串 SDS 的类型。</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">struct</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> sdshdr {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> len;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // buf 中已使用的长度</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> free;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // buf 中未使用的长度</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    char</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> buf</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">[]</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 数据空间</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">};</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>因为 C 语⾔的字符串不记录⾃身的⻓度信息，当需要获取字符串⻓度时，需要遍历整个字符串，时间复杂度为 O(N)。</p><p>⽽ SDS 保存了⻓度信息，这样就将获取字符串⻓度的时间由 O(N) 降低到了 O(1)。</p><figure><img src="/blog/assets/img/redis-7c038f2c-b5ee-4229-9449-713fab3b1855.1f0b1087.png" alt="SDS" tabindex="0" loading="lazy"><figcaption>SDS</figcaption></figure><h4 id="简单介绍下链表-linkedlist" tabindex="-1"><a class="header-anchor" href="#简单介绍下链表-linkedlist"><span>简单介绍下链表 linkedlist</span></a></h4><p>Redis 的链表是⼀个双向⽆环链表结构，和 Java 中的 <a href="https://javabetter.cn/collection/linkedlist.html" target="_blank" rel="noopener noreferrer">LinkedList</a> 类似。</p><p>链表的节点由⼀个叫做 listNode 的结构来表示，每个节点都有指向其前置节点和后置节点的指针，同时头节点的前置和尾节点的后置均指向 null。</p><figure><img src="/blog/assets/img/redis-1adef9c0-8feb-4836-8997-84bda96e2498.15af01ef.png" alt="链表linkedlist" tabindex="0" loading="lazy"><figcaption>链表linkedlist</figcaption></figure><h4 id="简单介绍下字典-dict" tabindex="-1"><a class="header-anchor" href="#简单介绍下字典-dict"><span>简单介绍下字典 dict</span></a></h4><p>⽤于保存键值对的抽象数据结构。Redis 使⽤ hash 表作为底层实现，一个哈希表里可以有多个哈希表节点，而每个哈希表节点就保存了字典里中的一个键值对。</p><p>每个字典带有两个 hash 表，供平时使⽤和 rehash 时使⽤，hash 表使⽤链地址法来解决键冲突，被分配到同⼀个索引位置的多个键值对会形成⼀个单向链表，在对 hash 表进⾏扩容或者缩容的时候，为了服务的可⽤性，rehash 的过程不是⼀次性完成的，⽽是渐进式的。</p><figure><img src="/blog/assets/img/redis-9934b4a2-c253-4d42-acf4-c6c940840779.edfc277b.png" alt="字典" tabindex="0" loading="lazy"><figcaption>字典</figcaption></figure><h4 id="简单介绍下跳表-skiplist" tabindex="-1"><a class="header-anchor" href="#简单介绍下跳表-skiplist"><span>简单介绍下跳表 skiplist</span></a></h4><p>推荐阅读：<a href="https://www.jianshu.com/p/9d8296562806" target="_blank" rel="noopener noreferrer">全网最详细的跳表文章</a></p><p>跳表是有序集合 Zset 的底层实现之⼀。在 Redis 7.0 之前，如果有序集合的元素个数小于 128 个，并且每个元素的值小于 64 字节时，Redis 会使用压缩列表作为 Zset 的底层实现，否则会使用跳表；在 Redis 7.0 之后，压缩列表已经废弃，交由 listpack 来替代。</p><figure><img src="/blog/assets/img/redis-886ee2a8-fb02-4908-bbba-d4ad2a211094.18bb716f.png" alt="跳表" tabindex="0" loading="lazy"><figcaption>跳表</figcaption></figure><p>跳表由 zskiplist 和 zskiplistNode 组成，zskiplist ⽤于保存跳表的基本信息（表头、表尾、⻓度、层高等）。</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">typedef</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> struct</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> zskiplist {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    struct</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> zskiplistNode </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">header, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">tail;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    unsigned</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> long</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> length;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> level;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">} zskiplist;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>zskiplistNode ⽤于表示跳表节点，每个跳表节点的层⾼是不固定的，每个节点都有⼀个指向保存了当前节点的分值和成员对象的指针。</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">typedef</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> struct</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> zskiplistNode {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    sds ele;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    double</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> score;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    struct</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> zskiplistNode </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">backward;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    struct</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> zskiplistLevel {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        struct</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> zskiplistNode </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">forward;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        unsigned</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> span;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    } level</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">[]</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">} zskiplistNode;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="简单介绍下整数集合-intset" tabindex="-1"><a class="header-anchor" href="#简单介绍下整数集合-intset"><span>简单介绍下整数集合 intset</span></a></h4><p>⽤于保存整数值的集合抽象数据结构，不会出现重复元素，底层实现为数组。</p><figure><img src="/blog/assets/img/redis-833dbfb2-7c79-4e7b-a143-8a4a2936cdd8.acf733cc.png" alt="整数集合intset" tabindex="0" loading="lazy"><figcaption>整数集合intset</figcaption></figure><h4 id="简单介绍下压缩列表-ziplist" tabindex="-1"><a class="header-anchor" href="#简单介绍下压缩列表-ziplist"><span>简单介绍下压缩列表 ziplist</span></a></h4><p>压缩列表是为节约内存⽽开发的顺序性数据结构，它可以包含任意多个节点，每个节点可以保存⼀个字节数组或者整数值。</p><figure><img src="/blog/assets/img/redis-99bcbe82-1d91-41bf-8900-a240856071f5.da31d0ea.png" alt="压缩列表组成" tabindex="0" loading="lazy"><figcaption>压缩列表组成</figcaption></figure><h4 id="简单介绍下紧凑列表-listpack" tabindex="-1"><a class="header-anchor" href="#简单介绍下紧凑列表-listpack"><span>简单介绍下紧凑列表 listpack</span></a></h4><p>listpack 是 Redis 用来替代压缩列表（ziplist）的一种内存更加紧凑的数据结构。</p><figure><img src="/blog/assets/img/redis-20240403105313.4286ebda.png" alt="极客时间：listpack" tabindex="0" loading="lazy"><figcaption>极客时间：listpack</figcaption></figure><p>为了避免 ziplist 引起的连锁更新问题，listpack 中的元素不再像 ziplist 那样，保存其前一个元素的长度，而是保存当前元素的编码类型、数据，以及编码类型和数据的长度。</p><figure><img src="/blog/assets/img/redis-20240403105754.5fde6b37.png" alt="极客时间：listpack 的元素" tabindex="0" loading="lazy"><figcaption>极客时间：listpack 的元素</figcaption></figure><p>listpack 每个元素项不再保存上一个元素的长度，而是优化元素内字段的顺序，来保证既可以从前也可以向后遍历。</p><p>但因为 List/Hash/Set/ZSet 都严重依赖 ziplist，所以这个替换之路很漫长。</p><blockquote><ol><li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html" target="_blank" rel="noopener noreferrer">Java 面试指南（付费）</a>收录的字节跳动商业化一面的原题：说说 Redis 的 zset，什么是跳表，插入一个节点要构建几层索引</li><li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html" target="_blank" rel="noopener noreferrer">Java 面试指南（付费）</a>收录的字节跳动面经同学 9 飞书后端技术一面面试原题：Redis 的数据类型，ZSet 的实现</li><li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html" target="_blank" rel="noopener noreferrer">Java 面试指南（付费）</a>收录的小米暑期实习同学 E 一面面试原题：你知道 Redis 的 zset 底层实现吗</li><li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html" target="_blank" rel="noopener noreferrer">Java 面试指南（付费）</a>收录的腾讯面经同学 23 QQ 后台技术一面面试原题：zset 的底层原理</li><li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html" target="_blank" rel="noopener noreferrer">Java 面试指南（付费）</a>收录的快手面经同学 7 Java 后端技术一面面试原题：说一下 ZSet 底层结构</li><li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html" target="_blank" rel="noopener noreferrer">Java 面试指南（付费）</a>收录的美团同学 9 一面面试原题：redis的数据结构底层原理？</li><li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html" target="_blank" rel="noopener noreferrer">Java 面试指南（付费）</a>收录的腾讯面经同学 27 云后台技术一面面试原题：Zset的底层实现？</li><li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html" target="_blank" rel="noopener noreferrer">Java 面试指南（付费）</a>收录的得物面经同学 9 面试题目原题：Zset的底层如何实现？</li></ol></blockquote><h3 id="_50-redis-的-sds-和-c-中字符串相比有什么优势" tabindex="-1"><a class="header-anchor" href="#_50-redis-的-sds-和-c-中字符串相比有什么优势"><span>50.Redis 的 SDS 和 C 中字符串相比有什么优势？</span></a></h3><p>C 语言使用了一个长度为 <code>N+1</code> 的字符数组来表示长度为 <code>N</code> 的字符串，并且字符数组最后一个元素总是 <code>\0</code>，这种简单的字符串表示方式 不符合 Redis 对字符串在安全性、效率以及功能方面的要求。</p><figure><img src="/blog/assets/img/redis-2541fd26-4e84-467d-8d8c-c731154a85d7.0ac4f28d.png" alt="C语言的字符串" tabindex="0" loading="lazy"><figcaption>C语言的字符串</figcaption></figure><h4 id="c-语言的字符串可能有什么问题" tabindex="-1"><a class="header-anchor" href="#c-语言的字符串可能有什么问题"><span>C 语言的字符串可能有什么问题？</span></a></h4><p>这样简单的数据结构可能会造成以下一些问题：</p><ul><li><strong>获取字符串长度复杂度高</strong> ：因为 C 不保存数组的长度，每次都需要遍历一遍整个数组，时间复杂度为 O(n)；</li><li>不能杜绝 <strong>缓冲区溢出/内存泄漏</strong> 的问题 : C 字符串不记录自身长度带来的另外一个问题是容易造成缓存区溢出（buffer overflow），例如在字符串拼接的时候，新的</li><li>C 字符串 <strong>只能保存文本数据</strong> → 因为 C 语言中的字符串必须符合某种编码（比如 ASCII），例如中间出现的 <code>&#39;\0&#39;</code> 可能会被判定为提前结束的字符串而识别不了；</li></ul><h4 id="redis-如何解决-优势" tabindex="-1"><a class="header-anchor" href="#redis-如何解决-优势"><span>Redis 如何解决？优势？</span></a></h4><figure><img src="/blog/assets/img/redis-fc26a4e7-1c8d-4e82-b7f8-1f6b43d16d38.cc26a278.png" alt="Redis sds" tabindex="0" loading="lazy"><figcaption>Redis sds</figcaption></figure><p>简单来说一下 Redis 如何解决的：</p><ol><li><strong>多增加 len 表示当前字符串的长度</strong>：这样就可以直接获取长度了，复杂度 O(1)；</li><li><strong>自动扩展空间</strong>：当 SDS 需要对字符串进行修改时，首先借助于 <code>len</code> 和 <code>alloc</code> 检查空间是否满足修改所需的要求，如果空间不够的话，SDS 会自动扩展空间，避免了像 C 字符串操作中的溢出情况；</li><li><strong>有效降低内存分配次数</strong>：C 字符串在涉及增加或者清除操作时会改变底层数组的大小造成重新分配，SDS 使用了 <strong>空间预分配</strong> 和 <strong>惰性空间释放</strong> 机制，简单理解就是每次在扩展时是成倍的多分配的，在缩容是也是先留着并不正式归还给 OS；</li><li><strong>二进制安全</strong>：C 语言字符串只能保存 <code>ascii</code> 码，对于图片、音频等信息无法保存，SDS 是二进制安全的，写入什么读取就是什么，不做任何过滤和限制；</li></ol><h3 id="_51-字典是如何实现的-rehash-了解吗" tabindex="-1"><a class="header-anchor" href="#_51-字典是如何实现的-rehash-了解吗"><span>51.字典是如何实现的？Rehash 了解吗？</span></a></h3><p>字典是 Redis 服务器中出现最为频繁的复合型数据结构。除了 <strong>hash</strong> 结构的数据会用到字典外，整个 Redis 数据库的所有 <code>key</code> 和 <code>value</code> 也组成了一个 <strong>全局字典</strong>，还有带过期时间的 <code>key</code> 也是一个字典。<em>(存储在 RedisDb 数据结构中)</em></p><h4 id="字典结构是什么样的呢" tabindex="-1"><a class="header-anchor" href="#字典结构是什么样的呢"><span>字典结构是什么样的呢？</span></a></h4><p><strong>Redis</strong> 中的字典相当于 Java 中的 <strong>HashMap</strong>，内部实现也差不多类似，采用哈希与运算计算下标位置；通过 <strong>&quot;数组 + 链表&quot; <strong>的</strong>链地址法</strong> 来解决哈希冲突，同时这样的结构也吸收了两种不同数据结构的优点。</p><figure><img src="/blog/assets/img/redis-e08347a6-efd5-47c0-9adb-23baff82dbbd.1330377a.png" alt="Redis字典结构" tabindex="0" loading="lazy"><figcaption>Redis字典结构</figcaption></figure><h4 id="字典是怎么扩容的" tabindex="-1"><a class="header-anchor" href="#字典是怎么扩容的"><span>字典是怎么扩容的？</span></a></h4><p>字典结构内部包含 <strong>两个 hashtable</strong>，通常情况下只有一个哈希表 <code>ht[0]</code> 有值，在扩容的时候，把 <code>ht[0]</code>里的值 rehash 到 <code>ht[1]</code>，然后进行 <strong>渐进式 rehash</strong> ——所谓渐进式 rehash，指的是这个 rehash 的动作并不是一次性、集中式地完成的，而是分多次、渐进式地完成的。</p><p>待搬迁结束后，<code>h[1]</code>就取代 <code>h[0]</code>存储字典的元素。</p><h3 id="_52-跳表是如何实现的-原理" tabindex="-1"><a class="header-anchor" href="#_52-跳表是如何实现的-原理"><span>52.跳表是如何实现的？原理？</span></a></h3><p>跳表是一种有序的数据结构，它通过在每个节点中维持多个指向其它节点的指针，从而达到快速访问节点的目的。</p><figure><img src="/blog/assets/img/redis-08391728-5ba8-42a0-a287-9284451e0ee7.fb895ed7.png" alt="跳表" tabindex="0" loading="lazy"><figcaption>跳表</figcaption></figure><h4 id="为什么使用跳表" tabindex="-1"><a class="header-anchor" href="#为什么使用跳表"><span>为什么使用跳表？</span></a></h4><p>首先，因为 zset 要支持随机的插入和删除，所以它 <strong>不宜使用数组来实现</strong>，关于排序问题，我们也很容易就想到 <strong>红黑树/ 平衡树</strong> 这样的树形结构，为什么 Redis 不使用这样一些结构呢？</p><ol><li><strong>性能考虑：</strong> 在高并发的情况下，树形结构需要执行一些类似于 rebalance 这样的可能涉及整棵树的操作，相对来说跳跃表的变化只涉及局部；</li><li><strong>实现考虑：</strong> 在复杂度与红黑树相同的情况下，跳跃表实现起来更简单，看起来也更加直观；</li></ol><p>基于以上的一些考虑，Redis 基于 <strong>William Pugh</strong> 的论文做出一些改进后采用了 <strong>跳跃表</strong> 这样的结构。</p><p>本质是解决查找问题。</p><h4 id="跳跃表是怎么实现的" tabindex="-1"><a class="header-anchor" href="#跳跃表是怎么实现的"><span>跳跃表是怎么实现的？</span></a></h4><p>跳跃表的节点里有这些元素：</p><p>①、<strong>层</strong></p><p>跳跃表节点的 level 数组可以包含多个元素，每个元素都包含一个指向其它节点的指针，程序可以通过这些层来加快访问其它节点的速度，一般来说，层的数量月多，访问其它节点的速度就越快。</p><p>每次创建一个新的跳跃表节点的时候，程序都根据幂次定律，随机生成一个介于 1 和 32 之间的值作为 level 数组的大小，这个大小就是层的“高度”</p><p>②、<strong>前进指针</strong></p><p>每个层都有一个指向表尾的前进指针（<code>level[i].forward</code> 属性），用于从表头向表尾方向访问节点。</p><p>我们看一下跳跃表从表头到表尾，遍历所有节点的路径：</p><figure><img src="/blog/assets/img/redis-b153f782-e2e5-4f98-b251-04f06e16c073.ed3db2d4.png" alt="通过前进指针遍历" tabindex="0" loading="lazy"><figcaption>通过前进指针遍历</figcaption></figure><p>③、<strong>跨度</strong></p><p>层的跨度用于记录两个节点之间的距离。跨度是用来计算排位（rank）的：在查找某个节点的过程中，将沿途访问过的所有层的跨度累计起来，得到的结果就是目标节点在跳跃表中的排位。</p><p>例如查找，分值为 3.0、成员对象为 o3 的节点时，沿途经历的层：查找的过程只经过了一个层，并且层的跨度为 3，所以目标节点在跳跃表中的排位为 3。</p><figure><img src="/blog/assets/img/redis-d2395b7e-2f31-4ca8-b06d-2cb47afaeb74.4e59a223.png" alt="计算节点的排位" tabindex="0" loading="lazy"><figcaption>计算节点的排位</figcaption></figure><p>④、<strong>分值和成员</strong></p><p>节点的分值（score 属性）是一个 double 类型的浮点数，跳跃表中所有的节点都按分值从小到大来排序。</p><p>节点的成员对象（obj 属性）是一个指针，它指向一个字符串对象，而字符串对象则保存这一个 SDS 值。</p><h4 id="为什么-hash-表范围查询效率比跳表低" tabindex="-1"><a class="header-anchor" href="#为什么-hash-表范围查询效率比跳表低"><span>为什么 hash 表范围查询效率比跳表低？</span></a></h4><p>哈希表是一种基于键值对的数据结构，主要用于快速查找、插入和删除操作。</p><p>哈希表通过计算键的哈希值来确定值的存储位置，这使得它在单个元素的访问上非常高效，时间复杂度为 O(1)。</p><p>然而，哈希表内的元素是无序的。因此，对于范围查询（如查找所有在某个范围内的元素），哈希表无法直接支持，必须遍历整个表来检查哪些元素满足条件，这使得其在范围查询上的效率低下，时间复杂度为 O(n)。</p><p>跳表是一种有序的数据结构，能够保持元素的排序顺序。</p><p>它通过多层的链表结构实现快速的插入、删除和查找操作，其中每一层都是下一层的一个子集，并且元素在每一层都是有序的。</p><p>当进行范围查询时，跳表可以从最高层开始，快速定位到范围的起始点，然后沿着下一层继续直到找到范围的结束点。这种分层的结构使得跳表在进行范围查询时非常高效，时间复杂度为 O(log n) 加上范围内元素的数量。</p><blockquote><ol><li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html" target="_blank" rel="noopener noreferrer">Java 面试指南（付费）</a>收录的小米暑期实习同学 E 一面面试原题：为什么 hash 表范围查询效率比跳表低</li><li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html" target="_blank" rel="noopener noreferrer">Java 面试指南（付费）</a>收录的腾讯面经同学 23 QQ 后台技术一面面试原题：zset 的底层原理</li><li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html" target="_blank" rel="noopener noreferrer">Java 面试指南（付费）</a>收录的得物面经同学 8 一面面试原题：跳表的结构</li><li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html" target="_blank" rel="noopener noreferrer">Java 面试指南（付费）</a>收录的美团面经同学 4 一面面试原题：Redis 跳表</li><li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html" target="_blank" rel="noopener noreferrer">Java 面试指南（付费）</a>收录的阿里系面经同学 19 饿了么面试原题：跳表了解吗</li></ol></blockquote><h3 id="_53-压缩列表了解吗" tabindex="-1"><a class="header-anchor" href="#_53-压缩列表了解吗"><span>53.压缩列表了解吗？</span></a></h3><p>压缩列表是 Redis <strong>为了节约内存</strong> 而使用的一种数据结构，由一系列特殊编码的连续内存块组成的顺序型数据结构。</p><figure><img src="/blog/assets/img/redis-6be492f7-9f92-4607-a4c4-81a612a3d7bd.bf73f37d.png" alt="压缩列表组成部分" tabindex="0" loading="lazy"><figcaption>压缩列表组成部分</figcaption></figure><p>hash、list、zset 在元素较少时会使用压缩列表。</p><figure><img src="/blog/assets/img/redis-20241225105623.58731351.png" alt="截图来自 Redis 官网" tabindex="0" loading="lazy"><figcaption>截图来自 Redis 官网</figcaption></figure><p>一个压缩列表包含任意多个节点，每个节点可以保存一个字节数组或者一个整数值。</p><figure><img src="/blog/assets/img/redis-b5d224c2-53ee-40a3-9efc-2feb7dd3d7a8.a98ba636.png" alt="压缩列表示例" tabindex="0" loading="lazy"><figcaption>压缩列表示例</figcaption></figure><ul><li><strong>zlbyttes</strong>：记录整个压缩列表占用的内存字节数</li><li><strong>zltail</strong>：记录压缩列表表尾节点距离压缩列表的起始地址有多少字节</li><li><strong>zllen</strong>：记录压缩列表包含的节点数量</li><li><strong>entryX</strong>：列表节点</li><li><strong>zlend</strong>：用于标记压缩列表的末端</li></ul><blockquote><ol><li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html" target="_blank" rel="noopener noreferrer">Java 面试指南（付费）</a>收录的同学 30 腾讯音乐面试原题：什么情况下使用压缩列表</li></ol></blockquote><h3 id="_54-快速列表-quicklist-了解吗" tabindex="-1"><a class="header-anchor" href="#_54-快速列表-quicklist-了解吗"><span>54.快速列表 quicklist 了解吗？</span></a></h3><p>Redis 早期版本存储 list 列表数据结构使用的是压缩列表 ziplist 和普通的双向链表 linkedlist，也就是说当元素少时使用 ziplist，当元素多时用 linkedlist。</p><p>但考虑到链表的附加空间相对较高，<code>prev</code> 和 <code>next</code> 指针就要占去 <code>16</code> 个字节（64 位操作系统占用 <code>8</code> 个字节），另外每个节点的内存都是单独分配，会家具内存的碎片化，影响内存管理效率。</p><p>后来 Redis 新版本（3.2）对列表数据结构进行了改造，使用 <code>quicklist</code> 代替了 <code>ziplist</code> 和 <code>linkedlist</code>，quicklist 是综合考虑了时间效率与空间效率引入的新型数据结构。</p><p>quicklist 由 list 和 ziplist 结合而成，它是一个由 ziplist 充当节点的双向链表。 <img src="/blog/assets/img/redis-3b9785b0-6573-4c2d-8b7d-d5d1be799e26.014152e5.png" alt="quicklist" loading="lazy"></p><p>GitHub 上标星 10000+ 的开源知识库《<a href="https://github.com/itwanger/toBeBetterJavaer" target="_blank" rel="noopener noreferrer"> Java 进阶之路</a>》第一版 PDF 终于来了！包括 Java 基础语法、数组&amp;字符串、OOP、集合框架、Java IO、异常处理、Java 新特性、网络编程、NIO、并发编程、JVM 等等，共计 32 万余字，500+张手绘图，可以说是通俗易懂、风趣幽默……详情戳：<a href="https://javabetter.cn/overview/" target="_blank" rel="noopener noreferrer">太赞了，GitHub 上标星 10000+ 的 Java 教程</a></p><p>微信搜 <strong>隔壁老王</strong> 或扫描下方二维码关注原创公众号隔壁老王，回复 <strong>222</strong> 即可免费领取。</p><figure><img src="/blog/assets/img/gongzhonghao.3d747207.jpeg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="补充" tabindex="-1"><a class="header-anchor" href="#补充"><span>补充</span></a></h2><h3 id="_55-假如-redis-里面有-1-亿个-key-其中有-10w-个-key-是以某个固定的已知的前缀开头的-如何将它们全部找出来" tabindex="-1"><a class="header-anchor" href="#_55-假如-redis-里面有-1-亿个-key-其中有-10w-个-key-是以某个固定的已知的前缀开头的-如何将它们全部找出来"><span>55.假如 Redis 里面有 1 亿个 key，其中有 10w 个 key 是以某个固定的已知的前缀开头的，如何将它们全部找出来？</span></a></h3><p>使用 <code>keys</code> 指令可以扫出指定模式的 key 列表。但是要注意 keys 指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用 <code>scan</code> 指令，<code>scan</code> 指令可以无阻塞的提取出指定模式的 <code>key</code> 列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用 <code>keys</code> 指令长。</p><h3 id="_56-redis-的秒杀场景下扮演了什么角色-补充" tabindex="-1"><a class="header-anchor" href="#_56-redis-的秒杀场景下扮演了什么角色-补充"><span>56.Redis 的秒杀场景下扮演了什么角色？（补充）</span></a></h3><p>秒杀主要是指大量用户集中在短时间内对服务器进行访问，从而导致服务器负载剧增，可能出现系统响应缓慢甚至崩溃的情况。</p><p>针对秒杀的场景来说，最终抢到商品的用户是固定的，也就是说 100 个人和 10000 个人来抢一个商品，最终都只能有 100 个人抢到。</p><p>但是对于秒杀活动的初心来说，肯定是希望参与的用户越多越好，但真正开始下单时，最好能把请求控制在服务器能够承受的范围之内（😂）。</p><figure><img src="/blog/assets/img/redis-20240420102552.361dd08d.png" alt="许令波-秒杀系统的设计" tabindex="0" loading="lazy"><figcaption>许令波-秒杀系统的设计</figcaption></figure><p>解决这一问题的关键就在于错峰削峰和限流。当然了，前端页面的静态化、按钮防抖也能够有效的减轻服务器的压力。</p><ul><li>页面静态化：将商品详情等页面静态化，使用 CDN 分发。</li><li>按钮防抖：避免用户因频繁点击造成的额外请求，比如设定间隔时间后才能再次点击。</li></ul><h4 id="如何实现错峰削峰呢" tabindex="-1"><a class="header-anchor" href="#如何实现错峰削峰呢"><span>如何实现错峰削峰呢？</span></a></h4><p>针对车流量的晚高峰和早高峰，最强有力的办法就是限行，但限行不是无损的，毕竟限行的牌号无法出行。</p><p>无损的方式就是有的车辆早出发，有的车辆晚出发，这样就能够实现错峰出行。</p><p>在秒杀场景下，可以通过以下几种方式实现错峰削峰：</p><p>①、<strong>预热缓存</strong>：提前将热点数据加载到 Redis 缓存中，减少对数据库的访问压力。</p><p>②、<strong>消息队列</strong>：引入消息队列，将请求异步处理，减少瞬时请求压力。消息队列就像一个水库，可以削减上游的洪峰流量。</p><figure><img src="/blog/assets/img/redis-20240420104633.1a4fd12c.png" alt="许令波-排队" tabindex="0" loading="lazy"><figcaption>许令波-排队</figcaption></figure><p>③、<strong>多阶段多时间窗口</strong>：将秒杀活动分为多个阶段，每个阶段设置不同的时间窗口，让用户在不同的时间段内参与秒杀活动。</p><p>④、<strong>插入答题系统</strong>：在秒杀活动中加入答题环节，只有答对题目的用户才能参与秒杀活动，这样可以减少无效请求。</p><figure><img src="/blog/assets/img/redis-20240420104921.dce22806.png" alt="许令波-答题" tabindex="0" loading="lazy"><figcaption>许令波-答题</figcaption></figure><h4 id="如何限流呢" tabindex="-1"><a class="header-anchor" href="#如何限流呢"><span>如何限流呢？</span></a></h4><p>采用令牌桶算法，它就像在帝都买车，摇到号才有资格，没摇到就只能等下一次（😁）。</p><p>在实际开发中，我们需要维护一个容器，按照固定的速率往容器中放令牌（token），当请求到来时，从容器中取出一个令牌，如果容器中没有令牌，则拒绝请求。</p><figure><img src="/blog/assets/img/redis-20240420114025.72f71adf.png" alt="李子捌：令牌桶" tabindex="0" loading="lazy"><figcaption>李子捌：令牌桶</figcaption></figure><p>第一步，使用 Redis 初始化令牌桶：</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">redis-cli</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> SET</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;token_bucket&quot;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;100&quot;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>第二步，使用 Lua 脚本实现令牌桶算法；假设每秒向桶中添加 10 个令牌，但不超过桶的最大容量。</p><div class="language-lua line-numbers-mode" data-highlighter="shiki" data-ext="lua" data-title="lua" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- Lua 脚本来添加令牌，并确保不超过最大容量</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">local</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> bucket</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> = </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">KEYS</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">]</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">local</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> add_count</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> = </span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">tonumber</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">ARGV</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">])</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">local</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> max_tokens</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> = </span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">tonumber</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">ARGV</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">])</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">local</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> current</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> = </span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">tonumber</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">redis</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">call</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;GET&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">bucket</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) or </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">local</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> new_count</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> = </span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">math.min</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">current</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> + </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">add_count</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">max_tokens</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">redis</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">call</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;SET&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">bucket</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">tostring</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">new_count</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">))</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">return</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> new_count</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>第三步，使用 Shell 脚本调用 Lua 脚本：</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">#!/bin/bash</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">while</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> true</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">do</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    redis-cli</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> EVAL</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;$(</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">cat</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> add_tokens.lua)&quot;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> token_bucket</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 10</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 100</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    sleep</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">done</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>第四步，当请求到达时，需要检查并消耗一个令牌。</p><div class="language-lua line-numbers-mode" data-highlighter="shiki" data-ext="lua" data-title="lua" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- Lua 脚本来消耗一个令牌</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">local</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> bucket</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> = </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">KEYS</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">]</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">local</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> tokens</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> = </span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">tonumber</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">redis</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">call</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;GET&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">bucket</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) or </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">if</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> tokens</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &gt; </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> then</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">    redis</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">call</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;DECR&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">bucket</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  -- 成功消耗令牌</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">else</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  -- 令牌不足</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">end</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>调用 Lua 脚本：</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">redis-cli</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> EVAL</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;$(</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">cat</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> consume_token.lua)&quot;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> token_bucket</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><blockquote><ol><li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html" target="_blank" rel="noopener noreferrer">Java 面试指南（付费）</a>收录的农业银行面经同学 3 Java 后端面试原题：秒杀问题（错峰、削峰、前端、流量控制）</li><li><a href="https://javabetter.cn/zhishixingqiu/mianshi.html" target="_blank" rel="noopener noreferrer">Java 面试指南（付费）</a>收录的滴滴面经同学 3 网约车后端开发一面原题：限流算法</li></ol></blockquote><h3 id="_57-客户端宕机后-redis-服务端如何感知到" tabindex="-1"><a class="header-anchor" href="#_57-客户端宕机后-redis-服务端如何感知到"><span>57. 客户端宕机后 Redis 服务端如何感知到？</span></a></h3><p>每个客户端在 Redis 中维护一个特定的键（称为心跳键），用于表示客户端的健康状态。该键具有一个设置的超时时间，例如 10 秒。</p><p>客户端定期（如每 5 秒）更新这个心跳键的超时时间，保持它的存活状态，通常通过 SET 命令重设键的过期时间。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">import</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> redis.clients.jedis.Jedis</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> ClientHeartbeat</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> final</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> String</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> HEARTBEAT_KEY </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;client:heartbeat&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> final</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> EXPIRE_TIME </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 10</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 10秒</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> main</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[] </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">args</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 创建 Redis 连接</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        Jedis</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> jedis</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> Jedis</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;localhost&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 定时更新心跳键</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        while</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">true</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">            try</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                // 设置心跳键并设置过期时间</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">                jedis</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">setex</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(HEARTBEAT_KEY, EXPIRE_TIME, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;alive&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                // 打印心跳日志</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">                System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;Heartbeat sent.&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                // 等待一段时间后再次发送心跳</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">                Thread</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">sleep</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">5000</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">); </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 每5秒发送一次心跳</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">            } </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">catch</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">InterruptedException</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> e</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">                e</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">printStackTrace</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">                break</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">            }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Redis 服务端定期检查这个心跳键。如果发现该键已超时并被 Redis 自动删除，说明客户端可能已宕机。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">import</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> redis.clients.jedis.Jedis</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> ServerMonitor</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> final</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> String</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> HEARTBEAT_KEY </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;client:heartbeat&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> main</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[] </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">args</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 创建 Redis 连接</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        Jedis</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> jedis</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> Jedis</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;localhost&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 定期检查心跳键</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        while</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">true</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">            try</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                // 检查心跳键是否存在</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">                if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">jedis</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">exists</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(HEARTBEAT_KEY)) {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">                    System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;Client is alive.&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">                } </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">else</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">                    System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;Client is down or disconnected.&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">                }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                // 每隔一段时间检查一次</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">                Thread</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">sleep</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">10000</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">); </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 每10秒检查一次</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">            } </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">catch</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">InterruptedException</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> e</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">                e</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">printStackTrace</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">                break</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">            }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></div><!----><footer class="vp-page-meta"><div class="vp-meta-item edit-link"><a class="auto-link external-link vp-meta-label" href="https://github.com/JL-20191210/blog/edit/main/src/Interview/Java/07-Redis面试题/7.Redis面试题A.md" aria-label="在 GitHub 上编辑此页" rel="noopener noreferrer" target="_blank"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="edit icon" name="edit"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></svg><!--]-->在 GitHub 上编辑此页<!----></a></div><div class="vp-meta-item git-info"><!----><!----></div></footer><nav class="vp-page-nav"><a class="route-link auto-link prev" href="/blog/Interview/Java/07-Redis%E9%9D%A2%E8%AF%95%E9%A2%98/7.Redis%E9%9D%A2%E8%AF%95%E9%A2%98.html" aria-label="Redis面试题"><div class="hint"><span class="arrow start"></span>上一页</div><div class="link"><!---->Redis面试题</div></a><a class="route-link auto-link next" href="/blog/Interview/Java/07-Redis%E9%9D%A2%E8%AF%95%E9%A2%98/7.Redis%E9%9D%A2%E8%AF%95%E9%A2%98B.html" aria-label="面渣逆袭-Redis"><div class="hint">下一页<span class="arrow end"></span></div><div class="link">面渣逆袭-Redis<!----></div></a></nav><!----><!----><!--]--></main><!--]--><footer class="vp-footer-wrapper" vp-footer><div class="vp-footer">哟吼~</div><div class="vp-copyright">Copyright © 2025 来杯冰柠檬 </div></footer></div><!--]--><!--[--><!----><!--[--><!--]--><!--]--><!--]--></div>
    <script src="/blog/assets/js/runtime~app.5b07cc97.js" defer></script><script src="/blog/assets/js/12710.15d38a93.js" defer></script><script src="/blog/assets/js/app.f955c049.js" defer></script>
  </body>
</html>
