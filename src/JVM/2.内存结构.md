---
icon: fa-solid fa-microchip
date: 2024-12-17
category:
  - JVM
tag:
  - 总结
# star: true
# sticky: true
---

# JVM 内存结构详解

本文将介绍 Java 虚拟机（JVM）的内存结构，包括程序计数器、虚拟机栈、本地方法栈、堆、方法区等重要内存区域的特点和作用。

## 1. 程序计数器

### 1.1 定义

**程序计数器（Program Counter Register）**：用于记录下一条 JVM 指令的执行地址行号。

**特点：**
- 线程私有
- 不会导致内存溢出
<!-- more -->
### 1.2 作用

- 每个线程都有自己的程序计数器，记录当前线程执行的字节码指令地址，确保线程切换后能恢复到正确的位置。

### 1.3 特点

- 程序计数器是 JVM 中唯一一个线程私有的内存区域。
- 执行 Java 方法时，计数器记录字节码指令的地址；执行 Native 方法时，计数器值为 `undefined`。

### 1.4 内存结构

- 程序计数器是较小的内存区域，通常为机器字长（32 位或 64 位），并且不会导致内存溢出。

### 1.5 线程切换

- 程序计数器在线程切换时起到关键作用，确保线程切换后能够恢复到正确的执行位置。

### 1.6 异常情况

- 程序计数器不会引发 `OutOfMemoryError`，且由于其线程私有，线程切换时不会出现线程安全问题。

---

## 2. 虚拟机栈

### 2.1 定义

虚拟机栈为每个线程分配的内存区域，由多个栈帧组成。每个栈帧对应一次方法调用时所需的内存。

**特点：**
- 栈大小可调整，超出限制会抛出 `StackOverflowError`。
- 栈空间可以动态扩展，但无法收缩。

### 2.2 内存结构

- 虚拟机栈包含多个栈帧，每个栈帧保存当前方法的局部变量表、操作数栈、动态链接、方法出口等信息。

### 2.3 线程切换

- 每个线程有独立的虚拟机栈，确保数据隔离，线程切换时能够正确恢复执行位置。

### 2.4 异常情况

- 可能会发生 `StackOverflowError`，栈空间不足时抛出。
- 由于栈是线程私有的，不会导致线程安全问题。

### 2.5 问题辨析

- **垃圾回收**：虚拟机栈内存不涉及垃圾回收，方法调用结束后栈帧被弹出。
- **栈内存分配**：栈内存过大会支持更多递归调用，但减少可执行线程数。
- **局部变量线程安全性**：局部变量在线程栈内是线程安全的，但如果其作用域超出栈（如被引用到堆），需要考虑线程安全问题。

### 2.6 栈内存溢出

- 栈溢出的原因可能是栈帧过大或栈的深度过深。可以通过调整 `-Xss256k` 参数来设置栈的大小。

### 2.7 线程运行诊断

- **诊断工具**：
  - 使用 `top` 查看 CPU 占用情况。
  - 使用 `ps` 查看哪个线程占用 CPU。
  - 使用 `jstack` 查看线程信息，定位具体线程。

---

## 3. 本地方法栈

![本地方法栈](2.内存结构.assets/图片来自 1_内存结构，第 5 页.png)

### 3.1 作用

本地方法栈用于执行本地方法（由 C、C++ 等编写），通过 Java Native Interface（JNI）与 Java 程序交互，主要用于与底层系统进行交互。

### 3.2 与 Java 虚拟机栈的区别

- 虚拟机栈用于执行 Java 方法，而本地方法栈用于执行本地方法。

### 3.3 栈帧结构

- 本地方法栈的栈帧结构与虚拟机栈类似，但栈帧中包含本地方法的特定信息，如参数和返回值。

### 3.4 栈大小限制

- 本地方法栈通常较小，因为本地方法的调用相对简单。

### 3.5 安全性考虑

- 本地方法栈的安全性需要开发人员注意，因本地方法由本地代码编写，JVM 无法直接控制。

---

## 4. 堆

### 4.1 定义

堆（Heap）是 JVM 中用于存储对象实例的内存区域。所有通过 `new` 关键字创建的对象都会分配到堆内存中。

**特点：**
- 线程共享：所有线程都可以访问堆内存中的对象。
- 垃圾回收：堆内存支持垃圾回收，自动回收不再使用的对象。

### 4.2 堆内存溢出

**堆内存溢出**（Heap OutOfMemoryError）通常发生在堆内存中对象过多，超出了容量限制。可以通过指定堆内存大小（如 `-Xmx8m`）来避免溢出。

**诊断工具：**
- **jps 工具**：查看当前 Java 进程。
- **jmap 工具**：查看堆内存占用情况。
- **jconsole 工具**：图形化监控工具，查看堆内存使用情况。
- **jvisualvm 工具**：提供堆内存分析和性能监控功能。

---

## 5. 方法区

![方法区](2.内存结构.assets/图片来自 1_内存结构，第 8 页-3886814.png)

### 5.1 定义

方法区用于存储类结构信息、运行时常量池、静态变量以及即时编译器编译后的代码等。

### 5.2 特点

- 方法区是线程共享的，存储类的信息、方法、字段、运行时常量池等数据。
- 数据在类加载时存入方法区，是静态数据区域。

### 5.3 内存溢出

方法区内存溢出（OutOfMemoryError）通常发生在加载大量类时，导致空间不足。
- 在 JDK 1.8 之前，方法区被称为**永久代**，可以通过 `-XX:MaxPermSize` 参数调整大小。
- 在 JDK 1.8 之后，方法区被改为**元空间**，通过 `-XX:MaxMetaspaceSize` 参数调整大小。

### 5.4 诊断工具

可以使用 **jmap**、**jconsole**、**jvisualvm** 等工具来监控和诊断方法区内存的使用情况。

### 5.5 常量池

- **定义**：常量池存储编译期生成的字面量和符号引用。
- **特点**：属于方法区的一部分，包含类名、方法名、字段名等符号引用和字面量。

**内存溢出**：常量池内存溢出通常发生在常量过多时。可以通过增加常量池的大小或优化代码来避免溢出。

### 5.6 StringTable

**StringTable** 是 JVM 用来存储字符串常量池的机制，避免重复创建字符串对象。

- 在 JDK 1.6 之前，字符串常量池位于永久代；自 JDK 1.8 起，移至堆内存。

**性能调优**：
- 可通过调整 **HashTable** 的桶数来优化性能，使用 `-XX:StringTableSize` 参数增加桶数量。

**示例代码**：

```java
String str = new String("a") + new String("b");
String st2 = str.intern();  // 将 "ab" 加入常量池
System.out.println(str == st2);  // true
```

---

希望这样的格式和修改能够帮助你更容易理解文章内容。如果有其他改进意见或需要进一步优化，随时告诉我！