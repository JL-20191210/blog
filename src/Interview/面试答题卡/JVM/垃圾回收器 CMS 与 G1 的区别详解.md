---
title: 垃圾回收器 CMS 与 G1 的区别详解
icon: fa-solid fa-recycle
date: 2025-07-13
author: JeanHu
category:
  - JVM
  - GC机制
tag:
  - JVM
  - GC
  - CMS
  - G1
  - 回收器对比
summary: 本文对比分析了 CMS 与 G1 两种垃圾回收器在回收算法、内存布局、STW 行为与适用场景方面的核心差异，帮助开发者在性能调优中合理选型。
---

# ☕ JVM面试答题卡：垃圾回收器 CMS 与 G1 的区别详解

## ✅ 一句话概括

> CMS 是一款低延迟、基于“标记-清除”算法的并发回收器，而 G1 是面向服务端的低延迟垃圾回收器，采用分区式管理、并发标记和“标记-整理”算法，具备更好的吞吐量和更可控的 GC 停顿时间。

------
<!-- more -->
## 🧱 基本原理

| 对比项   | CMS（Concurrent Mark-Sweep）              | G1（Garbage First）                         |
| -------- | ----------------------------------------- | ------------------------------------------- |
| 设计目标 | 低停顿（Low Latency）                     | 高吞吐+可预测低延迟                         |
| 收集区域 | 年轻代 + 老年代（传统 Eden/Survivor/Old） | 全堆划分为多个 Region（包括年轻代和老年代） |
| 算法     | 年轻代为复制算法，老年代为 **标记-清除**  | 年轻代为复制算法，老年代为 **标记-整理**    |
| 并发能力 | 年轻代 STW，老年代可并发标记/清理         | 多阶段并发，支持预测暂停时间                |
| 停顿时间 | 不可预测，取决于对象数量和碎片程度        | 可配置目标停顿时间（如 `MaxGCPauseMillis`） |
| 碎片问题 | 清除后有内存碎片，不可压缩                | 自动整理内存，碎片少                        |
| 失败回退 | CMS 失败后触发 Full GC（单线程 STW）      | G1 内部 Full GC 是并发多线程                |

------

## 📈 CMS 回收流程简图

```
1. 初始标记(STW)
2. 并发标记
3. 预清理（可选）
4. 重新标记(STW)
5. 并发清除
```

------

## 📊 G1 回收流程简图

```
1. 初始标记(STW)
2. 并发标记
3. 最终标记(STW)
4. 筛选回收集(Region)
5. 并发复制/压缩整理
```

------

## 🔍 详细对比分析

| 特性           | CMS                                   | G1                                 |
| -------------- | ------------------------------------- | ---------------------------------- |
| 并发回收       | 支持（老年代）                        | 更强（多个阶段并发）               |
| 内存碎片       | 有，清除后不压缩                      | 无，回收同时整理                   |
| STW 频率和时间 | 较高且不可预测                        | 可配置、可预估                     |
| 内存分区       | 按代划分（年轻代、老年代）            | 分为多个均等 Region，按需角色      |
| 吞吐量         | 中等                                  | 高                                 |
| 适用场景       | 响应敏感型应用，如 Web 服务器         | 大内存场景、长时间运行的服务端应用 |
| 是否即将淘汰   | ✅ 是（JDK 9 之后已标记为 Deprecated） | ✅ 否（G1 是默认 GC，持续优化）     |

------

## 🚨 CMS 的典型问题

- 清除后不整理内存，导致**碎片严重**
- 如果 Full GC 被触发，会退化为单线程 Serial GC，**性能骤降**
- 并发阶段与用户线程同时运行，可能影响吞吐

------

## 🌟 G1 的优势

- **可预测的 GC 停顿时间**
- **自动整理 Region 内存**，无碎片困扰
- 支持 **大堆内存（>4GB）** 场景
- 结合了 CMS 的低停顿优势 + 串行/并行 GC 的效率

------

## ✅ 面试答题参考句

> CMS 是一种“标记-清除”算法的并发垃圾回收器，能减少老年代 GC 的停顿时间，但存在内存碎片问题；G1 则通过将堆划分为多个 Region，实现按需回收、标记-整理，具有更好的吞吐量控制和可预测的停顿时间，是 JDK 默认推荐的 GC 策略。