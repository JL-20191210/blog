# 🐬MySQL 面试答题卡：锁机制详解

------

## 🧠 原则简介

**MySQL 锁机制：**

> MySQL 为了保证数据一致性与并发控制，引入了多种锁机制，主要分为：**全局锁、表级锁、行级锁、记录锁、间隙锁、临键锁、意向锁、元数据锁、乐观锁、悲观锁**等。不同锁的粒度与性能差异显著，适用场景各不相同。

------

## 🔍 MySQL 锁类型详解与示例

------

### 1️⃣ 全局锁（Global Lock）

- **作用**：锁定整个数据库实例，所有表都不能进行写操作。
- **特点**：粒度最大，阻塞性最强，常用于全库逻辑备份。
- **加锁方式**：

```sql
-- 加全局锁（只读模式）
FLUSH TABLES WITH READ LOCK;

-- 解锁
UNLOCK TABLES;
```

- **适用场景**：
  - 全库备份
  - 防止写入导致数据不一致

------

### 2️⃣ 表级锁（Table Lock）

- **作用**：锁定整张表，适合读多写少的场景。
- **特点**：开销小，加锁快，但并发性低。
- **加锁方式**：

```sql
-- 给表加读锁（其他会话可以读，不能写）
LOCK TABLES my_table READ;

-- 给表加写锁（其他会话不能读也不能写）
LOCK TABLES my_table WRITE;

-- 解锁
UNLOCK TABLES;
```

- **适用场景**：
  - MyISAM 存储引擎（默认用表锁）
  - 批量数据导入导出

------

### 3️⃣ 行级锁（Row Lock）

- **作用**：锁定数据表中某一行记录，最小粒度的锁。
- **特点**：并发性能高，但加锁开销大。
- **加锁方式**（InnoDB 存储引擎自动触发）：

```sql
-- X锁 会对满足条件的行加行锁（悲观锁）
SELECT * FROM users WHERE id = 1 FOR UPDATE;

-- S锁 共享锁（读锁）
SELECT * FROM users WHERE id = 1 LOCK IN SHARE MODE;
```

- **适用场景**：
  - 高频并发更新
  - 精确锁定目标行

------

### 4️⃣ 记录锁（Record Lock）

- **作用**：锁定某行记录的索引项。
- **特点**：仅锁定命中的行，避免影响其他数据。
- **示例**：

```sql
-- id 是主键或唯一索引，命中唯一记录
SELECT * FROM users WHERE id = 5 FOR UPDATE;
```

- **注意**：必须走索引，否则会退化为 **表锁**。

------

### 5️⃣ 间隙锁（Gap Lock）

- **作用**：锁定两个索引值之间的“间隙”，防止幻读。
- **特点**：不锁记录本身，只锁区间。
- **示例**：

```sql
-- 锁定 age 在 (20,30) 之间的间隙，不允许插入这个区间的新数据
SELECT * FROM users WHERE age > 20 AND age < 30 FOR UPDATE;
```

- **适用场景**：可重复读（REPEATABLE READ）隔离级别下防止幻读。

> 幻读：刚刚还没有，突然跳出来了

------

### 6️⃣ 临键锁（Next-Key Lock）

- **作用**：记录锁 + 间隙锁的组合，锁定区间并包含记录本身。
- **特点**：InnoDB 在可重复读隔离级别下的默认锁方式。
- **示例**：

```sql
-- 锁定 age=25 的记录，以及 (20,30) 区间的间隙
SELECT * FROM users WHERE age = 25 FOR UPDATE;
```

- **适用场景**：
  - 防止幻读
  - 确保区间数据稳定

------

### 7️⃣ 意向锁（Intention Lock）

- **作用**：表级锁，标记事务打算对某些行加行锁，便于多事务协调。
- **类型**：
  - **IS（Intention Shared）**：打算加共享锁
  - **IX（Intention Exclusive）**：打算加排它锁
- **示例**：

```sql
-- 自动加锁，不需要手动写 SQL
SELECT * FROM users WHERE id = 1 FOR UPDATE; -- 自动加 IX 锁
```

- **适用场景**：避免行锁与表锁冲突，提升加锁效率。

------

### 8️⃣ 元数据锁（Metadata Lock, MDL）

- **作用**：保证表结构读写一致性。
- **特点**：自动触发，不可手动加锁。
- **示例**：

```sql
-- 会话1：执行 DML（会持有 MDL 读锁）
SELECT * FROM users;

-- 会话2：尝试修改表结构，会被阻塞
ALTER TABLE users ADD COLUMN email VARCHAR(255);
```

- **适用场景**：
  - 防止 DDL 与 DML 并发导致数据不一致

------

### 9️⃣ 乐观锁（Optimistic Lock）

- **作用**：通过版本号或时间戳控制并发更新，不阻塞其他事务。
- **特点**：适合冲突概率低的场景。
- **示例**：

```sql
-- 数据表增加版本字段 version
UPDATE users SET name = 'Tom', version = version + 1
WHERE id = 1 AND version = 3;
```

- **适用场景**：
  - 高并发读多写少
  - 不需要数据库级别锁

------

### 🔟 悲观锁（Pessimistic Lock）

- **作用**：认为并发冲突很可能发生，先加锁再操作。
- **特点**：阻塞其他事务对数据的修改。
- **示例**：

```sql
-- 悲观锁
SELECT * FROM users WHERE id = 1 FOR UPDATE;
```

- **适用场景**：
  - 冲突概率高
  - 数据一致性要求严格

------

## 🗣 面试总结句式

> MySQL 锁根据粒度分为全局锁、表级锁、行级锁等；根据功能又有记录锁、间隙锁、临键锁、意向锁、元数据锁；根据策略有乐观锁和悲观锁。不同锁机制在性能与数据安全性之间需要权衡，面试时可以结合业务场景给出合适的选择方案。