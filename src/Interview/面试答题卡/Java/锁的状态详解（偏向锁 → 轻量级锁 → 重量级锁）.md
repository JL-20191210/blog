# ☕ Java 面试答题卡：锁的状态详解（偏向锁 → 轻量级锁 → 重量级锁）

## ✅ 1. 背景：为什么锁有这么多“状态”？

为了**提高并发性能、减少线程切换的开销**，JVM 从 JDK 1.6 开始引入了锁的多种状态：
 **根据竞争情况自动升级（或降级）**，实现从无锁到偏向锁、轻量级锁、重量级锁的渐进控制。

## ✅ 2. 锁状态切换图

```
无锁
 ↓
偏向锁（Bias Lock）       ← 如果另一个线程竞争
 ↓                             ↑
轻量级锁（Lightweight Lock）  ← 自旋失败或激烈竞争
 ↓
重量级锁（Heavyweight Lock）
```



## ✅ 3. 锁状态一览表

| 锁状态   | 是否加锁 | 是否阻塞   | 性能   | 适用场景                   |
| -- | -- | ---- |  | -- |
| 无锁     | 否       | 否         | ✅ 最高 | 单线程、不可共享对象       |
| 偏向锁   | ✅ 加锁   | 否         | ✅ 很高 | 绝大多数时间由同一线程访问 |
| 轻量级锁 | ✅ 加锁   | 否（自旋） | ⚠️ 中等 | 多线程竞争但冲突不频繁     |
| 重量级锁 | ✅ 加锁   | ✅ 阻塞     | ❌ 最差 | 多线程激烈竞争             |

## 🔍 4. 各锁状态详解

### 🔸 4.1 偏向锁（Bias Lock）

#### 📌 定义：

> 偏向于**第一个获取锁的线程**，后续只要是同一个线程再次获得锁，不再执行加锁操作（连 CAS 都不做）。

#### ⚙️ 原理：

- 将持有锁的线程 ID 写入对象头（Mark Word）
- 只要没有其他线程竞争，偏向锁状态不会改变

#### 📈 特点：

- 无线程竞争时性能最优
- 适用于“**线程独占访问**”场景（如单线程操作集合）

#### 🧠 注意：

- 默认 JVM 启动几秒后（4s）才启用偏向锁（通过 `-XX:BiasedLockingStartupDelay=0` 启用立即生效）

### 🔸4.2 轻量级锁（Lightweight Lock）

#### 📌 定义：

> 线程尝试使用 **CAS** 将当前线程的锁记录插入对象头；如果成功，则获得锁；否则进入自旋。

#### ⚙️ 原理：

- 使用线程栈中的锁记录（Lock Record）
- 用 CAS 竞争对象头中的 Mark Word 指针（将其替换为指向 Lock Record 的地址）

#### 📈 特点：

- 避免了线程挂起和恢复的系统调用
- 多线程竞争但冲突短暂场景中性能较好
- 自旋是有限次的（默认 10 次）

#### 🧠 自旋失败后，升级为重量级锁

### 🔸 4.3 重量级锁（Heavyweight Lock）

#### 📌 定义：

> 如果自旋失败，说明竞争激烈，JVM 使用操作系统的 **互斥锁（monitor）** 机制，挂起其他线程。

#### ⚙️ 原理：

- 使用 `ObjectMonitor`（重量级锁结构体）
- 被阻塞的线程挂起（由操作系统管理）
- 只有获得锁的线程才能运行

#### 📉 特点：

- 会触发**用户态到内核态切换**（代价大）
- 阻塞与唤醒有上下文切换，性能差

### 🧠 4.4 用生活类比理解

假设一个房间要被人使用：

- **无锁**：没人要用，谁都可以自由进出；
- **偏向锁**：你一个人频繁使用，门上挂了你的名字，别人不会干扰你；
- **轻量级锁**：你在用，另一个人来了，在门口等你一下（自旋）；
- **重量级锁**：你还没出来，对方等不住了，叫物业来协调（线程挂起、调度）；

## ✅ 5. 如何查看对象当前的锁状态？

可以使用 JDK 的 `jol` 工具（Java Object Layout）：

```java
import org.openjdk.jol.info.ClassLayout;
public class LockTest {
    public static void main(String[] args) throws Exception {
        Object o = new Object();
        System.out.println(ClassLayout.parseInstance(o).toPrintable());
    }
}
```

## ✅ 6. 锁状态切换时机总结

| 起始状态 | 触发条件                   | 切换后状态 |
| -- | -- | ---- |
| 无锁     | synchronized 被调用        | 偏向锁     |
| 偏向锁   | 其他线程尝试竞争同一把锁   | 轻量级锁   |
| 轻量级锁 | 自旋失败（多线程竞争激烈） | 重量级锁   |
| 重量级锁 | 无竞争（有可能回退）       | ❌ 不会降级 |

## ✅ 7. 面试常问问题模板（建议背诵）

> 在 JDK 1.6+ 中，synchronized 实现了多种锁优化机制，锁状态会根据线程竞争情况自动升级。起初是偏向锁（无竞争），如有多个线程尝试锁定，会升级为轻量级锁（自旋），若竞争严重则进一步升级为重量级锁（阻塞）。这种设计既保证了线程安全，又尽量减少了性能开销。

## 🎯 常见面试追问：

### Q1：偏向锁适合什么场景？

- 单线程重复访问某个对象（如迭代集合）

### Q2：轻量级锁为什么比重量级锁快？

- 避免了线程挂起、恢复的系统调用，使用自旋代替阻塞

### Q3：锁状态会降级吗？

- 锁**升级是单向不可逆**的，不会自动降级（避免频繁切换带来性能抖动）