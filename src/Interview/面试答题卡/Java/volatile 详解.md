## ☕ Java 面试答题卡：`volatile` 详解

### ✅ 1. 基本概念

> `volatile` 是 Java 中的一个轻量级同步机制，用于**修饰变量**，确保对该变量的**可见性**与**禁止指令重排序**，但**不保证原子性**。

------

### ✅ 2. 作用说明

| 功能       | 说明                                                         |
| ---------- | ------------------------------------------------------------ |
| 可见性     | 一个线程对 `volatile` 变量的修改，对其他线程立即可见         |
| 禁止重排序 | 避免编译器和 CPU 对代码指令重排，从而防止执行顺序错乱（特别是双检锁 DCL） |
| 非原子性   | 对变量的操作（如 i++）仍然不是原子的，需要借助 `AtomicXXX` 或锁同步 |

------

### ✅ 3. 示例说明

#### 🔹 3.1 可见性保证（没有 volatile）

```java
boolean flag = true;

new Thread(() -> {
    while (flag) {} // 无限循环，主线程的修改不可见
}).start();

Thread.sleep(1000);
flag = false; // 修改对子线程不可见，导致无法退出循环
```

#### 🔹 3.2 加 volatile 修饰

```java
volatile boolean flag = true; // 保证修改立即对其他线程可见
```

------

### ✅ 4. 原理解析

- `volatile` 变量在写操作后，会强制将 **工作内存中的值刷新到主内存**。
- 在读操作前，会强制从 **主内存读取最新的值**。
- 使用了**内存屏障（Memory Barrier）**来实现这两个保证。

------

### ✅ 5. JMM 语义图（Java 内存模型）

```java
线程A             主内存              线程B
  |   写volatile变量 →  主内存 ← 读volatile变量 |
```

------

### ✅ 6. 使用场景（典型）

| 场景                          | 是否适合用 volatile  |
| ----------------------------- | -------------------- |
| 状态标志、开关控制            | ✅ 适合               |
| 双重检查锁（DCL）中的单例实例 | ✅ 适合               |
| 多线程计数器（如 i++）        | ❌ 不适合（需原子性） |
| 复杂条件判断或数据结构共享    | ❌ 不适合             |

------

### ✅ 7. 与 `synchronized` 对比

| 特性       | `volatile`       | `synchronized`              |
| ---------- | ---------------- | --------------------------- |
| 可见性     | ✅                | ✅                           |
| 原子性     | ❌                | ✅                           |
| 重排序禁止 | ✅                | ✅（通过进入和退出 monitor） |
| 性能开销   | 小（无锁）       | 较大（加锁和上下文切换）    |
| 使用复杂性 | 简单（变量声明） | 复杂（代码块或方法）        |

------

### ✅ 8. 注意事项 / 限制

- `volatile` **不能用于原子操作**（如 i++、x = x + 1）
- **数组引用**可用 volatile 修饰，但不能保证数组内部元素可见性
- `volatile` 仅适用于 **状态标志、配置开关等轻量同步场景**
- 不支持复合操作的同步，例如“先读后改再写”

------

### ✅ 9. 双重检查锁（DCL）中的应用

```java
public class Singleton {
    private static volatile Singleton instance;

    public static Singleton getInstance() {
        if (instance == null) {
            synchronized(Singleton.class) {
                if (instance == null) {
                    instance = new Singleton(); // 禁止重排序，确保安全发布
                }
            }
        }
        return instance;
    }
}
```

如果没有 `volatile`，可能出现**指令重排**，导致获取到未完全初始化的对象。

------

### 🎯 一句话总结（面试简答）

> `volatile` 用于保证变量的可见性和禁止指令重排序，适用于状态标志等轻量同步场景，但不保证原子性；复杂并发场景应使用 `synchronized` 或原子类。