# 中电金信

面试官：你先做个自我介绍

> 巴拉巴拉巴拉

面试官：好，我看着你熟悉多线程并发，咱们聊一下线程的生命周期都有哪些？

> **1.线程的生命周期？**
>
> Java 线程的生命周期主要包括 **新建、就绪、运行、等待/阻塞、终止** 五种状态。
>
> - `NEW`：对象创建但未启动。
> - `RUNNABLE`：已启动，等待 CPU 调度。
> - `WAITING/TIMED_WAITING/BLOCKED`：线程等待条件满足或获取锁。
> - `TERMINATED`：线程执行完成或异常退出。

面试官：这里面 start和run它俩有什么区别？

> **2.start和run它俩有什么区别？**
>
> 调用 `start()` 会创建一个新的线程，并异步执行 `run()` 方法中的代码。
>
> 直接调用 `run()` 方法只是一个普通的同步方法调用，所有代码都在当前线程中执行，不会创建新线程。没有新的线程创建，也就达不到多线程并发的目的。

面试官：有了解过线程里面那些sleep，wait，yield方法吗？

> **3.有了解过线程里面那些sleep，wait，yield方法吗？**

面试官：sleep它会释放CPU或释放锁吗？

> 4.sleep会释放CPU吗？
>
> - 当线程 A 调用了 Thread 的 sleep 方法后，线程 A 会暂时让出指定时间的执行权。
>
> - 指定的睡眠时间到了后该方法会正常返回，接着参与 CPU 调度，获取到 CPU 资源后可以继续执行。
>
> 5.sleep会释放锁吗？
>
> - sleep 会让当前线程休眠，不需要获取对象锁，属于 Thread 类的方法；
>
> - wait 会让获得对象锁的线程等待，要提前获得对象锁，属于 Object 类的方法。
>
> 6.yield方法了解吗
>
> - `yield()` 方法的目的是让当前线程让出 CPU 使用权，回到就绪状态。
>
> 7.yield方法和sleep方法有什么区别
>
> **sleep**：让出 CPU，一定暂停，指定时间后恢复；不释放锁。
>
> **yield**：让出 CPU，只是提示，可能马上又被调度回来；不释放锁。

我看看还有JVM，你了解JVM的内存模型吗？

我提醒一下方法区之类的堆这些。

> 7.能说一下 JVM 的内存区域吗？
>
> JVM 的内存区域可以细分为`程序计数器`、`虚拟机栈`、`本地方法栈`、`堆`和`方法区`。

堆里面一般是放什么信息的？

> 8.介绍一下 Java 堆？
>
> 堆是 JVM 中最大的一块内存区域，被所有线程共享，在 JVM 启动时创建，主要用来存储 new 出来的对象。
>
> 由于大多数垃圾收集器采用分代收集理论，Java 堆被划分为新生代和老年代。其中，新生代又进一步细分为 Eden 区和两个 Survivor 区（From Survivor 与 To Survivor）。

方法区域里面一般会存什么信息

> 9.方法区里一般存什么信息？
>
> 方法区并不真实存在，属于 Java 虚拟机规范中的一个逻辑概念，用于存储已被 JVM 加载的类信息、常量、静态变量、即时编译器编译后的代码缓存等。
>
> 在 HotSpot 虚拟机中，方法区的实现称为永久代 PermGen，但在 Java 8 及之后的版本中，已经被元空间 Metaspace 所替代。

了解过双亲委派吗？双亲委派模型有了解

> 10.了解过双亲委派吗？双亲委派模型有了解?
>
> 双亲委派模型要求类加载器在加载类时，先委托父加载器尝试加载，只有父加载器无法加载时，子加载器才会加载。
>
> 这个过程会一直向上递归，也就是说，从子加载器到父加载器，再到更上层的加载器，一直到最顶层的启动类加载器。
>
> 启动类加载器会尝试加载这个类。如果它能够加载这个类，就直接返回；如果它不能加载这个类，就会将加载任务返回给委托它的子加载器。
>
> 子加载器尝试加载这个类。如果子加载器也无法加载这个类，它就会继续向下传递这个加载任务，依此类推。
>
> 直到某个加载器能够加载这个类，或者所有加载器都无法加载这个类，最终抛出 ClassNotFoundException。
>
> 11.为什么要用双亲委派模型？
>
> **①、避免类的重复加载**：父加载器加载的类，子加载器无需重复加载。
>
> **②、保证核心类库的安全性**：如 `java.lang.*` 只能由 Bootstrap ClassLoader 加载，防止被篡改。

有这样一个场景，假如说我在生产环境发现CPU利用率飙高了，这个时候你要怎么定位或排查？

> 12.CPU利用率飙高了怎么定位或者查询？
>
> 1. 首先，使用 top 命令查看 CPU 占用情况，找到占用 CPU 较高的进程 ID。
> 2. 接着，使用 jstack 命令查看对应进程的线程堆栈信息，将所有线程的堆栈信息输出到文件中
> 3. 然后再使用 top 命令查看进程中线程的占用情况，找到占用 CPU 较高的线程 ID。
> 4. 接着在 jstack 的输出中搜索这个十六进制的线程 ID，找到对应的堆栈信息。（注意，top 命令显示的线程 ID 是十进制的，而 jstack 输出的是十六进制的，所以需要将线程 ID 转换为十六进制。）
> 5. 最后，根据堆栈信息定位到具体的业务方法，查看是否有死循环、频繁的垃圾回收、资源竞争导致的上下文频繁切换等问题。

还有一个问题就是我们常说垃圾回收对吧？我们在垃圾回收之前，首先得确认它是不是要回收的垃圾，确认这个对象是不是可回收的方法，我们讲就可达性分析。可达性分析的过程你了解吗？

> 13.可达性分析
>
> 通过一组名为 “GC Roots” 的根对象，进行递归扫描，无法从根对象到达的对象就是“垃圾”，可以被回收。

哪些可以作为你说的这些入口的对象。

> 14.Java 中可作为 GC Roots 的引用有哪几种？
>
> 在 Java 中，GC Roots 包括以下几种：
>
> - 虚拟机栈中的引用（方法的参数、局部变量等）
> - 本地方法栈中 JNI 的引用
> - 类静态变量
> - 运行时常量池中的常量（String 或 Class 类型）

可以是吧？好行，你们的数据库用的是什么？

MySQL

MySQL的你们用的常用的引擎用的是哪一种？

> 15.常用的引擎用的是哪一种?
>
> 用的默认引擎InnoDB

你在项目当中用到了哪些索引？

> 16.用到了哪些索引？
>
> - 主键索引
> - 唯一索引
> - 前缀索引
> - 联合索引
> - 覆盖索引

我就做一个简单的select，去查数据他一定会回表查吗？

> 

不一定，比如说我要是建立了联合索引的话，我用我的select正好我的联合索引覆盖掉了，可以直接就从二级索引里边就直接查到了，就不用再回表了。

说话人4 13:45

回表的话他不是说回表要从二级索引里边获取主键，然后去技术索引里边拿数据，因为技术索引里边是存的是所有表里边所有的数据都在叶子节点上挂着，所以说只要覆盖索引覆盖掉了，或者是普通的索引覆盖了也可以，直接查出来就可以了，就不用再回表了，这也是索引比较快的一个原因。