# 两种缓存重建方案

## 方案 A：消息驱动缓存重建

1. **数据更新数据库**
   - 每条业务数据变更后，首先在数据库中完成状态更新。
2. **发送 MQ 消息**
   - 消息中只携带 **数据主键 ID**，不包含完整对象。
   - 目的是通知缓存服务该数据需要更新。
3. **消费 MQ 重建缓存**
   - 缓存服务消费消息后，根据 ID 从数据库查询最新数据。
   - 将最新数据写入 Redis 缓存。

✅ **优化点**

- 消息只携带 ID，减小 MQ 消息体积，提高吞吐。
- 数据库查询最新状态，保证缓存与 DB 一致性。
- 可以结合 **批量积累** 或 **延迟队列**，减少单条缓存写入压力。

------

## 方案 B：批量缓存更新

1. **积累待更新数据 ID**
   - 每条数据库更新完成后，将 **数据 ID** 放入 **Redis 队列**（List 或 Set）。
   - Redis SET 可用于去重，避免重复写缓存。
2. **批量触发缓存重建**
   - 服务端定时任务（如每 5 秒或每达到 N 条）检查 Redis 队列。
   - 使用 **分布式锁**（如 Redisson）确保多实例同时运行时，只会有一个任务执行批量重建。
3. **批量读取数据库并写缓存**
   - 根据队列中的 ID 批量查询数据库最新数据。
   - 使用 **Redis Pipeline** 批量写缓存，减少网络往返，提高性能。
4. **清理队列**
   - 写入缓存成功后，从队列中删除已处理 ID。
   - 失败的 ID 可重新放回队列，保证最终一致性。

✅ **优化点**

- 批量操作降低 Redis 压力，提高吞吐。
- 分布式锁保证多实例环境下的幂等性。
- 队列去重防止重复写缓存。
- 可以结合阈值触发和定时触发，兼顾延迟和实时性。

------

### **对比与选择**

| 方案                | 优点                              | 适用场景                     |
| ------------------- | --------------------------------- | ---------------------------- |
| MQ 消息驱动         | 实时性高，缓存接近数据库更新      | 数据量中小，延迟要求高       |
| Redis 队列 + 批量写 | 减少 Redis 写入压力，适合高吞吐量 | 大量数据更新，缓存写入压力大 |

------

### **推荐实践**

- **高并发大数据量** → 方案 B（批量重建 + Pipeline + 分布式锁）
- **低并发、对缓存实时性要求高** → 方案 A（MQ 消息驱动）
- **企业项目常用** → 将两者结合：MQ 消息驱动积累待更新 ID，定时批量重建缓存。