# 分布式锁保证缓存重建

```java
import org.redisson.api.RLock;
import org.redisson.api.RedissonClient;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.stereotype.Service;

import java.util.concurrent.TimeUnit;

@Service
public class DemandCacheService {

    @Autowired
    private StringRedisTemplate redisTemplate;

    @Autowired
    private RedissonClient redissonClient;

    @Autowired
    private DemandRepository demandRepository;

    private static final String CACHE_KEY_PREFIX = "demand:";
    private static final String LOCK_KEY_PREFIX = "lock:demand:";

    public Demand getDemandById(Long demandId) {
        String cacheKey = CACHE_KEY_PREFIX + demandId;
        String lockKey = LOCK_KEY_PREFIX + demandId;

        // 1. 先查缓存
        String demandJson = redisTemplate.opsForValue().get(cacheKey);
        if (demandJson != null) {
            return JsonUtils.fromJson(demandJson, Demand.class);
        }

        // 2. 缓存未命中 → 尝试获取分布式锁
        RLock lock = redissonClient.getLock(lockKey);
        try {
            // tryLock(waitTime, leaseTime, unit)
            // waitTime = 最多等待1秒, leaseTime = 10秒后自动释放
            if (lock.tryLock(1, 10, TimeUnit.SECONDS)) {
                // 双重检查，防止缓存击穿下重复查询数据库
                demandJson = redisTemplate.opsForValue().get(cacheKey);
                if (demandJson != null) {
                    return JsonUtils.fromJson(demandJson, Demand.class);
                }

                // 3. 查数据库
                Demand demand = demandRepository.findById(demandId).orElse(null);
                if (demand == null) {
                    // 缓存空对象，防止缓存穿透
                    redisTemplate.opsForValue().set(cacheKey, "null", 30, TimeUnit.SECONDS);
                    return null;
                }

                // 4. 回写缓存，设置随机 TTL 避免雪崩
                redisTemplate.opsForValue().set(cacheKey,
                        JsonUtils.toJson(demand),
                        300 + (int)(Math.random() * 60),
                        TimeUnit.SECONDS);

                return demand;
            } else {
                // 获取锁失败 → 直接睡一会再查缓存（自旋）
                Thread.sleep(50);
                demandJson = redisTemplate.opsForValue().get(cacheKey);
                return demandJson != null ? JsonUtils.fromJson(demandJson, Demand.class) : null;
            }
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        } finally {
            if (lock.isHeldByCurrentThread()) {
                lock.unlock();
            }
        }
    }
}
```

