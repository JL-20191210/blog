# 项目问题2.0

### 1.为什么项目中使用RabbitMQ？

**第一，系统之间的解耦。**
   我们的系统是典型的微服务架构，比如侦查需求统筹系统（01）要向卫星公司 IO 系统（02）发送任务请求。
 如果用同步调用（比如 Feign），那一旦对方服务不可用，整个链路就会被阻塞。
 RabbitMQ 作为中间层，可以让消息先入队，即使卫星公司系统暂时不可用，消息也不会丢失，等对方恢复后自动消费，实现了系统之间的松耦合。**第二，异步处理，提升系统响应速度。**
像需求提报这种操作，涉及到多级节点（局基地、科处、哨位）的状态同步，如果全部走同步调用，会导致接口响应时间长。

我们把部分非关键流程（比如日志记录、状态广播、通知）放到 MQ 异步执行，让主业务线程更快返回，提高了整体吞吐量。

**第三，削峰填谷，提升系统稳定性。**
 在一些高峰期，比如战区集中提报任务或卫星回传数据时，会有瞬时流量高峰。
 我们通过 MQ 缓冲消息流，消费者端可以按自身处理能力消费，从而防止数据库或下游服务被压垮。

### 2.为什么选 RabbitMQ 而不是 Kafka？

我们的系统属于**政务/军工类分布式系统**，消息量没有互联网业务那么大，但**每一条消息都必须可靠送达**。
 RabbitMQ 在这方面做得更好，支持：

- 消息确认机制（ACK/NACK）
- 持久化队列（Durable）
- 死信队列（DLX）
- 延迟队列

这些机制让消息可靠性可以做到“几乎不丢”，非常符合我们这种对一致性和可靠性要求极高的场景。

Kafka 更偏向**日志流式处理**，追求的是高吞吐和顺序消费，但对实时事务一致性保障较弱，不太适合我们这种强事务系统。

### 3.你们在可靠性这方面是怎么设计的？

**🧩 1️⃣ 消息可靠投递（生产端可靠性）**

在生产端，我们严格防止“消息丢失”。
设计上做了三层保障：

1. **本地事务 + 消息表机制**
   - 在业务服务中，数据库操作和消息发送放在同一个本地事务里。
   - 比如需求提报时，先写业务表，同时往消息表插入一条“待发送”记录。
   - 事务提交后，再由定时任务扫描消息表异步发送 MQ，确保即使系统重启或 MQ 暂时不可用，消息也不会丢失。
2. **Confirm 确认机制**
   - 开启 RabbitMQ 的 `publisher-confirm` 模式。
   - 生产者发送消息后会等待 Broker 返回 ack，只有收到确认才更新消息表状态为“已发送”。
3. **Mandatory 与 Return 回调**
   - 开启 `mandatory` 参数，如果消息未能路由到任何队列，会触发回调并记录日志或重新投递。

**⚙️ 2️⃣ 消费端幂等性保证（防止重复消费）**

RabbitMQ 在网络抖动或重试时可能造成重复消息，因此我们在消费端做了**幂等控制**：

- 每条消息有唯一业务 ID（例如需求 ID + 消息类型），
- 消费时先查幂等表或 Redis，看该消息是否已处理；
- 已处理则直接丢弃，否则执行并标记完成。

这样即使消息被重复投递，也不会产生业务副作用。

**🔁 3️⃣ 失败重试与延迟队列机制**

对于消费失败的消息，我们设计了两级重试机制：

1. **业务内重试**：消费失败时先手动 NACK 并重新入队（设置最大重试次数）。
2. **延迟队列重试**：
   - 超过重试次数后，消息进入延迟队列（例如延迟 5 秒、30 秒、5 分钟等）；
   - 定时重试，直到消费成功或进入死信队列（DLX）待人工干预。

这种方式既能保证消息不丢失，也避免了频繁重试导致队列堆积。
**💾 4️⃣ 持久化与镜像队列（Broker 可靠性）**

RabbitMQ 层面我们开启了持久化配置：

- 队列设置为 `durable=true`；
- 消息属性设置为 `deliveryMode=2`（持久化消息）。

同时在部署上启用了 **镜像队列（HA 队列）**：

- 每条消息会在多个节点间复制；
- 即使某个节点宕机，其他节点也能无缝接管，不会丢失消息。

### 4.那如果数据库事务回滚了，但 MQ 消息已经发出去了，你怎么处理？

#### **1️⃣ 核心思路**

- **不直接在数据库事务里发送 MQ 消息**
- **先把消息写入本地消息表**（与业务表同一事务）
- **事务提交成功后，再异步发送 MQ**
- **发送失败可重试** → 保证最终一致性

**2️⃣ 流程步骤**

1. **开启本地或 Seata 全局事务**（根据是否跨库）
2. **写业务数据 + 写本地消息表**（消息状态 = `PENDING`）
3. **提交事务**
   - 如果事务回滚 → 消息表未写入 → 消息不会发送
4. **异步定时任务扫描消息表**
   - 发现 `PENDING` 消息 → 发送 MQ
   - MQ confirm 成功 → 更新消息状态为 `SENT`
   - 发送失败 → 重试（下次扫描再发送）
5. **幂等控制**
   - 下游消费系统根据消息 ID 做幂等判断，避免重复消费

### 5.遇到的难题，怎么解决的？

### **1️⃣ 分布式事务一致性问题**

**难题：**

- 需求提报涉及跨服务数据库更新（需求表、状态表），
- 同时要发送 MQ 消息通知下游系统，
- 数据库回滚但消息已发出会导致不一致。

**解决思路：**

1. 核心业务数据使用 **Seata 全局事务**，保证跨服务/跨库操作原子性；
2. MQ 消息采用 **本地消息表 + 定时任务异步发送**，事务回滚时消息不会发送；
3. 异步发送加**幂等控制 + 重试机制**，确保最终一致性。

> 核心思路：强一致性保证核心业务 + 最终一致性保证消息可靠投递。

### **2️⃣ 高并发报表生成性能问题**

**难题：**

- 全国需求报表生成量大，原本生成时间分钟级，影响业务效率。

**解决思路：**

1. 使用 **EasyExcel** 高性能生成 Excel；
2. **SQL 索引优化 + Redis 缓存**，减少数据库扫描量；
3. 异步化生成报表 + 流量削峰，性能从分钟级提升到秒级。

> 核心思路：结合缓存和异步处理，提高高并发场景下的吞吐量和响应速度。、

### **3️⃣ 分布式节点状态同步问题**

**难题：**

- 系统是三级树形节点（局基地、科处、哨位），
- 需求状态要同步到下级节点，网络延迟或节点宕机可能导致状态不一致。

**解决思路：**

1. **RabbitMQ 异步消息队列**实现状态广播，解耦节点间通信；
2. 消息加 **幂等控制**，避免重复消费导致错误；
3. 关键节点状态变更增加**重试和补偿机制**，确保最终一致。

> 核心思路：异步 + 幂等 + 补偿，保证分布式状态一致性。

### **4️⃣ 微服务高可用和负载均衡问题**

**难题：**

- 微服务多副本部署，需要保证服务注册发现、配置统一、调用高可用。

**解决思路：**

1. 使用 **Nacos** 做服务注册发现 + 配置中心；
2. 同步调用使用 **OpenFeign**，异步调用用 **MQ**；
3. Docker 多副本部署，保证负载均衡和高可用。

> 核心思路：服务注册 + 异步解耦 + 多副本部署，确保系统稳定性。























































































