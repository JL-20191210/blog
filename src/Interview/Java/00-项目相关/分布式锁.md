# 分布式锁

## 场景

### 1️⃣ 核心业务操作

- **需求提报 / 消解**
  - 防止多节点或多实例同时处理同一条需求，导致状态重复或覆盖
- **需求状态同步**
  - 多节点异步同步状态时，保证同一条记录在同一时间只能被一个实例更新

------

### 2️⃣ 报表与统计计算

- **报表导出**
  - 防止并发导出同一个条件的数据，避免重复计算和数据库压力
- **统计计算**
  - 批量统计历史数据时，确保同一时间段只有一个实例在执行统计逻辑

------

### 3️⃣ 缓存管理

- **热点数据缓存更新**
  - 多实例同时触发缓存更新（如 Redis TTL 过期或手动刷新）
  - 分布式锁保证只有一个实例去刷新，其他实例等待或跳过

------

### 4️⃣ 消息/任务调度

- **MQ 消息幂等处理**
  - 消费端有多个副本实例时，保证同一条消息只处理一次
- **定时任务/批处理**
  - 系统有多个实例同时跑定时任务（如数据清理、定期汇总）
  - 分布式锁确保任务不会被重复执行

------

### 5️⃣ 数据库写入冲突

- **高频并发写入**
  - 多实例同时写入同一条统计记录或状态表
  - 分布式锁避免写冲突或脏数据

------

### 🔹 面试口语总结

> 在我们的项目中，分布式锁不仅用于需求消解和状态同步，还应用在报表导出、统计计算、缓存刷新、消息幂等和定时任务执行等场景。主要作用是保证同一业务数据在同一时间只能被一个实例操作，从而避免重复处理和写冲突，保证系统数据一致性和稳定性。

## 分布式锁的使用

### 1️⃣ Java + Redisson 分布式锁示例（需求消解场景）

```java
@Service
public class DemandService {

    @Autowired
    private RedissonClient redissonClient;

    @Autowired
    private DemandRepository demandRepository;

    /**
     * 执行需求消解操作
     * @param demandId 需求ID
     */
    public void processDemand(Long demandId) {
        // 生成锁的唯一 key（业务唯一标识）
        String lockKey = "demand:lock:" + demandId;

        // 获取锁，等待最多500ms，锁过期时间5秒
        RLock lock = redissonClient.getLock(lockKey);
        boolean locked = false;
        try {
            locked = lock.tryLock(500, 5000, TimeUnit.MILLISECONDS);
            if (locked) {
                // 1️⃣ 查询当前需求状态
                Demand demand = demandRepository.findById(demandId);
                if(demand == null || demand.isProcessed()) {
                    return; // 已处理，直接返回
                }

                // 2️⃣ 执行业务逻辑（消解/状态更新）
                demand.process();
                demandRepository.save(demand);

                // 3️⃣ 可选：异步更新缓存或发送 MQ
            } else {
                // 获取锁失败，可选择重试或返回失败提示
                System.out.println("当前需求正在被其他实例处理，稍后重试");
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new RuntimeException("获取分布式锁失败", e);
        } finally {
            if (locked && lock.isHeldByCurrentThread()) {
                lock.unlock(); // 释放锁
            }
        }
    }
}
```

------

### 2️⃣ 高频缓存刷新场景

```java
public void refreshDemandCache(Long demandId) {
    String lockKey = "demand:cache:lock:" + demandId;
    RLock lock = redissonClient.getLock(lockKey);

    boolean locked = false;
    try {
        locked = lock.tryLock(200, 2000, TimeUnit.MILLISECONDS);
        if (locked) {
            // 1️⃣ 查询数据库
            Demand demand = demandRepository.findById(demandId);

            // 2️⃣ 刷新 Redis 缓存
            redisTemplate.opsForValue().set("demand:" + demandId, demand, 60, TimeUnit.SECONDS);
        } else {
            // 其他实例正在刷新缓存，跳过
            System.out.println("缓存刷新被其他实例占用，跳过");
        }
    } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
    } finally {
        if (locked && lock.isHeldByCurrentThread()) {
            lock.unlock();
        }
    }
}
```

------

### 3️⃣ 分布式锁参数说明

| 参数                                 | 说明                                                         |
| ------------------------------------ | ------------------------------------------------------------ |
| `lockKey`                            | 分布式锁唯一标识，通常用业务ID                               |
| `tryLock(waitTime, leaseTime, unit)` | 尝试获取锁，`waitTime` 等待获取锁时间，`leaseTime` 锁自动过期时间 |
| `unlock()`                           | 释放锁，确保只释放自己持有的锁                               |

------

### 🔹 面试口语总结

> 我们在项目中使用 Redis 分布式锁（Redisson 封装），在需求消解、状态同步、缓存刷新等高并发场景确保同一条业务数据同时只被一个实例处理。锁的 key 是业务唯一 ID，带有过期时间防止死锁。获取锁成功才执行业务操作，失败则重试或跳过，从而保证数据一致性和系统稳定性。