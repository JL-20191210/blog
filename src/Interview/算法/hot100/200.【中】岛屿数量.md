# [200. 岛屿数量](https://leetcode.cn/problems/number-of-islands/)

## 题目描述

> 给你一个由 `'1'`（陆地）和 `'0'`（水）组成的的二维网格，请你计算网格中岛屿的数量。
>
> 岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。
>
> 此外，你可以假设该网格的四条边均被水包围。
>
>  
>
> **示例 1：**
>
> ```
> 输入：grid = [
>   ['1','1','1','1','0'],
>   ['1','1','0','1','0'],
>   ['1','1','0','0','0'],
>   ['0','0','0','0','0']
> ]
> 输出：1
> ```
>
> **示例 2：**
>
> ```
> 输入：grid = [
>   ['1','1','0','0','0'],
>   ['1','1','0','0','0'],
>   ['0','0','1','0','0'],
>   ['0','0','0','1','1']
> ]
> 输出：3
> ```

## 代码示例

```java
class Solution {
    // 定义四个方向的移动：上、下、左、右
    private static int[] x = {1, -1, 0, 0};
    private static int[] y = {0, 0, 1, -1};

    // 主方法，用来计算岛屿的数量
    public int numIslands(char[][] grid) {
        // 如果网格为空或者没有任何岛屿（无有效行或列），返回 0
        if (grid == null || grid.length == 0 || grid[0].length == 0) return 0;

        int row = grid.length;   // 行数
        int cols = grid[0].length;  // 列数
        int islandsCount = 0;  // 岛屿数量

        // 遍历网格中的每个位置
        for (int i = 0; i < row; i++) {
            for (int j = 0; j < cols; j++) {
                // 如果当前位置是岛屿（值为 '1'）
                if (grid[i][j] == '1') {
                    islandsCount++;  // 岛屿计数器加 1
                    dfs(grid, i, j);  // 调用 DFS 来标记所有与该岛屿相连的部分
                }
            }
        }

        return islandsCount;  // 返回岛屿的数量
    }

    // 深度优先搜索 (DFS) 方法，标记岛屿（将 '1' 替换为 '0'，表示已经访问过）
    void dfs(char[][] grid, int i, int j) {
        // 如果越界或当前位置已经是水域（'0'），则返回
        if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] == '0') {
            return;
        }

        // 将当前岛屿位置标记为水域，避免重复访问
        grid[i][j] = '0';

        // 遍历当前岛屿的四个相邻位置（上下左右）
        for (int k = 0; k < 4; k++) {
            int newX = i + x[k];  // 计算新的行坐标
            int newY = j + y[k];  // 计算新的列坐标
            dfs(grid, newX, newY);  // 递归调用 DFS
        }
    }
}

```