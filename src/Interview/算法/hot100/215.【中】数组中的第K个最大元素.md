# [215. 数组中的第K个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/)

## 题目描述

> 给定整数数组 `nums` 和整数 `k`，请返回数组中第 `**k**` 个最大的元素。
>
> 请注意，你需要找的是数组排序后的第 `k` 个最大的元素，而不是第 `k` 个不同的元素。
>
> 你必须设计并实现时间复杂度为 `O(n)` 的算法解决此问题。
>
>  
>
> **示例 1:**
>
> ```
> 输入: [3,2,1,5,6,4], k = 2
> 输出: 5
> ```
>
> **示例 2:**
>
> ```
> 输入: [3,2,3,1,2,4,5,5,6], k = 4
> 输出: 4
> ```

## 代码实现

```java
class Solution {
    // 主方法，用来找到数组中第 k 大的元素
    public int findKthLargest(int[] nums, int k) {
        int n = nums.length;  // 数组的长度
        // 调用 quickselect 函数，找到第 n-k 小的元素，也就是第 k 大的元素
        return quickselect(nums, 0, n - 1, n - k);
    }

    // 快速选择算法：用来在数组中找到第 k 小的元素
    int quickselect(int[] nums, int l, int r, int k) {
        // 递归终止条件：如果 l == r，表示只剩下一个元素，直接返回
        if (l == r) return nums[k];

        int x = nums[l], i = l - 1, j = r + 1;
        // 使用快速排序的思路：基准值 x，分区操作
        while (i < j) {
            // 从左侧找到大于或等于基准值的元素
            do i++; while (nums[i] < x);
            // 从右侧找到小于或等于基准值的元素
            do j--; while (nums[j] > x);

            // 如果 i < j，则交换这两个元素
            if (i < j) {
                int temp = nums[i];
                nums[i] = nums[j];
                nums[j] = temp;
            }
        }

        // 判断第 k 小的元素所在的分区
        if (k <= j)  // 如果 k 小于等于 j，意味着第 k 小的元素在左边部分
            return quickselect(nums, l, j, k);  // 递归查找左部分
        else  // 如果 k 大于 j，意味着第 k 小的元素在右边部分
            return quickselect(nums, j + 1, r, k);  // 递归查找右部分
    }
}
```

