# [5. 最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/)

## 题目描述

> 给你一个字符串 `s`，找到 `s` 中最长的 回文 子串。
>
>  
>
> **示例 1：**
>
> ```
> 输入：s = "babad"
> 输出："bab"
> 解释："aba" 同样是符合题意的答案。
> ```
>
> **示例 2：**
>
> ```
> 输入：s = "cbbd"
> 输出："bb"
> ```

## 示例代码

```java
class Solution {
    public String longestPalindrome(String s) {
        int len  = s.length();
        
        // 如果字符串的长度小于2，直接返回原字符串，因为一个字符或者空字符串本身就是回文
        if(len < 2){
            return s;
        }

        // maxLen 记录当前找到的最大回文串的长度
        int maxLen = 1;
        // start 记录最大回文串的起始位置
        int start = 0;
        
        // judge[i][j] 用来判断字符串从 i 到 j 的子串是否是回文串
        boolean [][] judge = new boolean[len][len];

        // 初始化：所有长度为1的子串（单个字符）都是回文串
        for (int i = 0; i < len; i++) {
            judge[i][i] = true;
        }

        // 将输入字符串转成字符数组，方便操作
        char[] charArray = s.toCharArray();

        // 从子串长度为2开始，逐渐检查更长的子串
        for(int L = 2; L <= len; L++) {  // L 表示当前检查的子串长度
            // 遍历所有可能的子串起始位置 i
            for(int i = 0; i < len; i++) {
                // 计算子串的结束位置 j
                int j = L + i - 1;
                
                // 如果子串的结束位置 j 超出了字符串的范围，跳出循环
                if(j >= len) {
                    break;
                }
                
                // 判断当前子串 s[i..j] 是否为回文
                if(charArray[i] != charArray[j]) {
                    judge[i][j] = false; // 如果两端字符不同，显然不是回文
                } else {
                    // 如果两端字符相同，进一步判断是否是回文
                    if(j - i < 3) {
                        // 对于长度小于3的子串，只有两端相同即为回文（例如 "aa" 或 "aba"）
                        judge[i][j] = true;
                    } else {
                        // 对于长度大于3的子串，判断中间的子串是否为回文
                        judge[i][j] = judge[i+1][j-1];
                    }
                }

                // 如果当前子串是回文并且长度大于之前的最大回文串，则更新最大回文串的长度和起始位置
                if(judge[i][j] && j - i + 1 > maxLen) {
                    maxLen = j - i + 1;
                    start = i;
                }
            }
        }

        // 返回从 start 开始，长度为 maxLen 的子串，即最长回文子串
        return s.substring(start, start + maxLen);
    }
}

```

