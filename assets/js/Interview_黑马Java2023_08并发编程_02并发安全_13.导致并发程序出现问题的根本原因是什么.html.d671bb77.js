"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[7327],{66262:(i,a)=>{a.A=(i,a)=>{const n=i.__vccOpts||i;for(const[i,p]of a)n[i]=p;return n}},56877:(i,a,n)=>{n.r(a),n.d(a,{comp:()=>r,data:()=>c});var p=n(20641);const e=n.p+"assets/img/174118380077410.d6feb142.png",t=n.p+"assets/img/174118380324713.6f98206b.png",l=n.p+"assets/img/174118380487916.1e6a0151.png",s=n.p+"assets/img/174118474128519.f573fdda.png",o={},r=(0,n(66262).A)(o,[["render",function(i,a){return(0,p.uX)(),(0,p.CE)("div",null,a[0]||(a[0]=[(0,p.Fv)('<h1 id="_13-导致并发程序出现问题的根本原因是什么" tabindex="-1"><a class="header-anchor" href="#_13-导致并发程序出现问题的根本原因是什么"><span>13.导致并发程序出现问题的根本原因是什么</span></a></h1><blockquote><p>难易程度：☆☆☆</p><p>出现频率：☆☆☆</p></blockquote><div class="hint-container important"><p class="hint-container-title">重要</p><p><strong>参考回答</strong></p><p>Java并发编程有三大核心特性，分别是原子性、可见性和有序性（袁克友）。</p><p>首先，原子性指的是一个线程在CPU中的操作是不可暂停也不可中断的，要么执行完成，要么不执行。比如，一些简单的操作如赋值可能是原子的，但复合操作如自增就不是原子的。为了保证原子性，我们可以使用synchronized关键字或JUC里面的Lock来进行加锁。</p><p>其次，可见性是指让一个线程对共享变量的修改对另一个线程可见。由于线程可能在自己的工作内存中缓存共享变量的副本，因此一个线程对共享变量的修改可能不会立即反映在其他线程的工作内存中。为了解决这个问题，我们可以使用synchronized关键字、volatile关键字或Lock来确保可见性。</p><p>最后，有序性是指处理器为了提高程序运行效率，可能会对输入代码进行优化，导致程序中各个语句的执行先后顺序与代码中的顺序不一致。虽然处理器会保证程序最终执行结果与代码顺序执行的结果一致，但在某些情况下我们可能需要确保特定的执行顺序。为了解决这个问题，我们可以使用volatile关键字来禁止指令重排。</p></div><p>Java并发编程三大特性</p><ul><li>原子性</li><li>可见性</li><li>有序性</li></ul><h4 id="_1-原子性" tabindex="-1"><a class="header-anchor" href="#_1-原子性"><span>（1）原子性</span></a></h4><p>一个线程在CPU中操作不可暂停，也不可中断，要不执行完成，要不不执行</p><p>比如，如下代码能保证原子性吗？</p><figure><img src="'+e+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>以上代码会出现超卖或者是一张票卖给同一个人，执行并不是原子性的</p><p>解决方案：</p><p>1.synchronized：同步加锁</p><p>2.JUC里面的lock：加锁</p><figure><img src="'+t+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h4 id="_3-内存可见性" tabindex="-1"><a class="header-anchor" href="#_3-内存可见性"><span>（3）内存可见性</span></a></h4><p>内存可见性：让一个线程对共享变量的修改对另一个线程可见</p><p>比如，以下代码不能保证内存可见性</p><figure><img src="'+l+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>解决方案：</p><ul><li>synchronized</li><li>volatile（推荐）</li><li>LOCK</li></ul><h4 id="_3-有序性" tabindex="-1"><a class="header-anchor" href="#_3-有序性"><span>（3）有序性</span></a></h4><p>指令重排：处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的</p><p>还是之前的例子，如下代码：</p><figure><img src="'+s+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>解决方案：</p><ul><li>volatile</li></ul>',26)]))}]]),c=JSON.parse('{"path":"/Interview/%E9%BB%91%E9%A9%ACJava2023/08%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/02%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8/13.%E5%AF%BC%E8%87%B4%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E5%87%BA%E7%8E%B0%E9%97%AE%E9%A2%98%E7%9A%84%E6%A0%B9%E6%9C%AC%E5%8E%9F%E5%9B%A0%E6%98%AF%E4%BB%80%E4%B9%88.html","title":"13.导致并发程序出现问题的根本原因是什么","lang":"zh-CN","frontmatter":{"gitInclude":[]},"headers":[],"readingTime":{"minutes":2.3,"words":690},"filePathRelative":"Interview/黑马Java2023/08并发编程/02并发安全/13.导致并发程序出现问题的根本原因是什么.md","excerpt":"\\n<blockquote>\\n<p>难易程度：☆☆☆</p>\\n<p>出现频率：☆☆☆</p>\\n</blockquote>\\n<div class=\\"hint-container important\\">\\n<p class=\\"hint-container-title\\">重要</p>\\n<p><strong>参考回答</strong></p>\\n<p>Java并发编程有三大核心特性，分别是原子性、可见性和有序性（袁克友）。</p>\\n<p>首先，原子性指的是一个线程在CPU中的操作是不可暂停也不可中断的，要么执行完成，要么不执行。比如，一些简单的操作如赋值可能是原子的，但复合操作如自增就不是原子的。为了保证原子性，我们可以使用synchronized关键字或JUC里面的Lock来进行加锁。</p>\\n<p>其次，可见性是指让一个线程对共享变量的修改对另一个线程可见。由于线程可能在自己的工作内存中缓存共享变量的副本，因此一个线程对共享变量的修改可能不会立即反映在其他线程的工作内存中。为了解决这个问题，我们可以使用synchronized关键字、volatile关键字或Lock来确保可见性。</p>\\n<p>最后，有序性是指处理器为了提高程序运行效率，可能会对输入代码进行优化，导致程序中各个语句的执行先后顺序与代码中的顺序不一致。虽然处理器会保证程序最终执行结果与代码顺序执行的结果一致，但在某些情况下我们可能需要确保特定的执行顺序。为了解决这个问题，我们可以使用volatile关键字来禁止指令重排。</p>\\n</div>"}')}}]);