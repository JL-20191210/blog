"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[6791],{6262:(n,e)=>{e.A=(n,e)=>{const r=n.__vccOpts||n;for(const[n,l]of e)r[n]=l;return r}},7632:(n,e,r)=>{r.r(e),r.d(e,{comp:()=>s,data:()=>o});var l=r(641);const t={},s=(0,r(6262).A)(t,[["render",function(n,e){return(0,l.uX)(),(0,l.CE)("div",null,e[0]||(e[0]=[(0,l.Fv)('<h1 id="_4-堆" tabindex="-1"><a class="header-anchor" href="#_4-堆"><span>4. 堆</span></a></h1><h2 id="_4-1-定义" tabindex="-1"><a class="header-anchor" href="#_4-1-定义"><span>4.1 定义</span></a></h2><p>堆（Heap）是 JVM 中用于存储对象实例的内存区域。所有通过 <code>new</code> 关键字创建的对象都会分配到堆内存中。</p><p><strong>特点：</strong></p><ul><li>线程共享：所有线程都可以访问堆内存中的对象。</li><li>垃圾回收：堆内存支持垃圾回收，自动回收不再使用的对象。</li></ul><h2 id="_4-2-堆内存溢出" tabindex="-1"><a class="header-anchor" href="#_4-2-堆内存溢出"><span>4.2 堆内存溢出</span></a></h2><p><strong>堆内存溢出</strong>（Heap OutOfMemoryError）通常发生在堆内存中对象过多，超出了容量限制。可以通过指定堆内存大小（如 <code>-Xmx8m</code>）来避免溢出。</p><p><strong>诊断工具：</strong></p><ul><li><strong>jps 工具</strong>：查看当前 Java 进程。</li><li><strong>jmap 工具</strong>：查看堆内存占用情况。</li><li><strong>jconsole 工具</strong>：图形化监控工具，查看堆内存使用情况。</li><li><strong>jvisualvm 工具</strong>：提供堆内存分析和性能监控功能。</li></ul>',9)]))}]]),o=JSON.parse('{"path":"/JVM/2.%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/2.4%E5%A0%86.html","title":"4. 堆","lang":"zh-CN","frontmatter":{"gitInclude":[]},"headers":[{"level":2,"title":"4.1 定义","slug":"_4-1-定义","link":"#_4-1-定义","children":[]},{"level":2,"title":"4.2 堆内存溢出","slug":"_4-2-堆内存溢出","link":"#_4-2-堆内存溢出","children":[]}],"readingTime":{"minutes":0.68,"words":204},"filePathRelative":"JVM/2.内存结构/2.4堆.md","excerpt":"\\n<h2>4.1 定义</h2>\\n<p>堆（Heap）是 JVM 中用于存储对象实例的内存区域。所有通过 <code>new</code> 关键字创建的对象都会分配到堆内存中。</p>\\n<p><strong>特点：</strong></p>\\n<ul>\\n<li>线程共享：所有线程都可以访问堆内存中的对象。</li>\\n<li>垃圾回收：堆内存支持垃圾回收，自动回收不再使用的对象。</li>\\n</ul>\\n<h2>4.2 堆内存溢出</h2>\\n<p><strong>堆内存溢出</strong>（Heap OutOfMemoryError）通常发生在堆内存中对象过多，超出了容量限制。可以通过指定堆内存大小（如 <code>-Xmx8m</code>）来避免溢出。</p>"}')}}]);