"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[21844],{66262:(a,n)=>{n.A=(a,n)=>{const t=a.__vccOpts||a;for(const[a,s]of n)t[a]=s;return t}},45152:(a,n,t)=>{t.r(n),t.d(n,{comp:()=>l,data:()=>r});var s=t(20641);const e={},l=(0,t(66262).A)(e,[["render",function(a,n){return(0,s.uX)(),(0,s.CE)("div",null,n[0]||(n[0]=[(0,s.Fv)('<h1 id="☕-java-面试答题卡-concurrenthashmap详解" tabindex="-1"><a class="header-anchor" href="#☕-java-面试答题卡-concurrenthashmap详解"><span>☕ Java 面试答题卡：ConcurrentHashMap详解</span></a></h1><h2 id="✅-1-什么是-concurrenthashmap" tabindex="-1"><a class="header-anchor" href="#✅-1-什么是-concurrenthashmap"><span>✅ 1. 什么是 ConcurrentHashMap？</span></a></h2><blockquote><p>ConcurrentHashMap 是 Java 中一个<strong>线程安全的哈希表实现</strong>，支持并发读写操作，性能远优于 Hashtable 和 Collections.synchronizedMap()。</p></blockquote><p>它是并发编程中非常重要的基础组件。</p><h2 id="✅-2-所在包与版本" tabindex="-1"><a class="header-anchor" href="#✅-2-所在包与版本"><span><strong>✅ 2. 所在包与版本</strong></span></a></h2><ul><li>所在包：java.util.concurrent</li><li>出现版本：Java 1.5，引入了分段锁实现</li><li>Java 8 重写为基于<strong>CAS + synchronized + 红黑树</strong>的结构</li></ul><h2 id="✅-3-与其他-map-对比" tabindex="-1"><a class="header-anchor" href="#✅-3-与其他-map-对比"><span><strong>✅ 3. 与其他 Map 对比</strong></span></a></h2><table><thead><tr><th><strong>特性</strong></th><th>HashMap</th><th>Hashtable</th><th>ConcurrentHashMap</th></tr></thead><tbody><tr><td>线程安全</td><td>❌</td><td>✅（全部同步）</td><td>✅（高并发设计）</td></tr><tr><td>锁粒度</td><td>无锁</td><td>整体锁</td><td>分段/节点锁</td></tr><tr><td>读写效率</td><td>高（单线程）</td><td>低（全锁）</td><td>高（多线程）</td></tr><tr><td>支持 null 键值</td><td>✅（允许一个）</td><td>❌</td><td>❌</td></tr><tr><td>适合场景</td><td>单线程或读多写少</td><td>非推荐（老API）</td><td>多线程高并发读写</td></tr></tbody></table><h2 id="✅-4-java-7-vs-java-8-实现对比" tabindex="-1"><a class="header-anchor" href="#✅-4-java-7-vs-java-8-实现对比"><span><strong>✅ 4. Java 7 vs Java 8 实现对比</strong></span></a></h2><table><thead><tr><th><strong>版本</strong></th><th><strong>底层结构</strong></th><th><strong>锁策略</strong></th></tr></thead><tbody><tr><td>Java 7</td><td>Segment[] + HashEntry[]</td><td>分段锁（Segment继承ReentrantLock）</td></tr><tr><td>Java 8</td><td>Node[] + 链表/红黑树</td><td>CAS + synchronized</td></tr></tbody></table><blockquote><p>Java 8 移除了 Segment，提高空间效率；写时采用 CAS + synchronized，提高并发度。</p></blockquote><h2 id="✅-5-java-8-结构详解" tabindex="-1"><a class="header-anchor" href="#✅-5-java-8-结构详解"><span><strong>✅ 5. Java 8 结构详解</strong></span></a></h2><h3 id="🌳-基本结构" tabindex="-1"><a class="header-anchor" href="#🌳-基本结构"><span><strong>🌳 基本结构：</strong></span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>transient volatile Node&lt;K,V&gt;[] table;  // 主存储数组（Node 链表或红黑树）</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li>Node：链表节点结构（key、value、hash、next）</li><li>table：核心存储数组，默认初始化大小 16</li></ul><h3 id="🌳-高并发写的核心手段" tabindex="-1"><a class="header-anchor" href="#🌳-高并发写的核心手段"><span><strong>🌳 高并发写的核心手段：</strong></span></a></h3><table><thead><tr><th><strong>技术</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td>CAS</td><td>控制桶位插入、初始化、扩容标志等</td></tr><tr><td>synchronized</td><td>控制链表/红黑树写入过程</td></tr><tr><td>volatile</td><td>保证 table 和 size 等字段的可见性</td></tr><tr><td>分段扩容机制</td><td>分布式地进行 rehash，避免全表阻塞</td></tr></tbody></table><h2 id="✅-6-插入流程简图-java-8" tabindex="-1"><a class="header-anchor" href="#✅-6-插入流程简图-java-8"><span><strong>✅ 6. 插入流程简图（Java 8）</strong></span></a></h2><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>put(key, val)</span></span>\n<span class="line"><span>  └── 1. 计算 hash</span></span>\n<span class="line"><span>      ├── 2. 如果 table 未初始化，CAS 初始化</span></span>\n<span class="line"><span>      ├── 3. 定位桶位 i = (n - 1) &amp; hash</span></span>\n<span class="line"><span>      ├── 4. 如果桶为空，CAS 插入新节点</span></span>\n<span class="line"><span>      ├── 5. 如果非空：</span></span>\n<span class="line"><span>      │     ├── 5.1 是链表：synchronized 上锁 + 遍历插入</span></span>\n<span class="line"><span>      │     └── 5.2 是红黑树：红黑树插入逻辑</span></span>\n<span class="line"><span>      └── 6. 判断是否需要 treeify 或 resize</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="✅-7-常用-api-示例" tabindex="-1"><a class="header-anchor" href="#✅-7-常用-api-示例"><span><strong>✅ 7. 常用 API 示例</strong></span></a></h2><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>ConcurrentHashMap&lt;String, Integer&gt; map = new ConcurrentHashMap&lt;&gt;();</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>map.put(&quot;A&quot;, 1);</span></span>\n<span class="line"><span>map.putIfAbsent(&quot;B&quot;, 2);</span></span>\n<span class="line"><span>map.compute(&quot;A&quot;, (k, v) -&gt; v == null ? 0 : v + 1);</span></span>\n<span class="line"><span>map.forEach(1, (k, v) -&gt; System.out.println(k + &quot;:&quot; + v));</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="✅-8-常见面试问题解析" tabindex="-1"><a class="header-anchor" href="#✅-8-常见面试问题解析"><span><strong>✅ 8. 常见面试问题解析</strong></span></a></h2><h3 id="q1-为什么-concurrenthashmap不支持-null" tabindex="-1"><a class="header-anchor" href="#q1-为什么-concurrenthashmap不支持-null"><span><strong>Q1：为什么</strong> ConcurrentHashMap不支持 null？</span></a></h3><ul><li>为避免<strong>put(null, value)</strong> 与 <strong>map.get(key) == null</strong> 产生歧义（究竟是键不存在，还是值为 null）</li></ul><h3 id="q2-为什么读操作不加锁" tabindex="-1"><a class="header-anchor" href="#q2-为什么读操作不加锁"><span><strong>Q2：为什么读操作不加锁？</strong></span></a></h3><ul><li>因为数据结构使用了 volatile + 单向链表结构，读操作只需保证<strong>可见性即可</strong>，无需互斥。</li><li>Java 8 中通过<strong>volatile 保证数组可见性</strong>，Node 元素不可变。</li></ul><h3 id="q3-扩容如何避免阻塞" tabindex="-1"><a class="header-anchor" href="#q3-扩容如何避免阻塞"><span><strong>Q3：扩容如何避免阻塞？</strong></span></a></h3><ul><li>Java 8 使用 transferIndex + 多线程协作迁移，每个线程负责一段桶位数据迁移，避免一次性全表锁死。</li></ul><h2 id="✅-9-使用场景" tabindex="-1"><a class="header-anchor" href="#✅-9-使用场景"><span><strong>✅ 9. 使用场景</strong></span></a></h2><ul><li>并发环境下的缓存结构（如 LRU 缓存）</li><li>线程安全的 HashMap 替代品</li><li>计数器、并发 ID 映射表</li><li>Spring 的 Bean 定义映射结构（内部使用）</li></ul><h2 id="✅-10-注意事项" tabindex="-1"><a class="header-anchor" href="#✅-10-注意事项"><span><strong>✅ 10. 注意事项</strong></span></a></h2><table><thead><tr><th><strong>注意点</strong></th><th><strong>建议/说明</strong></th></tr></thead><tbody><tr><td>null 键值不支持</td><td>使用 Optional 或默认值规避</td></tr><tr><td>遍历是弱一致性（弱一致性迭代器）</td><td>可用于读多写少的遍历场景</td></tr><tr><td>写操作仍然有锁竞争</td><td>高并发写入可能不如预期快</td></tr><tr><td>不适合严格一致性需求场景</td><td>如需要强一致性，应考虑加锁或用 ConcurrentSkipListMap</td></tr></tbody></table><h2 id="🎯-面试简答模板-建议背诵" tabindex="-1"><a class="header-anchor" href="#🎯-面试简答模板-建议背诵"><span><strong>🎯 面试简答模板（建议背诵）</strong></span></a></h2><blockquote><p>ConcurrentHashMap 是 Java 中线程安全的哈希表实现，支持高并发读写操作。Java 7 使用 Segment 分段锁，而 Java 8 重构为基于 CAS + synchronized 的节点级并发机制，底层结构为数组 + 链表 + 红黑树组合。它不支持 null 键值，并发读操作不加锁，适合高性能并发环境下的数据存取，如缓存、线程安全 Map 等场景。</p></blockquote>',34)]))}]]),r=JSON.parse('{"path":"/Interview/%E9%9D%A2%E8%AF%95%E7%AD%94%E9%A2%98%E5%8D%A1/Java/ConcurrentHashMap%20%E8%AF%A6%E8%A7%A3.html","title":"☕ Java 面试答题卡：ConcurrentHashMap详解","lang":"zh-CN","frontmatter":{"gitInclude":[]},"headers":[{"level":2,"title":"✅ 1. 什么是 ConcurrentHashMap？","slug":"✅-1-什么是-concurrenthashmap","link":"#✅-1-什么是-concurrenthashmap","children":[]},{"level":2,"title":"✅ 2. 所在包与版本","slug":"✅-2-所在包与版本","link":"#✅-2-所在包与版本","children":[]},{"level":2,"title":"✅ 3. 与其他 Map 对比","slug":"✅-3-与其他-map-对比","link":"#✅-3-与其他-map-对比","children":[]},{"level":2,"title":"✅ 4. Java 7 vs Java 8 实现对比","slug":"✅-4-java-7-vs-java-8-实现对比","link":"#✅-4-java-7-vs-java-8-实现对比","children":[]},{"level":2,"title":"✅ 5. Java 8 结构详解","slug":"✅-5-java-8-结构详解","link":"#✅-5-java-8-结构详解","children":[{"level":3,"title":"🌳 基本结构：","slug":"🌳-基本结构","link":"#🌳-基本结构","children":[]},{"level":3,"title":"🌳 高并发写的核心手段：","slug":"🌳-高并发写的核心手段","link":"#🌳-高并发写的核心手段","children":[]}]},{"level":2,"title":"✅ 6. 插入流程简图（Java 8）","slug":"✅-6-插入流程简图-java-8","link":"#✅-6-插入流程简图-java-8","children":[]},{"level":2,"title":"✅ 7. 常用 API 示例","slug":"✅-7-常用-api-示例","link":"#✅-7-常用-api-示例","children":[]},{"level":2,"title":"✅ 8. 常见面试问题解析","slug":"✅-8-常见面试问题解析","link":"#✅-8-常见面试问题解析","children":[{"level":3,"title":"Q1：为什么 ConcurrentHashMap不支持 null？","slug":"q1-为什么-concurrenthashmap不支持-null","link":"#q1-为什么-concurrenthashmap不支持-null","children":[]},{"level":3,"title":"Q2：为什么读操作不加锁？","slug":"q2-为什么读操作不加锁","link":"#q2-为什么读操作不加锁","children":[]},{"level":3,"title":"Q3：扩容如何避免阻塞？","slug":"q3-扩容如何避免阻塞","link":"#q3-扩容如何避免阻塞","children":[]}]},{"level":2,"title":"✅ 9. 使用场景","slug":"✅-9-使用场景","link":"#✅-9-使用场景","children":[]},{"level":2,"title":"✅ 10. 注意事项","slug":"✅-10-注意事项","link":"#✅-10-注意事项","children":[]},{"level":2,"title":"🎯 面试简答模板（建议背诵）","slug":"🎯-面试简答模板-建议背诵","link":"#🎯-面试简答模板-建议背诵","children":[]}],"readingTime":{"minutes":3.06,"words":919},"filePathRelative":"Interview/面试答题卡/Java/ConcurrentHashMap 详解.md","excerpt":"\\n<h2>✅ 1. 什么是 ConcurrentHashMap？</h2>\\n<blockquote>\\n<p>ConcurrentHashMap 是 Java 中一个<strong>线程安全的哈希表实现</strong>，支持并发读写操作，性能远优于 Hashtable 和 Collections.synchronizedMap()。</p>\\n</blockquote>\\n<p>它是并发编程中非常重要的基础组件。</p>\\n<h2><strong>✅ 2. 所在包与版本</strong></h2>\\n<ul>\\n<li>所在包：java.util.concurrent</li>\\n<li>出现版本：Java 1.5，引入了分段锁实现</li>\\n<li>Java 8 重写为基于<strong>CAS + synchronized + 红黑树</strong>的结构</li>\\n</ul>"}')}}]);