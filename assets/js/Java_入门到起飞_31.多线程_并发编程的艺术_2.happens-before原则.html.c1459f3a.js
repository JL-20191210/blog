"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[6964],{66262:(s,i)=>{i.A=(s,i)=>{const a=s.__vccOpts||s;for(const[s,e]of i)a[s]=e;return a}},56790:(s,i,a)=>{a.r(i),a.d(i,{comp:()=>h,data:()=>l});var e=a(20641);const n={},h=(0,a(66262).A)(n,[["render",function(s,i){return(0,e.uX)(),(0,e.CE)("div",null,i[0]||(i[0]=[(0,e.Fv)('<h1 id="java内存模型中的-happens-before-规则" tabindex="-1"><a class="header-anchor" href="#java内存模型中的-happens-before-规则"><span>Java内存模型中的 <code>happens-before</code> 规则</span></a></h1><p>在Java多线程编程中，保证程序的正确性和一致性至关重要。Java内存模型（JMM）通过一系列规则来确保多线程环境下数据的一致性，其中最核心的概念之一就是 <code>happens-before</code> 关系。理解并正确运用 <code>happens-before</code> 规则是开发高效且正确的多线程程序的关键。</p><h4 id="什么是-happens-before" tabindex="-1"><a class="header-anchor" href="#什么是-happens-before"><span>什么是 <code>happens-before</code>？</span></a></h4><p><code>happens-before</code> 是Java内存模型中的一个关键概念，定义了两项操作之间的执行顺序关系。当我们说一个操作 &quot;happens-before&quot; 另一个操作时，意味着第一个操作的结果在第二个操作之前对所有线程可见，并且保证了前者的操作不会被重排到后者的后面。</p><p>换句话说，<code>happens-before</code> 提供了一种机制，确保在多线程环境下对共享变量的修改和读取是有序的，避免线程间的不可预测行为。</p><h3 id="_1-happens-before-规则的基本解释" tabindex="-1"><a class="header-anchor" href="#_1-happens-before-规则的基本解释"><span>1. <code>happens-before</code> 规则的基本解释</span></a></h3><p><code>happens-before</code> 规则描述了在多线程环境中，不同线程操作之间如何保持可见性、原子性和有序性。具体来说，<code>happens-before</code> 确保以下几点：</p><ul><li><strong>可见性</strong>：一个线程对共享变量的修改对其他线程是可见的。</li><li><strong>原子性</strong>：线程执行的操作不会被其他线程中断。</li><li><strong>有序性</strong>：操作执行的顺序符合预期，避免由于指令重排导致的错误。</li></ul><h3 id="_2-happens-before-规则的具体实现" tabindex="-1"><a class="header-anchor" href="#_2-happens-before-规则的具体实现"><span>2. <code>happens-before</code> 规则的具体实现</span></a></h3><p>在JMM中，以下几种情况构成了常见的 <code>happens-before</code> 关系：</p><h4 id="_1-程序顺序规则-program-order-rule" tabindex="-1"><a class="header-anchor" href="#_1-程序顺序规则-program-order-rule"><span>1. 程序顺序规则（Program Order Rule）</span></a></h4><p>对于单个线程中的操作，程序的执行顺序是天然的<code>happens-before</code>关系。即在一个线程中，前面的语句总是 <code>happens-before</code> 后面的语句。比如：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> x </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 10</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 操作1</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">x </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> x </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 操作2</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，<code>操作1</code>（<code>x = 10</code>）必然在 <code>操作2</code>（<code>x = x + 1</code>）之前执行。</p><h4 id="_2-锁规则-lock-rule" tabindex="-1"><a class="header-anchor" href="#_2-锁规则-lock-rule"><span>2. 锁规则（Lock Rule）</span></a></h4><p>在JMM中，锁的释放（<code>unlock</code>）总是 <code>happens-before</code> 锁的获取（<code>lock</code>）。即一个线程释放锁之后，另一个线程获得该锁时，之前的所有修改都对后者可见。例如：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">synchronized</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (lock) {</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    x </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 10</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">} </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 锁释放，操作1</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">synchronized</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (lock) {</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">    System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(x);</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 锁获取，操作2</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，<code>操作1</code>（<code>x = 10</code>）发生在 <code>操作2</code>（<code>System.out.println(x)</code>）之前，并且 <code>操作2</code> 能够看到 <code>操作1</code> 的结果。</p><h4 id="_3-volatile-变量规则-volatile-variable-rule" tabindex="-1"><a class="header-anchor" href="#_3-volatile-变量规则-volatile-variable-rule"><span>3. <code>volatile</code> 变量规则（Volatile Variable Rule）</span></a></h4><p>在JMM中，<code>volatile</code> 关键字确保了对变量的写操作 <code>happens-before</code> 随后的读操作。具体来说，<code>volatile</code> 变量的写操作总是先于其他线程读取该变量的操作。因此，如果一个线程修改了一个 <code>volatile</code> 变量的值，其他线程对该变量的读取总能看到最新的值。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">volatile</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> boolean</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> flag </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> false</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">Thread </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> flag </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> true</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 写操作</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">Thread </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (flag) { </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 读操作</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 这里能看到 flag = true</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，线程1对<code>flag</code>变量的写操作 <code>happens-before</code> 线程2对<code>flag</code>变量的读操作，保证了线程2能够看到最新的值。</p><h4 id="_4-线程启动规则-thread-start-rule" tabindex="-1"><a class="header-anchor" href="#_4-线程启动规则-thread-start-rule"><span>4. 线程启动规则（Thread Start Rule）</span></a></h4><p>在JMM中，线程的启动操作 <code>happens-before</code> 该线程的任何操作。也就是说，线程调用 <code>start()</code> 方法时，主线程中的操作总是会在新线程的执行之前完成。例如：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Thread</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> t </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> Thread</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(() </span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">-&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;Thread started&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">t</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">start</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 主线程的操作1</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>这里，<code>主线程的操作1</code>（调用 <code>start()</code>）发生在新线程执行 <code>System.out.println()</code> 之前。</p><h4 id="_5-线程中断规则-thread-interrupt-rule" tabindex="-1"><a class="header-anchor" href="#_5-线程中断规则-thread-interrupt-rule"><span>5. 线程中断规则（Thread Interrupt Rule）</span></a></h4><p>线程的中断操作总是 <code>happens-before</code> 被中断线程的 <code>InterruptedException</code> 被抛出。例如：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Thread</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> t </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> Thread</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(() </span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">-&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> {</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    try</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> {</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        Thread</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">sleep</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1000</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    } </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">catch</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">InterruptedException</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> e</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;Thread was interrupted&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">})</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">t</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">start</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">t</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">interrupt</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 中断操作</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，<code>t.interrupt()</code> 会 <code>happens-before</code> <code>Thread.sleep()</code> 中的 <code>InterruptedException</code> 抛出。</p><h3 id="_3-happens-before-的应用场景" tabindex="-1"><a class="header-anchor" href="#_3-happens-before-的应用场景"><span>3. <code>happens-before</code> 的应用场景</span></a></h3><p>了解了 <code>happens-before</code> 规则后，我们可以在多线程编程中合理地设计同步机制。以下是一些实际应用场景：</p><h4 id="_1-共享变量的同步" tabindex="-1"><a class="header-anchor" href="#_1-共享变量的同步"><span>1. 共享变量的同步</span></a></h4><p>如果多个线程需要访问共享变量，使用 <code>volatile</code> 或者同步块（<code>synchronized</code>）来确保对共享变量的操作符合 <code>happens-before</code> 规则，从而避免出现线程间的数据不一致问题。</p><h4 id="_2-线程间通信" tabindex="-1"><a class="header-anchor" href="#_2-线程间通信"><span>2. 线程间通信</span></a></h4><p>使用 <code>wait()</code>、<code>notify()</code> 和 <code>notifyAll()</code> 等线程间通信机制时，<code>happens-before</code> 规则保证了线程在合适的时间点进入和退出等待状态，确保线程间的正确协作。</p><h4 id="_3-避免指令重排" tabindex="-1"><a class="header-anchor" href="#_3-避免指令重排"><span>3. 避免指令重排</span></a></h4><p>通过正确使用 <code>volatile</code> 和 <code>synchronized</code>，我们可以避免由于指令重排导致的逻辑错误。特别是在处理多个线程的写入和读取时，合理的使用这些同步机制可以确保顺序性。</p><h3 id="_4-总结" tabindex="-1"><a class="header-anchor" href="#_4-总结"><span>4. 总结</span></a></h3><p><code>happens-before</code> 是Java内存模型中的核心概念，它定义了多个操作之间的执行顺序，并保证了线程间的可见性、原子性和有序性。理解和运用 <code>happens-before</code> 规则可以帮助开发者编写线程安全的程序，避免数据竞争和同步错误。</p><ul><li><code>happens-before</code> 确保了操作顺序和内存一致性。</li><li>锁、<code>volatile</code>、线程启动等机制是确保 <code>happens-before</code> 规则正确实现的关键。</li><li>在多线程编程中，合理地利用这些规则可以有效避免并发问题，并提高程序的稳定性。</li></ul><p>掌握 <code>happens-before</code> 的基本原理和应用技巧是编写高效且正确的并发程序的基础。</p>',42)]))}]]),l=JSON.parse('{"path":"/Java/%E5%85%A5%E9%97%A8%E5%88%B0%E8%B5%B7%E9%A3%9E/31.%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/2.happens-before%E5%8E%9F%E5%88%99.html","title":"Java内存模型中的 happens-before 规则","lang":"zh-CN","frontmatter":{"gitInclude":[]},"headers":[{"level":3,"title":"1. happens-before 规则的基本解释","slug":"_1-happens-before-规则的基本解释","link":"#_1-happens-before-规则的基本解释","children":[]},{"level":3,"title":"2. happens-before 规则的具体实现","slug":"_2-happens-before-规则的具体实现","link":"#_2-happens-before-规则的具体实现","children":[]},{"level":3,"title":"3. happens-before 的应用场景","slug":"_3-happens-before-的应用场景","link":"#_3-happens-before-的应用场景","children":[]},{"level":3,"title":"4. 总结","slug":"_4-总结","link":"#_4-总结","children":[]}],"readingTime":{"minutes":4.67,"words":1401},"filePathRelative":"Java/入门到起飞/31.多线程/并发编程的艺术/2.happens-before原则.md","excerpt":"\\n<p>在Java多线程编程中，保证程序的正确性和一致性至关重要。Java内存模型（JMM）通过一系列规则来确保多线程环境下数据的一致性，其中最核心的概念之一就是 <code>happens-before</code> 关系。理解并正确运用 <code>happens-before</code> 规则是开发高效且正确的多线程程序的关键。</p>\\n<h4>什么是 <code>happens-before</code>？</h4>\\n<p><code>happens-before</code> 是Java内存模型中的一个关键概念，定义了两项操作之间的执行顺序关系。当我们说一个操作 \\"happens-before\\" 另一个操作时，意味着第一个操作的结果在第二个操作之前对所有线程可见，并且保证了前者的操作不会被重排到后者的后面。</p>"}')}}]);