"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[26923],{66262:(s,i)=>{i.A=(s,i)=>{const a=s.__vccOpts||s;for(const[s,n]of i)a[s]=n;return a}},3492:(s,i,a)=>{a.r(i),a.d(i,{comp:()=>l,data:()=>h});var n=a(20641);const e={},l=(0,a(66262).A)(e,[["render",function(s,i){return(0,n.uX)(),(0,n.CE)("div",null,i[0]||(i[0]=[(0,n.Fv)('<h1 id="☕-java-面试答题卡-锁的状态详解-偏向锁-→-轻量级锁-→-重量级锁" tabindex="-1"><a class="header-anchor" href="#☕-java-面试答题卡-锁的状态详解-偏向锁-→-轻量级锁-→-重量级锁"><span>☕ Java 面试答题卡：锁的状态详解（偏向锁 → 轻量级锁 → 重量级锁）</span></a></h1><h2 id="✅-1-背景-为什么锁有这么多-状态" tabindex="-1"><a class="header-anchor" href="#✅-1-背景-为什么锁有这么多-状态"><span>✅ 1. 背景：为什么锁有这么多“状态”？</span></a></h2><p>为了<strong>提高并发性能、减少线程切换的开销</strong>，JVM 从 JDK 1.6 开始引入了锁的多种状态： <strong>根据竞争情况自动升级（或降级）</strong>，实现从无锁到偏向锁、轻量级锁、重量级锁的渐进控制。</p><h2 id="✅-2-锁状态切换图" tabindex="-1"><a class="header-anchor" href="#✅-2-锁状态切换图"><span>✅ 2. 锁状态切换图</span></a></h2><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>无锁</span></span>\n<span class="line"><span> ↓</span></span>\n<span class="line"><span>偏向锁（Bias Lock）       ← 如果另一个线程竞争</span></span>\n<span class="line"><span> ↓                             ↑</span></span>\n<span class="line"><span>轻量级锁（Lightweight Lock）  ← 自旋失败或激烈竞争</span></span>\n<span class="line"><span> ↓</span></span>\n<span class="line"><span>重量级锁（Heavyweight Lock）</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="✅-3-锁状态一览表" tabindex="-1"><a class="header-anchor" href="#✅-3-锁状态一览表"><span>✅ 3. 锁状态一览表</span></a></h2><p>| 锁状态 | 是否加锁 | 是否阻塞 | 性能 | 适用场景 | | -- | -- | ---- | | -- | | 无锁 | 否 | 否 | ✅ 最高 | 单线程、不可共享对象 | | 偏向锁 | ✅ 加锁 | 否 | ✅ 很高 | 绝大多数时间由同一线程访问 | | 轻量级锁 | ✅ 加锁 | 否（自旋） | ⚠️ 中等 | 多线程竞争但冲突不频繁 | | 重量级锁 | ✅ 加锁 | ✅ 阻塞 | ❌ 最差 | 多线程激烈竞争 |</p><h2 id="🔍-4-各锁状态详解" tabindex="-1"><a class="header-anchor" href="#🔍-4-各锁状态详解"><span>🔍 4. 各锁状态详解</span></a></h2><h3 id="🔸-4-1-偏向锁-bias-lock" tabindex="-1"><a class="header-anchor" href="#🔸-4-1-偏向锁-bias-lock"><span>🔸 4.1 偏向锁（Bias Lock）</span></a></h3><h4 id="📌-定义" tabindex="-1"><a class="header-anchor" href="#📌-定义"><span>📌 定义：</span></a></h4><blockquote><p>偏向于<strong>第一个获取锁的线程</strong>，后续只要是同一个线程再次获得锁，不再执行加锁操作（连 CAS 都不做）。</p></blockquote><h4 id="⚙️-原理" tabindex="-1"><a class="header-anchor" href="#⚙️-原理"><span>⚙️ 原理：</span></a></h4><ul><li>将持有锁的线程 ID 写入对象头（Mark Word）</li><li>只要没有其他线程竞争，偏向锁状态不会改变</li></ul><h4 id="📈-特点" tabindex="-1"><a class="header-anchor" href="#📈-特点"><span>📈 特点：</span></a></h4><ul><li>无线程竞争时性能最优</li><li>适用于“<strong>线程独占访问</strong>”场景（如单线程操作集合）</li></ul><h4 id="🧠-注意" tabindex="-1"><a class="header-anchor" href="#🧠-注意"><span>🧠 注意：</span></a></h4><ul><li>默认 JVM 启动几秒后（4s）才启用偏向锁（通过 <code>-XX:BiasedLockingStartupDelay=0</code> 启用立即生效）</li></ul><h3 id="🔸4-2-轻量级锁-lightweight-lock" tabindex="-1"><a class="header-anchor" href="#🔸4-2-轻量级锁-lightweight-lock"><span>🔸4.2 轻量级锁（Lightweight Lock）</span></a></h3><h4 id="📌-定义-1" tabindex="-1"><a class="header-anchor" href="#📌-定义-1"><span>📌 定义：</span></a></h4><blockquote><p>线程尝试使用 <strong>CAS</strong> 将当前线程的锁记录插入对象头；如果成功，则获得锁；否则进入自旋。</p></blockquote><h4 id="⚙️-原理-1" tabindex="-1"><a class="header-anchor" href="#⚙️-原理-1"><span>⚙️ 原理：</span></a></h4><ul><li>使用线程栈中的锁记录（Lock Record）</li><li>用 CAS 竞争对象头中的 Mark Word 指针（将其替换为指向 Lock Record 的地址）</li></ul><h4 id="📈-特点-1" tabindex="-1"><a class="header-anchor" href="#📈-特点-1"><span>📈 特点：</span></a></h4><ul><li>避免了线程挂起和恢复的系统调用</li><li>多线程竞争但冲突短暂场景中性能较好</li><li>自旋是有限次的（默认 10 次）</li></ul><h4 id="🧠-自旋失败后-升级为重量级锁" tabindex="-1"><a class="header-anchor" href="#🧠-自旋失败后-升级为重量级锁"><span>🧠 自旋失败后，升级为重量级锁</span></a></h4><h3 id="🔸-4-3-重量级锁-heavyweight-lock" tabindex="-1"><a class="header-anchor" href="#🔸-4-3-重量级锁-heavyweight-lock"><span>🔸 4.3 重量级锁（Heavyweight Lock）</span></a></h3><h4 id="📌-定义-2" tabindex="-1"><a class="header-anchor" href="#📌-定义-2"><span>📌 定义：</span></a></h4><blockquote><p>如果自旋失败，说明竞争激烈，JVM 使用操作系统的 <strong>互斥锁（monitor）</strong> 机制，挂起其他线程。</p></blockquote><h4 id="⚙️-原理-2" tabindex="-1"><a class="header-anchor" href="#⚙️-原理-2"><span>⚙️ 原理：</span></a></h4><ul><li>使用 <code>ObjectMonitor</code>（重量级锁结构体）</li><li>被阻塞的线程挂起（由操作系统管理）</li><li>只有获得锁的线程才能运行</li></ul><h4 id="📉-特点" tabindex="-1"><a class="header-anchor" href="#📉-特点"><span>📉 特点：</span></a></h4><ul><li>会触发<strong>用户态到内核态切换</strong>（代价大）</li><li>阻塞与唤醒有上下文切换，性能差</li></ul><h3 id="🧠-4-4-用生活类比理解" tabindex="-1"><a class="header-anchor" href="#🧠-4-4-用生活类比理解"><span>🧠 4.4 用生活类比理解</span></a></h3><p>假设一个房间要被人使用：</p><ul><li><strong>无锁</strong>：没人要用，谁都可以自由进出；</li><li><strong>偏向锁</strong>：你一个人频繁使用，门上挂了你的名字，别人不会干扰你；</li><li><strong>轻量级锁</strong>：你在用，另一个人来了，在门口等你一下（自旋）；</li><li><strong>重量级锁</strong>：你还没出来，对方等不住了，叫物业来协调（线程挂起、调度）；</li></ul><h2 id="✅-5-如何查看对象当前的锁状态" tabindex="-1"><a class="header-anchor" href="#✅-5-如何查看对象当前的锁状态"><span>✅ 5. 如何查看对象当前的锁状态？</span></a></h2><p>可以使用 JDK 的 <code>jol</code> 工具（Java Object Layout）：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">import</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> org.openjdk.jol.info.ClassLayout</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> LockTest</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> main</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[] </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">args</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> throws</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Exception</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        Object</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> o</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> Object</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">ClassLayout</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">parseInstance</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(o).</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">toPrintable</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">());</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="✅-6-锁状态切换时机总结" tabindex="-1"><a class="header-anchor" href="#✅-6-锁状态切换时机总结"><span>✅ 6. 锁状态切换时机总结</span></a></h2><table><thead><tr><th>起始状态</th><th>触发条件</th><th>切换后状态</th></tr></thead><tbody><tr><td>无锁</td><td>synchronized 被调用</td><td>偏向锁</td></tr><tr><td>偏向锁</td><td>其他线程尝试竞争同一把锁</td><td>轻量级锁</td></tr><tr><td>轻量级锁</td><td>自旋失败（多线程竞争激烈）</td><td>重量级锁</td></tr><tr><td>重量级锁</td><td>无竞争（有可能回退）</td><td>❌ 不会降级</td></tr></tbody></table><h2 id="✅-7-面试常问问题模板-建议背诵" tabindex="-1"><a class="header-anchor" href="#✅-7-面试常问问题模板-建议背诵"><span>✅ 7. 面试常问问题模板（建议背诵）</span></a></h2><blockquote><p>在 JDK 1.6+ 中，synchronized 实现了多种锁优化机制，锁状态会根据线程竞争情况自动升级。起初是偏向锁（无竞争），如有多个线程尝试锁定，会升级为轻量级锁（自旋），若竞争严重则进一步升级为重量级锁（阻塞）。这种设计既保证了线程安全，又尽量减少了性能开销。</p></blockquote><h2 id="🎯-常见面试追问" tabindex="-1"><a class="header-anchor" href="#🎯-常见面试追问"><span>🎯 常见面试追问：</span></a></h2><h3 id="q1-偏向锁适合什么场景" tabindex="-1"><a class="header-anchor" href="#q1-偏向锁适合什么场景"><span>Q1：偏向锁适合什么场景？</span></a></h3><ul><li>单线程重复访问某个对象（如迭代集合）</li></ul><h3 id="q2-轻量级锁为什么比重量级锁快" tabindex="-1"><a class="header-anchor" href="#q2-轻量级锁为什么比重量级锁快"><span>Q2：轻量级锁为什么比重量级锁快？</span></a></h3><ul><li>避免了线程挂起、恢复的系统调用，使用自旋代替阻塞</li></ul><h3 id="q3-锁状态会降级吗" tabindex="-1"><a class="header-anchor" href="#q3-锁状态会降级吗"><span>Q3：锁状态会降级吗？</span></a></h3><ul><li>锁<strong>升级是单向不可逆</strong>的，不会自动降级（避免频繁切换带来性能抖动）</li></ul>',49)]))}]]),h=JSON.parse('{"path":"/Interview/%E9%9D%A2%E8%AF%95%E7%AD%94%E9%A2%98%E5%8D%A1/Java/%E9%94%81%E7%9A%84%E7%8A%B6%E6%80%81%E8%AF%A6%E8%A7%A3%EF%BC%88%E5%81%8F%E5%90%91%E9%94%81%20%E2%86%92%20%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%20%E2%86%92%20%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81%EF%BC%89.html","title":"☕ Java 面试答题卡：锁的状态详解（偏向锁 → 轻量级锁 → 重量级锁）","lang":"zh-CN","frontmatter":{"gitInclude":[]},"headers":[{"level":2,"title":"✅ 1. 背景：为什么锁有这么多“状态”？","slug":"✅-1-背景-为什么锁有这么多-状态","link":"#✅-1-背景-为什么锁有这么多-状态","children":[]},{"level":2,"title":"✅ 2. 锁状态切换图","slug":"✅-2-锁状态切换图","link":"#✅-2-锁状态切换图","children":[]},{"level":2,"title":"✅ 3. 锁状态一览表","slug":"✅-3-锁状态一览表","link":"#✅-3-锁状态一览表","children":[]},{"level":2,"title":"🔍 4. 各锁状态详解","slug":"🔍-4-各锁状态详解","link":"#🔍-4-各锁状态详解","children":[{"level":3,"title":"🔸 4.1 偏向锁（Bias Lock）","slug":"🔸-4-1-偏向锁-bias-lock","link":"#🔸-4-1-偏向锁-bias-lock","children":[]},{"level":3,"title":"🔸4.2 轻量级锁（Lightweight Lock）","slug":"🔸4-2-轻量级锁-lightweight-lock","link":"#🔸4-2-轻量级锁-lightweight-lock","children":[]},{"level":3,"title":"🔸 4.3 重量级锁（Heavyweight Lock）","slug":"🔸-4-3-重量级锁-heavyweight-lock","link":"#🔸-4-3-重量级锁-heavyweight-lock","children":[]},{"level":3,"title":"🧠 4.4 用生活类比理解","slug":"🧠-4-4-用生活类比理解","link":"#🧠-4-4-用生活类比理解","children":[]}]},{"level":2,"title":"✅ 5. 如何查看对象当前的锁状态？","slug":"✅-5-如何查看对象当前的锁状态","link":"#✅-5-如何查看对象当前的锁状态","children":[]},{"level":2,"title":"✅ 6. 锁状态切换时机总结","slug":"✅-6-锁状态切换时机总结","link":"#✅-6-锁状态切换时机总结","children":[]},{"level":2,"title":"✅ 7. 面试常问问题模板（建议背诵）","slug":"✅-7-面试常问问题模板-建议背诵","link":"#✅-7-面试常问问题模板-建议背诵","children":[]},{"level":2,"title":"🎯 常见面试追问：","slug":"🎯-常见面试追问","link":"#🎯-常见面试追问","children":[{"level":3,"title":"Q1：偏向锁适合什么场景？","slug":"q1-偏向锁适合什么场景","link":"#q1-偏向锁适合什么场景","children":[]},{"level":3,"title":"Q2：轻量级锁为什么比重量级锁快？","slug":"q2-轻量级锁为什么比重量级锁快","link":"#q2-轻量级锁为什么比重量级锁快","children":[]},{"level":3,"title":"Q3：锁状态会降级吗？","slug":"q3-锁状态会降级吗","link":"#q3-锁状态会降级吗","children":[]}]}],"readingTime":{"minutes":3.68,"words":1105},"filePathRelative":"Interview/面试答题卡/Java/锁的状态详解（偏向锁 → 轻量级锁 → 重量级锁）.md","excerpt":"\\n<h2>✅ 1. 背景：为什么锁有这么多“状态”？</h2>\\n<p>为了<strong>提高并发性能、减少线程切换的开销</strong>，JVM 从 JDK 1.6 开始引入了锁的多种状态：\\n<strong>根据竞争情况自动升级（或降级）</strong>，实现从无锁到偏向锁、轻量级锁、重量级锁的渐进控制。</p>\\n<h2>✅ 2. 锁状态切换图</h2>\\n<div class=\\"language- line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"\\" data-title=\\"\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span>无锁</span></span>\\n<span class=\\"line\\"><span> ↓</span></span>\\n<span class=\\"line\\"><span>偏向锁（Bias Lock）       ← 如果另一个线程竞争</span></span>\\n<span class=\\"line\\"><span> ↓                             ↑</span></span>\\n<span class=\\"line\\"><span>轻量级锁（Lightweight Lock）  ← 自旋失败或激烈竞争</span></span>\\n<span class=\\"line\\"><span> ↓</span></span>\\n<span class=\\"line\\"><span>重量级锁（Heavyweight Lock）</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>"}')}}]);