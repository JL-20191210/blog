"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[32363],{66262:(i,s)=>{s.A=(i,s)=>{const a=i.__vccOpts||i;for(const[i,n]of s)a[i]=n;return a}},83551:(i,s,a)=>{a.r(s),a.d(s,{comp:()=>d,data:()=>r});var n=a(20641);const e=a.p+"assets/img/1755143474285-560cfb2e-dd30-4187-8611-1b942f2ae651.0e965911.webp",l=a.p+"assets/img/1755159684087-da84621f-2a6b-4c81-8712-e1c0ceccb612.55934971.webp",t=a.p+"assets/img/1755159684080-bd67ad30-7048-4199-b803-0c2a4dfbb5d1.fcc2f135.png",p={},d=(0,a(66262).A)(p,[["render",function(i,s){return(0,n.uX)(),(0,n.CE)("div",null,s[0]||(s[0]=[(0,n.Fv)('<h1 id="redis面试题" tabindex="-1"><a class="header-anchor" href="#redis面试题"><span>Redis面试题</span></a></h1><h2 id="数据结构" tabindex="-1"><a class="header-anchor" href="#数据结构"><span>数据结构</span></a></h2><h3 id="_1-讲一下redis底层的数据结构" tabindex="-1"><a class="header-anchor" href="#_1-讲一下redis底层的数据结构"><span>1.讲一下Redis底层的数据结构</span></a></h3><p>Redis 提供了丰富的数据类型，常见的有五种数据类型：<strong>String（字符串），Hash（哈希），List（列表），Set（集合）、Zset（有序集合）</strong>。</p><figure><img src="'+e+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>随着 Redis 版本的更新，后面又支持了四种数据类型：<strong>BitMap（2.2 版新增）、HyperLogLog（2.8 版新增）、GEO（3.2 版新增）、Stream（5.0 版新增)</strong>。</p><blockquote><p>Redis 五种数据类型的应用场景：</p></blockquote><ul><li>String 类型的应用场景：缓存对象、常规计数、分布式锁、共享 session 信息等。</li><li>List 类型的应用场景：消息队列（但是有两个问题：1. 生产者需要自行实现全局唯一 ID；2. 不能以消费组形式消费数据）等。</li><li>Hash 类型：缓存对象、购物车等。</li><li>Set 类型：聚合计算（并集、交集、差集）场景，比如点赞、共同关注、抽奖活动等。</li><li>Zset 类型：排序场景，比如排行榜、电话和姓名排序等。</li></ul><blockquote><p>Redis 后续版本又支持四种数据类型，它们的应用场景如下：</p></blockquote><ul><li>BitMap（2.2 版新增）：二值状态统计的场景，比如签到、判断用户登陆状态、连续签到用户总数等；</li><li>HyperLogLog（2.8 版新增）：海量数据基数统计的场景，比如百万级网页 UV 计数等；</li><li>GEO（3.2 版新增）：存储地理位置信息的场景，比如滴滴叫车；</li><li>Stream（5.0 版新增）：消息队列，相比于基于 List 类型实现的消息队列，有这两个特有的特性：自动生成全局唯一消息ID，支持以消费组形式消费数据。</li></ul><h3 id="_2-zset用过吗" tabindex="-1"><a class="header-anchor" href="#_2-zset用过吗"><span>2.ZSet用过吗</span></a></h3><p>用过 zset 实现排行榜的功能。以博文点赞排名为例，小林发表了五篇博文，分别获得赞为 200、40、100、50、150。</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># arcticle:1 文章获得了200个赞</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt; ZADD user:xiaolin:ranking 200 arcticle:1</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">integer</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">1</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># arcticle:2 文章获得了40个赞</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt; ZADD user:xiaolin:ranking 40 arcticle:2</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">integer</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">1</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># arcticle:3 文章获得了100个赞</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt; ZADD user:xiaolin:ranking 100 arcticle:3</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">integer</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">1</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># arcticle:4 文章获得了50个赞</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt; ZADD user:xiaolin:ranking 50 arcticle:4</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">integer</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">1</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># arcticle:5 文章获得了150个赞</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt; ZADD user:xiaolin:ranking 150 arcticle:5</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">integer</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">1</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>文章 arcticle:4 新增一个赞，可以使用 ZINCRBY 命令（为有序集合key中元素member的分值加上increment）：</p><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" data-title="plain" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>&gt; ZINCRBY user:xiaolin:ranking 1 arcticle:4</span></span>\n<span class="line"><span>&quot;51&quot;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>查看某篇文章的赞数，可以使用 ZSCORE 命令（返回有序集合key中元素个数）：</p><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" data-title="plain" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>&gt; ZSCORE user:xiaolin:ranking arcticle:4</span></span>\n<span class="line"><span>&quot;50&quot;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>5</p><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" data-title="plain" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span># WITHSCORES 表示把 score 也显示出来</span></span>\n<span class="line"><span>&gt; ZREVRANGE user:xiaolin:ranking 0 2 WITHSCORES</span></span>\n<span class="line"><span>1) &quot;arcticle:1&quot;</span></span>\n<span class="line"><span>2) &quot;200&quot;</span></span>\n<span class="line"><span>3) &quot;arcticle:5&quot;</span></span>\n<span class="line"><span>4) &quot;150&quot;</span></span>\n<span class="line"><span>5) &quot;arcticle:3&quot;</span></span>\n<span class="line"><span>6) &quot;100&quot;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>获取小林 100 赞到 200 赞的文章，可以使用 ZRANGEBYSCORE 命令（返回有序集合中指定分数区间内的成员，分数由低到高排序）：</p><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" data-title="plain" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>&gt; ZRANGEBYSCORE user:xiaolin:ranking 100 200 WITHSCORES</span></span>\n<span class="line"><span>1) &quot;arcticle:3&quot;</span></span>\n<span class="line"><span>2) &quot;100&quot;</span></span>\n<span class="line"><span>3) &quot;arcticle:5&quot;</span></span>\n<span class="line"><span>4) &quot;150&quot;</span></span>\n<span class="line"><span>5) &quot;arcticle:1&quot;</span></span>\n<span class="line"><span>6) &quot;200&quot;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-zset-底层是怎么实现的" tabindex="-1"><a class="header-anchor" href="#_3-zset-底层是怎么实现的"><span>3.Zset 底层是怎么实现的？</span></a></h3><p>Zset 类型的底层数据结构是由<strong>压缩列表或跳表</strong>实现的：</p><ul><li>如果有序集合的元素个数小于 128 个，并且每个元素的值小于 64 字节时，Redis 会使用<strong>压缩列表</strong>作为 Zset 类型的底层数据结构；</li><li>如果有序集合的元素不满足上面的条件，Redis 会使用<strong>跳表</strong>作为 Zset 类型的底层数据结构；</li></ul><p>**在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了。</p><h3 id="_4-跳表是怎么实现的" tabindex="-1"><a class="header-anchor" href="#_4-跳表是怎么实现的"><span>4.跳表是怎么实现的？</span></a></h3><p>链表在查找元素的时候，因为需要逐一查找，所以查询效率非常低，时间复杂度是O(N)，于是就出现了跳表。<strong>跳表是在链表基础上改进过来的，实现了一种「多层」的有序链表</strong>，这样的好处是能快读定位数据。那跳表长什么样呢？我这里举个例子，下图展示了一个层级为 3 的跳表。</p><figure><img src="'+l+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>图中头节点有 L0~L2 三个头指针，分别指向了不同层级的节点，然后每个层级的节点都通过指针连接起来：</p><ul><li>L0 层级共有 5 个节点，分别是节点1、2、3、4、5；</li><li>L1 层级共有 3 个节点，分别是节点 2、3、5；</li><li>L2 层级只有 1 个节点，也就是节点 3 。</li></ul><p>如果我们要在链表中查找节点 4 这个元素，只能从头开始遍历链表，需要查找 4 次，而使用了跳表后，只需要查找 2 次就能定位到节点 4，因为可以在头节点直接从 L2 层级跳到节点 3，然后再往前遍历找到节点 4。可以看到，这个查找过程就是在多个层级上跳来跳去，最后定位到元素。当数据量很大时，跳表的查找复杂度就是 O(logN)。那跳表节点是怎么实现多层级的呢？这就需要看「跳表节点」的数据结构了，如下：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">typedef struct zskiplistNode {</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    //Zset 对象的元素值</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    sds ele</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    //元素权重值</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    double</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> score</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    //后向指针</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    struct zskiplistNode </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">backward</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">  </span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    //节点的level数组，保存每层上的前向指针和跨度</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    struct zskiplistLevel {</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">        struct zskiplistNode </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">forward</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">        unsigned </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">long</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> span</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    } level[]</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">} zskiplistNode</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Zset 对象要同时保存「元素」和「元素的权重」，对应到跳表节点结构里就是 <code>sds</code> 类型的 <code>ele</code> 变量和 double 类型的 score 变量。</p><blockquote><p><strong>元素值（member）</strong></p><ul><li>在 Redis 内部用 <strong><code>sds</code></strong>（simple dynamic string）类型存储。</li><li><code>sds ele;</code> 这个字段就是用来放这个元素值的。</li><li>例子：如果有一个 Zset 元素 <code>&quot;user:1001&quot;</code>，那它会保存在这个 <code>ele</code> 里。</li></ul><p><strong>元素的权重值（score）</strong></p><ul><li>在 Zset 中，每个元素都有一个排序用的分值（score）。</li><li>Redis 跳表的节点里用 <strong><code>double score;</code></strong> 保存这个分值。</li><li>例子：如果 <code>&quot;user:1001&quot;</code> 的 score 是 <code>99.5</code>，就放在这个 <code>score</code> 变量里。</li></ul></blockquote><p>每个跳表节点都有一个<strong>后向指针</strong>（struct zskiplistNode *backward），指向前一个节点，目的是为了方便从跳表的尾节点开始访问节点，这样倒序查找时很方便。</p><blockquote><p><strong>前向指针</strong>（<code>forward</code>）：指向下一个节点（从小到大方向）</p><p><strong>后向指针</strong>（<code>backward</code>）：指向上一个节点（从大到小方向）</p></blockquote><p>跳表是一个带有层级关系的链表，而且每一层级可以包含多个节点，每一个节点通过指针连接起来，实现这一特性就是靠跳表节点结构体中的<strong>zskiplistLevel 结构体类型的 level 数组</strong>。level 数组中的每一个元素代表跳表的一层，也就是由 zskiplistLevel 结构体表示，比如 leve[0] 就表示第一层，leve[1] 就表示第二层。zskiplistLevel 结构体里定义了「指向下一个跳表节点的指针」和「跨度」，跨度时用来记录两个节点之间的距离。比如，下面这张图，展示了各个节点的跨度。</p><figure><img src="'+t+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>第一眼看到跨度的时候，以为是遍历操作有关，实际上并没有任何关系，遍历操作只需要用前向指针（struct zskiplistNode *forward）就可以完成了。Redis <strong>跳表在创建节点的时候，随机生成每个节点的层数</strong>，并没有严格维持相邻两层的节点数量比例为 2 : 1 的情况。具体的做法是，<strong>跳表在创建节点时候，会生成范围为[0-1]的一个随机数，如果这个随机数小于 0.25（相当于概率 25%)，那么层数就增加 1 层，然后继续生成下一个随机数，直到随机数的结果大于 0.25 结束，最终确定该节点的层数</strong>。这样的做法，相当于每增加一层的概率不超过 25%，层数越高，概率越低，层高最大限制是 64。虽然我前面讲解跳表的时候，图中的跳表的「头节点」都是 3 层高，但是其实<strong>如果层高最大限制是 64，那么在创建跳表「头节点」的时候，就会直接创建 64 层高的头节点</strong>。</p><h3 id="_5-跳表是怎么设置层高的" tabindex="-1"><a class="header-anchor" href="#_5-跳表是怎么设置层高的"><span>5.跳表是怎么设置层高的？</span></a></h3><p>跳表在创建节点时候，会生成范围为[0-1]的一个随机数，如果这个随机数小于 0.25（相当于概率 25%），那么层数就增加 1 层，然后继续生成下一个随机数，直到随机数的结果大于 0.25 结束，最终确定该节点的层数。</p>',41)]))}]]),r=JSON.parse('{"path":"/Interview/Java/07-Redis%E9%9D%A2%E8%AF%95%E9%A2%98/7.Redis%E9%9D%A2%E8%AF%95%E9%A2%98.html","title":"Redis面试题","lang":"zh-CN","frontmatter":{"gitInclude":[]},"headers":[{"level":2,"title":"数据结构","slug":"数据结构","link":"#数据结构","children":[{"level":3,"title":"1.讲一下Redis底层的数据结构","slug":"_1-讲一下redis底层的数据结构","link":"#_1-讲一下redis底层的数据结构","children":[]},{"level":3,"title":"2.ZSet用过吗","slug":"_2-zset用过吗","link":"#_2-zset用过吗","children":[]},{"level":3,"title":"3.Zset 底层是怎么实现的？","slug":"_3-zset-底层是怎么实现的","link":"#_3-zset-底层是怎么实现的","children":[]},{"level":3,"title":"4.跳表是怎么实现的？","slug":"_4-跳表是怎么实现的","link":"#_4-跳表是怎么实现的","children":[]},{"level":3,"title":"5.跳表是怎么设置层高的？","slug":"_5-跳表是怎么设置层高的","link":"#_5-跳表是怎么设置层高的","children":[]}]}],"readingTime":{"minutes":7.1,"words":2129},"filePathRelative":"Interview/Java/07-Redis面试题/7.Redis面试题.md","excerpt":"\\n<h2>数据结构</h2>\\n<h3>1.讲一下Redis底层的数据结构</h3>\\n<p>Redis 提供了丰富的数据类型，常见的有五种数据类型：<strong>String（字符串），Hash（哈希），List（列表），Set（集合）、Zset（有序集合）</strong>。</p>\\n<figure><figcaption>img</figcaption></figure>\\n<p>随着 Redis 版本的更新，后面又支持了四种数据类型：<strong>BitMap（2.2 版新增）、HyperLogLog（2.8 版新增）、GEO（3.2 版新增）、Stream（5.0 版新增)</strong>。</p>"}')}}]);