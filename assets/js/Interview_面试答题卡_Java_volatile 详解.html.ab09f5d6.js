"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[98257],{66262:(i,s)=>{s.A=(i,s)=>{const a=i.__vccOpts||i;for(const[i,n]of s)a[i]=n;return a}},81219:(i,s,a)=>{a.r(s),a.d(s,{comp:()=>l,data:()=>e});var n=a(20641);const t={},l=(0,a(66262).A)(t,[["render",function(i,s){return(0,n.uX)(),(0,n.CE)("div",null,s[0]||(s[0]=[(0,n.Fv)('<h2 id="☕-java-面试答题卡-volatile-详解" tabindex="-1"><a class="header-anchor" href="#☕-java-面试答题卡-volatile-详解"><span>☕ Java 面试答题卡：<code>volatile</code> 详解</span></a></h2><h3 id="✅-1-基本概念" tabindex="-1"><a class="header-anchor" href="#✅-1-基本概念"><span>✅ 1. 基本概念</span></a></h3><blockquote><p><code>volatile</code> 是 Java 中的一个轻量级同步机制，用于<strong>修饰变量</strong>，确保对该变量的<strong>可见性</strong>与<strong>禁止指令重排序</strong>，但<strong>不保证原子性</strong>。</p></blockquote><hr><h3 id="✅-2-作用说明" tabindex="-1"><a class="header-anchor" href="#✅-2-作用说明"><span>✅ 2. 作用说明</span></a></h3><table><thead><tr><th>功能</th><th>说明</th></tr></thead><tbody><tr><td>可见性</td><td>一个线程对 <code>volatile</code> 变量的修改，对其他线程立即可见</td></tr><tr><td>禁止重排序</td><td>避免编译器和 CPU 对代码指令重排，从而防止执行顺序错乱（特别是双检锁 DCL）</td></tr><tr><td>非原子性</td><td>对变量的操作（如 i++）仍然不是原子的，需要借助 <code>AtomicXXX</code> 或锁同步</td></tr></tbody></table><hr><h3 id="✅-3-示例说明" tabindex="-1"><a class="header-anchor" href="#✅-3-示例说明"><span>✅ 3. 示例说明</span></a></h3><h4 id="🔹-3-1-可见性保证-没有-volatile" tabindex="-1"><a class="header-anchor" href="#🔹-3-1-可见性保证-没有-volatile"><span>🔹 3.1 可见性保证（没有 volatile）</span></a></h4><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">boolean</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> flag </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> true</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> Thread</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(() </span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">-&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> {</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    while</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (flag) {} </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 无限循环，主线程的修改不可见</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">})</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">start</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">Thread</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">sleep</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1000</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">flag </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> false</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 修改对子线程不可见，导致无法退出循环</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="🔹-3-2-加-volatile-修饰" tabindex="-1"><a class="header-anchor" href="#🔹-3-2-加-volatile-修饰"><span>🔹 3.2 加 volatile 修饰</span></a></h4><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">volatile</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> boolean</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> flag </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> true</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 保证修改立即对其他线程可见</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><hr><h3 id="✅-4-原理解析" tabindex="-1"><a class="header-anchor" href="#✅-4-原理解析"><span>✅ 4. 原理解析</span></a></h3><ul><li><code>volatile</code> 变量在写操作后，会强制将 <strong>工作内存中的值刷新到主内存</strong>。</li><li>在读操作前，会强制从 <strong>主内存读取最新的值</strong>。</li><li>使用了**内存屏障（Memory Barrier）**来实现这两个保证。</li></ul><hr><h3 id="✅-5-jmm-语义图-java-内存模型" tabindex="-1"><a class="header-anchor" href="#✅-5-jmm-语义图-java-内存模型"><span>✅ 5. JMM 语义图（Java 内存模型）</span></a></h3><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">线程A             主内存              线程B</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">  |</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">   写volatile变量 →  主内存 ← 读volatile变量 </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">|</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><hr><h3 id="✅-6-使用场景-典型" tabindex="-1"><a class="header-anchor" href="#✅-6-使用场景-典型"><span>✅ 6. 使用场景（典型）</span></a></h3><table><thead><tr><th>场景</th><th>是否适合用 volatile</th></tr></thead><tbody><tr><td>状态标志、开关控制</td><td>✅ 适合</td></tr><tr><td>双重检查锁（DCL）中的单例实例</td><td>✅ 适合</td></tr><tr><td>多线程计数器（如 i++）</td><td>❌ 不适合（需原子性）</td></tr><tr><td>复杂条件判断或数据结构共享</td><td>❌ 不适合</td></tr></tbody></table><hr><h3 id="✅-7-与-synchronized-对比" tabindex="-1"><a class="header-anchor" href="#✅-7-与-synchronized-对比"><span>✅ 7. 与 <code>synchronized</code> 对比</span></a></h3><table><thead><tr><th>特性</th><th><code>volatile</code></th><th><code>synchronized</code></th></tr></thead><tbody><tr><td>可见性</td><td>✅</td><td>✅</td></tr><tr><td>原子性</td><td>❌</td><td>✅</td></tr><tr><td>重排序禁止</td><td>✅</td><td>✅（通过进入和退出 monitor）</td></tr><tr><td>性能开销</td><td>小（无锁）</td><td>较大（加锁和上下文切换）</td></tr><tr><td>使用复杂性</td><td>简单（变量声明）</td><td>复杂（代码块或方法）</td></tr></tbody></table><hr><h3 id="✅-8-注意事项-限制" tabindex="-1"><a class="header-anchor" href="#✅-8-注意事项-限制"><span>✅ 8. 注意事项 / 限制</span></a></h3><ul><li><code>volatile</code> <strong>不能用于原子操作</strong>（如 i++、x = x + 1）</li><li><strong>数组引用</strong>可用 volatile 修饰，但不能保证数组内部元素可见性</li><li><code>volatile</code> 仅适用于 <strong>状态标志、配置开关等轻量同步场景</strong></li><li>不支持复合操作的同步，例如“先读后改再写”</li></ul><hr><h3 id="✅-9-双重检查锁-dcl-中的应用" tabindex="-1"><a class="header-anchor" href="#✅-9-双重检查锁-dcl-中的应用"><span>✅ 9. 双重检查锁（DCL）中的应用</span></a></h3><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Singleton</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> volatile</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Singleton</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> instance</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Singleton</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> getInstance</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (instance </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">==</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">            synchronized</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">Singleton</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">class</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">                if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (instance </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">==</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">                    instance </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> Singleton</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(); </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 禁止重排序，确保安全发布</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">                }</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">            }</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        }</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> instance;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果没有 <code>volatile</code>，可能出现<strong>指令重排</strong>，导致获取到未完全初始化的对象。</p><hr><h3 id="🎯-一句话总结-面试简答" tabindex="-1"><a class="header-anchor" href="#🎯-一句话总结-面试简答"><span>🎯 一句话总结（面试简答）</span></a></h3><blockquote><p><code>volatile</code> 用于保证变量的可见性和禁止指令重排序，适用于状态标志等轻量同步场景，但不保证原子性；复杂并发场景应使用 <code>synchronized</code> 或原子类。</p></blockquote>',34)]))}]]),e=JSON.parse('{"path":"/Interview/%E9%9D%A2%E8%AF%95%E7%AD%94%E9%A2%98%E5%8D%A1/Java/volatile%20%E8%AF%A6%E8%A7%A3.html","title":"","lang":"zh-CN","frontmatter":{"gitInclude":[]},"headers":[{"level":2,"title":"☕ Java 面试答题卡：volatile 详解","slug":"☕-java-面试答题卡-volatile-详解","link":"#☕-java-面试答题卡-volatile-详解","children":[{"level":3,"title":"✅ 1. 基本概念","slug":"✅-1-基本概念","link":"#✅-1-基本概念","children":[]},{"level":3,"title":"✅ 2. 作用说明","slug":"✅-2-作用说明","link":"#✅-2-作用说明","children":[]},{"level":3,"title":"✅ 3. 示例说明","slug":"✅-3-示例说明","link":"#✅-3-示例说明","children":[]},{"level":3,"title":"✅ 4. 原理解析","slug":"✅-4-原理解析","link":"#✅-4-原理解析","children":[]},{"level":3,"title":"✅ 5. JMM 语义图（Java 内存模型）","slug":"✅-5-jmm-语义图-java-内存模型","link":"#✅-5-jmm-语义图-java-内存模型","children":[]},{"level":3,"title":"✅ 6. 使用场景（典型）","slug":"✅-6-使用场景-典型","link":"#✅-6-使用场景-典型","children":[]},{"level":3,"title":"✅ 7. 与 synchronized 对比","slug":"✅-7-与-synchronized-对比","link":"#✅-7-与-synchronized-对比","children":[]},{"level":3,"title":"✅ 8. 注意事项 / 限制","slug":"✅-8-注意事项-限制","link":"#✅-8-注意事项-限制","children":[]},{"level":3,"title":"✅ 9. 双重检查锁（DCL）中的应用","slug":"✅-9-双重检查锁-dcl-中的应用","link":"#✅-9-双重检查锁-dcl-中的应用","children":[]},{"level":3,"title":"🎯 一句话总结（面试简答）","slug":"🎯-一句话总结-面试简答","link":"#🎯-一句话总结-面试简答","children":[]}]}],"readingTime":{"minutes":2.3,"words":690},"filePathRelative":"Interview/面试答题卡/Java/volatile 详解.md","excerpt":"<h2>☕ Java 面试答题卡：<code>volatile</code> 详解</h2>\\n<h3>✅ 1. 基本概念</h3>\\n<blockquote>\\n<p><code>volatile</code> 是 Java 中的一个轻量级同步机制，用于<strong>修饰变量</strong>，确保对该变量的<strong>可见性</strong>与<strong>禁止指令重排序</strong>，但<strong>不保证原子性</strong>。</p>\\n</blockquote>\\n<hr>\\n<h3>✅ 2. 作用说明</h3>\\n<table>\\n<thead>\\n<tr>\\n<th>功能</th>\\n<th>说明</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>可见性</td>\\n<td>一个线程对 <code>volatile</code> 变量的修改，对其他线程立即可见</td>\\n</tr>\\n<tr>\\n<td>禁止重排序</td>\\n<td>避免编译器和 CPU 对代码指令重排，从而防止执行顺序错乱（特别是双检锁 DCL）</td>\\n</tr>\\n<tr>\\n<td>非原子性</td>\\n<td>对变量的操作（如 i++）仍然不是原子的，需要借助 <code>AtomicXXX</code> 或锁同步</td>\\n</tr>\\n</tbody>\\n</table>"}')}}]);