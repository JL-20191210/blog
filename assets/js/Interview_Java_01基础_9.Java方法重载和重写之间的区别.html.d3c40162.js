"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[84982],{66262:(i,s)=>{s.A=(i,s)=>{const a=i.__vccOpts||i;for(const[i,l]of s)a[i]=l;return a}},92432:(i,s,a)=>{a.r(s),a.d(s,{comp:()=>e,data:()=>t});var l=a(20641);const n={},e=(0,a(66262).A)(n,[["render",function(i,s){return(0,l.uX)(),(0,l.CE)("div",null,[s[0]||(s[0]=(0,l.Lk)("h1",{id:"_9-java方法重载和重写之间的区别",tabindex:"-1"},[(0,l.Lk)("a",{class:"header-anchor",href:"#_9-java方法重载和重写之间的区别"},[(0,l.Lk)("span",null,"9.Java方法重载和重写之间的区别")])],-1)),s[1]||(s[1]=(0,l.Lk)("h3",{id:"_0-a",tabindex:"-1"},[(0,l.Lk)("a",{class:"header-anchor",href:"#_0-a"},[(0,l.Lk)("span",null,"0. A")])],-1)),(0,l.Q3)(" more "),s[2]||(s[2]=(0,l.Fv)('<div class="hint-container important"><p class="hint-container-title">重要</p><p><strong>面试官：</strong> &quot;能简单说明一下Java中的方法重载和方法重写有什么区别吗？&quot;</p><hr><p><strong>你：</strong> “好的，方法重载和方法重写都是Java中实现多态的两种常见方式。它们虽然有相似之处，但实际上有一些关键的区别。</p><p>首先，<strong>方法重载</strong>（Overloading）是指在同一个类中，多个方法有相同的名字，但参数列表不同。这些方法可以有不同的参数类型、参数个数或者参数顺序，但它们的方法名必须相同。需要注意的是，返回类型和访问修饰符不参与方法重载的判断。</p><p>举个例子，假设我们有一个<code>print</code>方法，它可以打印不同类型的内容。我们可以通过改变参数类型或数量来创建多个<code>print</code>方法：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> print</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> a) {}</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> print</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">double</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> a) {}</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> print</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> a) {}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这种情况下，编译器会根据调用时传递的参数来选择哪个方法。</p><p>方法重载是发生在<strong>编译时</strong>，也就是编译器在编译阶段决定应该调用哪个版本的方法，这种机制叫做<code>静态绑定</code>。</p><p>而<strong>方法重写</strong>（Overriding）是指子类对父类已经存在的方法进行重新实现，方法签名完全相同，包括方法名、参数列表和返回类型。在子类中重写父类方法时，子类会改变父类方法的行为，以适应自己的需要。</p><p>例如，父类和子类的<code>display</code>方法：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Parent</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> display</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;Parent display&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Child</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> extends</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Parent</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    @</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Override</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> display</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;Child display&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里，子类通过重写父类的<code>display</code>方法来改变它的行为。</p><p>方法重写是发生在<strong>运行时</strong>，也就是JVM根据对象的实际类型来决定调用哪个版本的方法，这种机制叫做<code>动态绑定</code>。</p><p>总结一下：</p><ol><li><strong>方法重载</strong>：方法名相同，参数列表不同，可以发生在同一类中。它是在编译时根据参数选择具体方法。</li><li><strong>方法重写</strong>：子类重新定义父类的方法，方法签名完全相同，发生在继承关系中，且是在运行时决定调用哪一个版本的方法。</li></ol><p>在方法重载中，返回类型和访问权限是可以不同的，而在方法重写中，返回类型必须与父类相同或是其子类型（即协变返回类型），访问权限也不能低于父类。</p></div><hr><h3 id="_1-方法重载-overloading" tabindex="-1"><a class="header-anchor" href="#_1-方法重载-overloading"><span>1. <strong>方法重载（Overloading）</strong></span></a></h3><ul><li><p><strong>定义</strong>：在同一个类中，方法名相同，<strong>参数列表不同</strong>（数量、类型或顺序不同）。</p></li><li><p><strong>发生时机</strong>：<strong>编译时</strong>（编译器根据传入的参数类型选择方法）。</p></li><li><p><strong>关键特征</strong>：</p><ul><li>方法名相同。</li><li>参数类型、个数或顺序不同。</li><li>返回类型和访问修饰符不影响重载。</li></ul></li><li><p><strong>例子</strong>：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> print</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> a) {}</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> print</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">double</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> a) {}</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> print</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> a) {}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h3 id="_2-方法重写-overriding" tabindex="-1"><a class="header-anchor" href="#_2-方法重写-overriding"><span>2. <strong>方法重写（Overriding）</strong></span></a></h3><ul><li><strong>定义</strong>：子类重新实现父类已经存在的方法，<strong>方法签名完全相同</strong>。</li><li><strong>发生时机</strong>：<strong>运行时</strong>（JVM根据对象的实际类型决定调用哪个方法）。</li><li><strong>关键特征</strong>： <ul><li>方法名和参数列表完全相同。</li><li>发生在继承关系中，子类可以改变父类方法的行为。</li><li>返回类型必须相同或是父类返回类型的子类型（协变返回类型）。</li><li>访问权限不能低于父类。</li></ul></li><li><strong>例子</strong>：<div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Parent</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> display</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {}</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Child</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> extends</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Parent</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    @</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Override</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> display</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {}</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 重写父类方法</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><hr><h3 id="_3-总结" tabindex="-1"><a class="header-anchor" href="#_3-总结"><span>3. <strong>总结</strong>：</span></a></h3><ol><li><strong>方法重载</strong>：同名方法，参数不同，编译时决定调用哪个方法。</li><li><strong>方法重写</strong>：子类重新定义父类的方法，方法签名完全相同，运行时决定调用哪个方法。</li></ol><p><strong>方法重载</strong>是<strong>编译时</strong>根据参数选择，而<strong>方法重写</strong>是<strong>运行时</strong>根据实际对象类型选择</p><hr><h3 id="_4-扩展" tabindex="-1"><a class="header-anchor" href="#_4-扩展"><span>4. 扩展</span></a></h3><h4 id="方法重载-overloading-注意点" tabindex="-1"><a class="header-anchor" href="#方法重载-overloading-注意点"><span><strong>方法重载（Overloading）注意点</strong></span></a></h4><ol><li><p><strong>参数必须不同</strong>：</p><ul><li>重载方法必须在参数数量、类型或顺序上有所不同。如果参数完全相同，则会报编译错误。</li><li>返回类型不能作为区分重载方法的依据。</li></ul></li><li><p><strong>不影响继承</strong>：</p><ul><li>重载发生在同一个类或子类中，但不涉及父子类关系。即使是继承了父类的方法，子类也可以通过方法重载来定义不同版本的同名方法。</li></ul></li><li><p><strong>访问修饰符不影响重载</strong>：</p><ul><li>方法的访问修饰符（如<code>public</code>、<code>private</code>、<code>protected</code>）不影响方法重载，因此不同的访问修饰符可以应用于重载的方法。</li></ul></li><li><p><strong>返回类型无关</strong>：</p><ul><li>返回类型与参数列表的不同并不能构成重载。换句话说，<strong>只有参数列表的差异才是区分重载的关键</strong>。</li></ul></li><li><p><strong>构造方法重载</strong>：</p><ul><li>构造方法也可以进行重载。通过不同的参数列表，可以定义多个构造函数。</li></ul></li></ol><h4 id="方法重写-overriding-注意点" tabindex="-1"><a class="header-anchor" href="#方法重写-overriding-注意点"><span><strong>方法重写（Overriding）注意点</strong></span></a></h4><ol><li><p><strong>方法签名完全相同</strong>：</p><ul><li>子类重写父类的方法时，<strong>方法名和参数列表必须完全相同</strong>，包括参数类型、个数和顺序。</li><li>返回类型必须相同，或者是父类返回类型的子类型（协变返回类型）。</li></ul></li><li><p><strong>访问权限</strong>：</p><ul><li>重写方法的访问修饰符<strong>不能低于父类方法</strong>的访问修饰符。例如，如果父类方法是<code>public</code>，子类的重写方法也必须是<code>public</code>，不能是<code>protected</code>或<code>private</code>。</li><li>你可以提高访问权限，比如将父类的<code>protected</code>方法重写为<code>public</code>，但不能降低权限。</li></ul></li><li><p><strong><code>@Override</code>注解</strong>：</p><ul><li>在重写方法时，使用<code>@Override</code>注解可以帮助编译器检查是否真正实现了方法重写。如果方法签名不正确，编译器会报错。</li></ul></li><li><p><strong>不能重写<code>final</code>、<code>static</code>或<code>private</code>方法</strong>：</p><ul><li><code>final</code>方法不能被重写，因为<code>final</code>方法表示不可修改。</li><li><code>static</code>方法属于类级别，不会参与实例对象的多态，因此无法重写。</li><li><code>private</code>方法无法被子类重写，因为它在父类中不可见。</li></ul></li><li><p><strong>父类方法的<code>super</code>调用</strong>：</p><ul><li>子类重写父类方法后，仍然可以通过<code>super</code>关键字调用父类的版本，通常用于在子类中扩展父类的行为。</li></ul></li></ol><h4 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span><strong>总结</strong></span></a></h4><ul><li><p><strong>重载</strong>：</p><ul><li>参数不同（数量、类型、顺序）。</li><li>同一类或继承关系内。</li><li>返回类型不影响。</li><li>无需考虑访问修饰符的限制。</li></ul></li><li><p><strong>重写</strong>：</p><ul><li>参数完全相同。</li><li>子类必须遵循父类的方法签名。</li><li>访问权限不能低于父类方法。</li><li><code>@Override</code>注解有助于检查。</li><li>无法重写<code>final</code>、<code>static</code>或<code>private</code>方法。</li></ul></li></ul>',18))])}]]),t=JSON.parse('{"path":"/Interview/Java/01%E5%9F%BA%E7%A1%80/9.Java%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB.html","title":"9.Java方法重载和重写之间的区别","lang":"zh-CN","frontmatter":{"icon":"fa-brands fa-java","date":"2025-01-09T00:00:00.000Z","category":["Java"],"tag":["必背"],"gitInclude":[]},"headers":[{"level":3,"title":"0. A","slug":"_0-a","link":"#_0-a","children":[]},{"level":3,"title":"1. 方法重载（Overloading）","slug":"_1-方法重载-overloading","link":"#_1-方法重载-overloading","children":[]},{"level":3,"title":"2. 方法重写（Overriding）","slug":"_2-方法重写-overriding","link":"#_2-方法重写-overriding","children":[]},{"level":3,"title":"3. 总结：","slug":"_3-总结","link":"#_3-总结","children":[]},{"level":3,"title":"4. 扩展","slug":"_4-扩展","link":"#_4-扩展","children":[]}],"readingTime":{"minutes":5.77,"words":1730},"filePathRelative":"Interview/Java/01基础/9.Java方法重载和重写之间的区别.md","localizedDate":"2025年1月9日","excerpt":"\\n<h3>0. A</h3>\\n"}')}}]);