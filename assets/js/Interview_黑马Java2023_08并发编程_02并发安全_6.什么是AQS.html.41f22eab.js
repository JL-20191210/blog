"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[5665],{66262:(t,i)=>{i.A=(t,i)=>{const e=t.__vccOpts||t;for(const[t,a]of i)e[t]=a;return e}},9641:(t,i,e)=>{e.r(i),e.d(i,{comp:()=>r,data:()=>o});var a=e(20641);const n=e.p+"assets/img/wps1.ec463543.png",l=e.p+"assets/img/wps2.f02bb5c4.jpg",s=e.p+"assets/img/wps3.83db7c8b.jpg",p={},r=(0,e(66262).A)(p,[["render",function(t,i){return(0,a.uX)(),(0,a.CE)("div",null,i[0]||(i[0]=[(0,a.Fv)('<h1 id="_6-什么是aqs" tabindex="-1"><a class="header-anchor" href="#_6-什么是aqs"><span>6.什么是AQS？</span></a></h1><blockquote><p>难易程度：☆☆☆</p><p>出现频率：☆☆☆</p></blockquote><div class="hint-container important"><p class="hint-container-title">重要</p><ul><li>AQS是多线程中的队列同步器。是一种锁机制，它是做为一个基础框架使用的,像ReentrantLock、Semaphore都是基于AQS实现的</li><li>AQS内部维护了一个先进先出的双向队列，队列中存储的排队的线程</li><li>在AQS内部还有一个属性state,这个state就相当于是一个资源，默认是0(无锁状态)，如果队列中的有一个线程修改成功了state为1，则当前线程就相等于获取了资源</li><li>在对state修改的时候使用的cas操作，保证多个线程修改的情况下原子性</li></ul></div><hr><h2 id="_1-概述" tabindex="-1"><a class="header-anchor" href="#_1-概述"><span>1.<strong>概述</strong></span></a></h2><p>全称是 AbstractQueuedSynchronizer，是阻塞式锁和相关的同步器工具的框架，它是构建锁或者其他同步组件的基础框架</p><p>AQS与Synchronized的区别</p><figure><img src="'+n+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p><strong>点击图片可查看完整电子表格</strong></p><p>AQS常见的实现类</p><ul><li><p>ReentrantLock 阻塞式锁</p></li><li><p>Semaphore 信号量</p></li><li><p>CountDownLatch 倒计时锁</p></li></ul><h2 id="_2-工作机制" tabindex="-1"><a class="header-anchor" href="#_2-工作机制"><span>2.<strong>工作机制</strong></span></a></h2><ul><li><p>在AQS中维护了一个使用了volatile修饰的state属性来表示资源的状态，0表示无锁，1表示有锁</p></li><li><p>提供了基于 FIFO 的等待队列，类似于 Monitor 的 EntryList</p></li><li><p>条件变量来实现等待、唤醒机制，支持多个条件变量，类似于 Monitor 的 WaitSet</p></li></ul><figure><img src="'+l+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><ul><li>线程0来了以后，去尝试修改state属性，如果发现state属性是0，就修改state状态为1，表示线程0抢锁成功•</li><li>线程1和线程2也会先尝试修改state属性，发现state的值已经是1了，有其他线程持有锁，它们都会到FIFO队列中进行等待</li><li>FIFO是一个双向队列，head属性表示头结点，tail表示尾结点</li></ul><p><strong>如果多个线程共同去抢这个资源是如何保证原子性的呢？</strong></p><figure><img src="'+s+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>在去修改state状态的时候，使用的cas自旋锁来保证原子性，确保只能有一个线程修改成功，修改失败的线程将会进入FIFO队列中等待</p><p><strong>AQS是公平锁吗，还是非公平锁？</strong></p><ul><li><p>新的线程与队列中的线程共同来抢资源，是非公平锁</p></li><li><p>新的线程到队列中等待，只让队列中的head线程获取锁，是公平锁</p></li></ul><p>比较典型的AQS实现类ReentrantLock，它默认就是非公平锁，新的线程与队列中的线程共同来抢资源</p>',21)]))}]]),o=JSON.parse('{"path":"/Interview/%E9%BB%91%E9%A9%ACJava2023/08%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/02%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8/6.%E4%BB%80%E4%B9%88%E6%98%AFAQS.html","title":"6.什么是AQS？","lang":"zh-CN","frontmatter":{"gitInclude":[]},"headers":[{"level":2,"title":"1.概述","slug":"_1-概述","link":"#_1-概述","children":[]},{"level":2,"title":"2.工作机制","slug":"_2-工作机制","link":"#_2-工作机制","children":[]}],"readingTime":{"minutes":2.11,"words":634},"filePathRelative":"Interview/黑马Java2023/08并发编程/02并发安全/6.什么是AQS.md","excerpt":"\\n<blockquote>\\n<p>难易程度：☆☆☆</p>\\n<p>出现频率：☆☆☆</p>\\n</blockquote>\\n<div class=\\"hint-container important\\">\\n<p class=\\"hint-container-title\\">重要</p>\\n<ul>\\n<li>AQS是多线程中的队列同步器。是一种锁机制，它是做为一个基础框架使用的,像ReentrantLock、Semaphore都是基于AQS实现的</li>\\n<li>AQS内部维护了一个先进先出的双向队列，队列中存储的排队的线程</li>\\n<li>在AQS内部还有一个属性state,这个state就相当于是一个资源，默认是0(无锁状态)，如果队列中的有一个线程修改成功了state为1，则当前线程就相等于获取了资源</li>\\n<li>在对state修改的时候使用的cas操作，保证多个线程修改的情况下原子性</li>\\n</ul>\\n</div>"}')}}]);