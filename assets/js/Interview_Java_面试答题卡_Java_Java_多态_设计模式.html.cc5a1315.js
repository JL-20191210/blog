"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[36945],{66262:(t,n)=>{n.A=(t,n)=>{const a=t.__vccOpts||t;for(const[t,e]of n)a[t]=e;return a}},35061:(t,n,a)=>{a.r(n),a.d(n,{comp:()=>l,data:()=>i});var e=a(20641);const d={},l=(0,a(66262).A)(d,[["render",function(t,n){return(0,e.uX)(),(0,e.CE)("div",null,n[0]||(n[0]=[(0,e.Fv)('<h1 id="☕java-面试答题卡-java-多态-设计模式" tabindex="-1"><a class="header-anchor" href="#☕java-面试答题卡-java-多态-设计模式"><span>☕Java 面试答题卡：Java 多态 + 设计模式</span></a></h1><hr><h2 id="_1️⃣-多态基础概念" tabindex="-1"><a class="header-anchor" href="#_1️⃣-多态基础概念"><span>1️⃣ 多态基础概念</span></a></h2><ul><li><strong>定义</strong>：同一个方法调用，在运行时可表现为不同的行为。</li><li><strong>实现方式</strong>：继承/接口 + 方法重写 + 父类引用指向子类对象 + 动态绑定（虚方法表）。</li><li><strong>解决的问题</strong>： <ul><li>调用方式统一，行为多样</li><li>实现开闭原则，增强扩展性</li><li>降低耦合，提高代码复用</li></ul></li></ul><hr><h2 id="_2️⃣-多态与常见设计模式" tabindex="-1"><a class="header-anchor" href="#_2️⃣-多态与常见设计模式"><span>2️⃣ 多态与常见设计模式</span></a></h2><table><thead><tr><th>设计模式</th><th>多态的体现方式</th><th>关键词</th></tr></thead><tbody><tr><td>策略模式</td><td>一组算法实现同一接口，运行时动态替换</td><td>interface + 多实现类</td></tr><tr><td>工厂模式</td><td>返回父类引用，实际是子类对象</td><td>多态返回值</td></tr><tr><td>模板方法模式</td><td>父类定义流程，子类重写细节步骤方法</td><td>抽象类 + 方法重写</td></tr><tr><td>状态模式</td><td>不同状态类实现同一接口，行为动态切换</td><td>上下文 + 多态</td></tr><tr><td>观察者模式</td><td>通知所有观察者，具体响应由各自决定</td><td>统一回调接口</td></tr><tr><td>责任链模式</td><td>各个处理器实现统一接口，动态传递处理请求</td><td>next.handle()</td></tr></tbody></table><hr><h2 id="_3️⃣-多态在-spring-中的应用场景" tabindex="-1"><a class="header-anchor" href="#_3️⃣-多态在-spring-中的应用场景"><span>3️⃣ 多态在 Spring 中的应用场景</span></a></h2><ul><li><strong>多实现类 Bean 注入</strong>：@Autowired + @Qualifier 或 <code>List&lt;Interface&gt;</code> 注入</li><li><strong>策略模式场景</strong>：如支付、消息推送，使用 ApplicationContext.getBeansOfType 结合接口实现</li><li><strong>自动装配 + 接口扩展</strong>：依赖注入只面向接口编程，Spring 自动注入最合适实现类</li><li><strong>Controller 接口参数绑定的多态性</strong>：通过继承/抽象类传参</li></ul><hr><h2 id="_4️⃣-面试答题模板" tabindex="-1"><a class="header-anchor" href="#_4️⃣-面试答题模板"><span>4️⃣ 面试答题模板</span></a></h2><h3 id="常规结构-概念-问题-示例-总结" tabindex="-1"><a class="header-anchor" href="#常规结构-概念-问题-示例-总结"><span>常规结构：概念 + 问题 + 示例 + 总结</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>多态是 Java 的核心特性之一，主要解决的是调用方式统一、行为多样化的问题。</span></span>\n<span class="line"><span>通过父类引用调用子类重写的方法，运行时动态决定行为，既保证了调用一致性，又提升了系统的扩展性。</span></span>\n<span class="line"><span>在策略模式中，不同实现类实现相同接口，业务可根据需要动态切换策略，是典型的多态应用。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="结尾总结句式" tabindex="-1"><a class="header-anchor" href="#结尾总结句式"><span>结尾总结句式：</span></a></h3><blockquote><p>多态不仅是面向对象的基础，更是众多设计模式落地的核心手段，使系统更灵活、更具维护性。</p></blockquote>',16)]))}]]),i=JSON.parse('{"path":"/Interview/Java/%E9%9D%A2%E8%AF%95%E7%AD%94%E9%A2%98%E5%8D%A1/Java/Java_%E5%A4%9A%E6%80%81_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html","title":"☕Java 面试答题卡：Java 多态 + 设计模式","lang":"zh-CN","frontmatter":{"gitInclude":[]},"headers":[{"level":2,"title":"1️⃣ 多态基础概念","slug":"_1️⃣-多态基础概念","link":"#_1️⃣-多态基础概念","children":[]},{"level":2,"title":"2️⃣ 多态与常见设计模式","slug":"_2️⃣-多态与常见设计模式","link":"#_2️⃣-多态与常见设计模式","children":[]},{"level":2,"title":"3️⃣ 多态在 Spring 中的应用场景","slug":"_3️⃣-多态在-spring-中的应用场景","link":"#_3️⃣-多态在-spring-中的应用场景","children":[]},{"level":2,"title":"4️⃣ 面试答题模板","slug":"_4️⃣-面试答题模板","link":"#_4️⃣-面试答题模板","children":[{"level":3,"title":"常规结构：概念 + 问题 + 示例 + 总结","slug":"常规结构-概念-问题-示例-总结","link":"#常规结构-概念-问题-示例-总结","children":[]},{"level":3,"title":"结尾总结句式：","slug":"结尾总结句式","link":"#结尾总结句式","children":[]}]}],"readingTime":{"minutes":1.87,"words":561},"filePathRelative":"Interview/Java/面试答题卡/Java/Java_多态_设计模式.md","excerpt":"\\n<hr>\\n<h2>1️⃣ 多态基础概念</h2>\\n<ul>\\n<li><strong>定义</strong>：同一个方法调用，在运行时可表现为不同的行为。</li>\\n<li><strong>实现方式</strong>：继承/接口 + 方法重写 + 父类引用指向子类对象 + 动态绑定（虚方法表）。</li>\\n<li><strong>解决的问题</strong>：\\n<ul>\\n<li>调用方式统一，行为多样</li>\\n<li>实现开闭原则，增强扩展性</li>\\n<li>降低耦合，提高代码复用</li>\\n</ul>\\n</li>\\n</ul>\\n<hr>\\n<h2>2️⃣ 多态与常见设计模式</h2>\\n<table>\\n<thead>\\n<tr>\\n<th>设计模式</th>\\n<th>多态的体现方式</th>\\n<th>关键词</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>策略模式</td>\\n<td>一组算法实现同一接口，运行时动态替换</td>\\n<td>interface + 多实现类</td>\\n</tr>\\n<tr>\\n<td>工厂模式</td>\\n<td>返回父类引用，实际是子类对象</td>\\n<td>多态返回值</td>\\n</tr>\\n<tr>\\n<td>模板方法模式</td>\\n<td>父类定义流程，子类重写细节步骤方法</td>\\n<td>抽象类 + 方法重写</td>\\n</tr>\\n<tr>\\n<td>状态模式</td>\\n<td>不同状态类实现同一接口，行为动态切换</td>\\n<td>上下文 + 多态</td>\\n</tr>\\n<tr>\\n<td>观察者模式</td>\\n<td>通知所有观察者，具体响应由各自决定</td>\\n<td>统一回调接口</td>\\n</tr>\\n<tr>\\n<td>责任链模式</td>\\n<td>各个处理器实现统一接口，动态传递处理请求</td>\\n<td>next.handle()</td>\\n</tr>\\n</tbody>\\n</table>"}')}}]);