"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[51593],{66262:(a,e)=>{e.A=(a,e)=>{const i=a.__vccOpts||a;for(const[a,s]of e)i[a]=s;return i}},27840:(a,e,i)=>{i.r(e),i.d(e,{comp:()=>g,data:()=>u});var s=i(20641);const t=i.p+"assets/img/641-17634736842159.ee6b22df.webp",d=i.p+"assets/img/640 (1).b0fe5148.webp",n=i.p+"assets/img/640 (2).5314bee1.webp",l=i.p+"assets/img/640 (3).52deee2d.webp",p=i.p+"assets/img/640.4ad6f48d.webp",c=i.p+"assets/img/640-176347370115411.042ef273.webp",r=i.p+"assets/img/640-176347371511314.43a049a3.webp",h=i.p+"assets/img/640-176347372722317.864c3371.webp",o={},g=(0,i(66262).A)(o,[["render",function(a,e){return(0,s.uX)(),(0,s.CE)("div",null,e[0]||(e[0]=[(0,s.Fv)('<h1 id="cpu飘高问题" tabindex="-1"><a class="header-anchor" href="#cpu飘高问题"><span>CPU飘高问题</span></a></h1><h2 id="使用-jstack-工具" tabindex="-1"><a class="header-anchor" href="#使用-jstack-工具"><span>使用 jstack 工具</span></a></h2><h3 id="第一步-使用-top-找到占用-cpu-最高的-java-进程" tabindex="-1"><a class="header-anchor" href="#第一步-使用-top-找到占用-cpu-最高的-java-进程"><span>第一步，使用 top 找到占用 CPU 最高的 Java 进程</span></a></h3><p>前面说了这一步，就是使用 Top 命令</p><figure><img src="'+t+'" alt="641" tabindex="0" loading="lazy"><figcaption>641</figcaption></figure><p>使用 <code>top</code>命令发现占用 CPU 99.7% 的线程是 Java 进程，进程 PID 为 <code>13731</code>。</p><h3 id="第二步-找到占用-cpu-最高的线程" tabindex="-1"><a class="header-anchor" href="#第二步-找到占用-cpu-最高的线程"><span>第二步，找到占用 CPU 最高的线程</span></a></h3><p>上一步用 <code>top</code>命令找到了那个 Java 进程。那一个进程中有那么多线程，不可能所有线程都一直占着 CPU 不放，这一步要做的就是揪出这个罪魁祸首，当然有可能不止一个。</p><p>接下来，还是用 <code>top</code>命令，只不过加一个参数<code>-Hp</code> ，就是下面这样</p><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" data-title="plain" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>top -Hp pid</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><code>H</code>参数表示要显示线程级别的信息，<code>p</code>则表示指定的pid，也就是进程id。代入前面得到的那个Java进程，完整的命令是这样的</p><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" data-title="plain" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>top -Hp 13731</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>执行之后，这个Java进程中占用线程占用 CPU 的情况就列出来了。</p><figure><img src="'+d+'" alt="640 (1)" tabindex="0" loading="lazy"><figcaption>640 (1)</figcaption></figure><p>可以看到占用 CPU 最高的那个线程 PID 为 <code>13756</code>。</p><h3 id="第三步-保存线程堆栈信息" tabindex="-1"><a class="header-anchor" href="#第三步-保存线程堆栈信息"><span>第三步，保存线程堆栈信息</span></a></h3><p>这就要用到 JDK 默认提供的一个工具了，叫做 jstack。当你安装了 JDK 之后，在 <code>bin</code>目录下会有一大堆内置的工具，<code>java</code>也是其中之一，还有另外我们可能比较熟悉的 <code>javac</code></p><figure><img src="'+n+'" alt="640 (2)" tabindex="0" loading="lazy"><figcaption>640 (2)</figcaption></figure><p>jstack 用于生成 Java 进程的线程快照（thread dump）。线程快照是一个关于 Java 进程中所有线程当前状态的快照，包括每个线程的堆栈信息。通过分析线程快照，可以了解 Java 进程中各个线程的运行状态、锁信息等。</p><p>我们用<code>jstack</code>的目的就是将那个占用 CPU 最高的线程的堆栈信息搞下来，然后进一步分析。使用命令 <code>jstack pid &gt; out.log</code>将某个进程的堆栈信息输出到 out.log文件中。</p><p>当前 Java 程序的所有线程信息都可以通过 <code>jstack</code>命令查看，我们用<code>jstack</code>命令将第一步找到的 Java 进程的线程栈保存下来。</p><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" data-title="plain" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>jstack 13731 &gt; thread_stack.log</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="第四步-在线程栈中查找最贵祸首的线程" tabindex="-1"><a class="header-anchor" href="#第四步-在线程栈中查找最贵祸首的线程"><span>第四步，在线程栈中查找最贵祸首的线程</span></a></h3><p>第二步已经找到了这个罪魁祸首的线程 PID 是 <code>13756</code>。</p><p>然后我们将 <code>13756</code>转换为 16 进制的，可以用在线进制转换的网站直接转换，比如 https://tool.oschina.net/hexconvert 这个，转换结果为 <code>0x35bc</code>。</p><p>最后，我们在线程栈中，也就是上一步保存的那个 thread_stack.log 文件，在里面查找这个16进制的线程 id （<code>0x35bc</code>）。</p><figure><img src="'+l+'" alt="640 (3)" tabindex="0" loading="lazy"><figcaption>640 (3)</figcaption></figure><p>然后，我么能看到了我们需要的线程名称、线程状态，哪个方法的哪一行代码消耗了最多的 CPU 都很清楚了。</p><h2 id="第二种-arthas" tabindex="-1"><a class="header-anchor" href="#第二种-arthas"><span>第二种，Arthas</span></a></h2><p>Arthas 是阿里开源的一款线上监控诊断产品，通过全局视角实时查看应用 load、内存、gc、线程的状态信息，并能在不修改应用代码的情况下，对业务问题进行诊断，包括查看方法调用的出入参、异常，监测方法执行耗时，类加载信息等，大大提升线上问题排查效率。</p><p>用 Arthas 查找占用 CPU 最高的方法只是一个开胃小菜，除此之外，它最大的用途是在不改代码、不重启服务的情况下对程序进行动态监控。如果你碰到了线上诡异问题，一定要用 Arthas 尝试找一找问题，开阔一下眼界。</p><p>好了，更多的功能到官网 https://arthas.aliyun.com/ 了解吧，接下来就将一下如何用 Arthas 达到前面用 jstack 同样的目的。</p><h3 id="安装-arthas" tabindex="-1"><a class="header-anchor" href="#安装-arthas"><span>安装 Arthas</span></a></h3><p>当然了，要使用 Arthas，你就必须先把它安装到你的目标服务器上，也就是那个出问题的Java服务所在的服务器。</p><p>下载 jar 包</p><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" data-title="plain" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>curl -O https://arthas.aliyun.com/arthas-boot.jar</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>启动 Arthas 服务</p><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" data-title="plain" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>java -jar arthas-boot.jar</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>启动之后，会列出当前这台服务器上的所有 Java 进程，然后你选择你要排查的那个服务即可。</p><figure><img src="'+p+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>然后出现 <code>arthas@</code>之后表示已经启动，并成功 attach 到目标进程上 。</p><p>然后可以输入命令 <code>dashboard</code>看一下实时面板，默认 5 秒刷新一次，在这个面板上能够看到线程、内存堆栈、GC和Runtime的基本信息。如果你用过 VisualVM 的话，就和那个基本一样。</p><figure><img src="'+c+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>好了，开始用 Arthas 找到导致 CPU 负载过高的问题吧。</p><h3 id="找到占用cpu最高的进程" tabindex="-1"><a class="header-anchor" href="#找到占用cpu最高的进程"><span>找到占用CPU最高的进程</span></a></h3><p>第一步，其实还是用 <code>top</code>命令找到占用 CPU 最高的进程，也就是 Arthas 启动时选择 attach 的那个 Java 进程。</p><p>然后 <code>java -jar arthas-boot.jar</code>启动Arthas，并attach 。</p><h3 id="找到占用-cpu-最高的线程" tabindex="-1"><a class="header-anchor" href="#找到占用-cpu-最高的线程"><span>找到占用 CPU 最高的线程</span></a></h3><p>执行 <code>thread</code>命令，这个命令会显示所有线程的信息，并且把CPU使用率高的线程排在前面。</p><p>这样，一眼就看出来了，第一个线程的 CPU 使用率高达 99% 了，就是它。</p><figure><img src="'+r+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><h3 id="查看堆栈信息" tabindex="-1"><a class="header-anchor" href="#查看堆栈信息"><span>查看堆栈信息</span></a></h3><p>使用 <code>thread ID</code> 获取堆栈信息，其实就是 <code>jstack pid</code>相同的作用。通过前一步看到这个线程的 ID 是18，然后执行 <code>thread 18</code></p><figure><img src="'+h+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><p>然后直接就看出来了出现问题的位置，<code>TestController.java</code>文件的 <code>high</code>方法的第23行。然后进代码看</p><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" data-title="plain" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>com.moonkite.wallpapermanage.controller.TestController.high(TestController.java:23)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这个方法是我故意写的死循环，真实情况当然没有这么明显，还需要针对具体代码认真分析。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><p>高 CPU 占用率这个问题是一种很常见也很典型的线上问题，排查方式只要按上述顺序记下来就基本上没什么问题。</p><p>其实还是推荐使用 Arthas，除了它确实功能非常多之外，还有就是在线上场景下，使用 <code>jstack</code>有时会碰到问题，如果这个线程已经忙的一点转圜的余地都没有了，<code>jstack</code>命令可能会执行失败。</p>',60)]))}]]),u=JSON.parse('{"path":"/Interview/Java/13-%E5%90%8A%E6%89%93%E9%9D%A2%E8%AF%95%E5%AE%98/%E3%80%90%E5%9C%BA%E6%99%AF%E3%80%91CPU%E9%A3%98%E9%AB%98%E9%97%AE%E9%A2%98.html","title":"CPU飘高问题","lang":"zh-CN","frontmatter":{"gitInclude":[]},"headers":[{"level":2,"title":"使用 jstack 工具","slug":"使用-jstack-工具","link":"#使用-jstack-工具","children":[{"level":3,"title":"第一步，使用 top 找到占用 CPU 最高的 Java 进程","slug":"第一步-使用-top-找到占用-cpu-最高的-java-进程","link":"#第一步-使用-top-找到占用-cpu-最高的-java-进程","children":[]},{"level":3,"title":"第二步，找到占用 CPU 最高的线程","slug":"第二步-找到占用-cpu-最高的线程","link":"#第二步-找到占用-cpu-最高的线程","children":[]},{"level":3,"title":"第三步，保存线程堆栈信息","slug":"第三步-保存线程堆栈信息","link":"#第三步-保存线程堆栈信息","children":[]},{"level":3,"title":"第四步，在线程栈中查找最贵祸首的线程","slug":"第四步-在线程栈中查找最贵祸首的线程","link":"#第四步-在线程栈中查找最贵祸首的线程","children":[]}]},{"level":2,"title":"第二种，Arthas","slug":"第二种-arthas","link":"#第二种-arthas","children":[{"level":3,"title":"安装 Arthas","slug":"安装-arthas","link":"#安装-arthas","children":[]},{"level":3,"title":"找到占用CPU最高的进程","slug":"找到占用cpu最高的进程","link":"#找到占用cpu最高的进程","children":[]},{"level":3,"title":"找到占用 CPU 最高的线程","slug":"找到占用-cpu-最高的线程","link":"#找到占用-cpu-最高的线程","children":[]},{"level":3,"title":"查看堆栈信息","slug":"查看堆栈信息","link":"#查看堆栈信息","children":[]}]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]}],"readingTime":{"minutes":5.11,"words":1534},"filePathRelative":"Interview/Java/13-吊打面试官/【场景】CPU飘高问题.md","excerpt":"\\n<h2>使用 jstack 工具</h2>\\n<h3>第一步，使用 top 找到占用 CPU 最高的 Java 进程</h3>\\n<p>前面说了这一步，就是使用 Top 命令</p>\\n<figure><figcaption>641</figcaption></figure>\\n<p>使用 <code>top</code>命令发现占用 CPU 99.7% 的线程是 Java 进程，进程 PID 为 <code>13731</code>。</p>\\n<h3>第二步，找到占用 CPU 最高的线程</h3>\\n<p>上一步用 <code>top</code>命令找到了那个 Java 进程。那一个进程中有那么多线程，不可能所有线程都一直占着 CPU 不放，这一步要做的就是揪出这个罪魁祸首，当然有可能不止一个。</p>"}')}}]);