"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[34463],{66262:(n,e)=>{e.A=(n,e)=>{const r=n.__vccOpts||n;for(const[n,t]of e)r[n]=t;return r}},52820:(n,e,r)=>{r.r(e),r.d(e,{comp:()=>a,data:()=>p});var t=r(20641);const o={},a=(0,r(66262).A)(o,[["render",function(n,e){return(0,t.uX)(),(0,t.CE)("div",null,[e[0]||(e[0]=(0,t.Lk)("h1",{id:"_2-1内存模型",tabindex:"-1"},[(0,t.Lk)("a",{class:"header-anchor",href:"#_2-1内存模型"},[(0,t.Lk)("span",null,"2.1内存模型")])],-1)),e[1]||(e[1]=(0,t.Lk)("blockquote",null,[(0,t.Lk)("p",null,"在 JVM (Java 虚拟机) 的内存模型中，堆内存（Heap）被划分为几个代（Generation），用来优化内存分配和垃圾回收（Garbage Collection）。主要分为以下几个代：")],-1)),(0,t.Q3)(" more "),e[2]||(e[2]=(0,t.Fv)('<h2 id="_1-年轻代-young-generation" tabindex="-1"><a class="header-anchor" href="#_1-年轻代-young-generation"><span><strong>1. 年轻代 (Young Generation)</strong></span></a></h2><p><strong>特点</strong>：</p><p>年轻代是新创建对象的主要存放区域，分为三部分：</p><p>​ • <strong>Eden 区</strong>：所有新创建的对象都会分配到 Eden 区。</p><p>​ • <strong>Survivor 区 (From 和 To)</strong>：用于在 Minor GC 后存活的对象。两个 Survivor 区交替使用，一个用来存储数据，另一个用来复制数据。</p><p><strong>垃圾回收机制</strong>：</p><p>​ • <strong>Minor GC</strong>：发生在年轻代，清理无用的短生命周期对象。</p><p>​ • 一般速度快，回收频率高。</p><p><strong>触发条件</strong>：</p><p>Eden 区满时触发 Minor GC，将存活对象复制到 Survivor 区，或直接晋升到老年代（根据晋升条件）。</p><h2 id="_2-老年代-old-generation" tabindex="-1"><a class="header-anchor" href="#_2-老年代-old-generation"><span><strong>2. 老年代 (Old Generation)</strong></span></a></h2><p><strong>特点</strong>：</p><p>​ • 存放生命周期较长的对象，如长期存活的缓存对象、静态对象等。</p><p>​ • 从年轻代晋升的对象会进入老年代。</p><p><strong>垃圾回收机制</strong>：</p><p>​ • <strong>Major GC/Full GC</strong>：针对老年代的回收，回收速度较慢，通常会导致应用暂停（Stop-The-World）。</p><p>​ • 触发频率低，但执行代价高。</p><p><strong>触发条件</strong>：</p><p>老年代内存不足时触发 Major GC。</p><h2 id="_3-永久代-permanent-generation-jdk-7-及之前" tabindex="-1"><a class="header-anchor" href="#_3-永久代-permanent-generation-jdk-7-及之前"><span><strong>3. 永久代 (Permanent Generation) [JDK 7 及之前]</strong></span></a></h2><p><strong>特点</strong>：</p><p>​ • 存储类的元信息，如类的字节码、方法区、常量池等。</p><p>​ • 用于加载 Class 对象、静态变量和运行时常量。</p><p><strong>垃圾回收机制</strong>：</p><p>当应用卸载类或者移除常量时，会对永久代进行回收。</p><p><strong>变化</strong>：</p><p>从 JDK 8 开始，永久代被移除，取而代之的是 <strong>元空间 (Metaspace)</strong>。</p><h2 id="_4-元空间-metaspace-jdk-8-及之后" tabindex="-1"><a class="header-anchor" href="#_4-元空间-metaspace-jdk-8-及之后"><span><strong>4. 元空间 (Metaspace) [JDK 8 及之后]</strong></span></a></h2><p><strong>特点</strong>：</p><p>​ • 类的元信息存储在元空间中。</p><p>​ • 不再使用堆内存，而是直接使用本地内存。</p><p>​ • 元空间的大小可以通过 JVM 参数控制 (-XX:MetaspaceSize)。</p><p><strong>优点</strong>：</p><p>​ • 避免永久代内存不足引起的 OutOfMemoryError。</p><p>​ • 提高了类加载的灵活性。</p><p><strong>总结图示</strong></p><p>堆 (Heap)</p><p>├── 年轻代 (Young Generation)</p><p>│ ├── Eden 区</p><p>│ ├── Survivor From 区</p><p>│ └── Survivor To 区</p><p>└── 老年代 (Old Generation)</p><p>方法区 (Method Area) [JDK 7]</p><p>├── 永久代 (Permanent Generation) [JDK 7]</p><p>└── 元空间 (Metaspace) [JDK 8+]</p>',45))])}]]),p=JSON.parse('{"path":"/JVM/2.1.%E5%B9%B4%E8%BD%BB%E4%BB%A3%E8%80%81%E5%B9%B4%E4%BB%A3.html","title":"2.1内存模型","lang":"zh-CN","frontmatter":{"icon":"fa-solid fa-microchip","date":"2024-12-17T00:00:00.000Z","category":["JVM"],"tag":["总结"],"gitInclude":[]},"headers":[{"level":2,"title":"1. 年轻代 (Young Generation)","slug":"_1-年轻代-young-generation","link":"#_1-年轻代-young-generation","children":[]},{"level":2,"title":"2. 老年代 (Old Generation)","slug":"_2-老年代-old-generation","link":"#_2-老年代-old-generation","children":[]},{"level":2,"title":"3. 永久代 (Permanent Generation) [JDK 7 及之前]","slug":"_3-永久代-permanent-generation-jdk-7-及之前","link":"#_3-永久代-permanent-generation-jdk-7-及之前","children":[]},{"level":2,"title":"4. 元空间 (Metaspace) [JDK 8 及之后]","slug":"_4-元空间-metaspace-jdk-8-及之后","link":"#_4-元空间-metaspace-jdk-8-及之后","children":[]}],"readingTime":{"minutes":1.9,"words":571},"filePathRelative":"JVM/2.1.年轻代老年代.md","localizedDate":"2024年12月17日","excerpt":"\\n<blockquote>\\n<p>在 JVM (Java 虚拟机) 的内存模型中，堆内存（Heap）被划分为几个代（Generation），用来优化内存分配和垃圾回收（Garbage Collection）。主要分为以下几个代：</p>\\n</blockquote>\\n"}')}}]);