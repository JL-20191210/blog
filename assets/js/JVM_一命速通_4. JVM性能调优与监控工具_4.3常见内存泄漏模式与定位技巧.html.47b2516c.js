"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[53198],{66262:(i,s)=>{s.A=(i,s)=>{const a=i.__vccOpts||i;for(const[i,t]of s)a[i]=t;return a}},13255:(i,s,a)=>{a.r(s),a.d(s,{comp:()=>l,data:()=>h});var t=a(20641);const e={},l=(0,a(66262).A)(e,[["render",function(i,s){const a=(0,t.g2)("RouteLink");return(0,t.uX)(),(0,t.CE)("div",null,[s[2]||(s[2]=(0,t.Lk)("h1",{id:"🧵-4-3-常见内存泄漏模式与定位技巧",tabindex:"-1"},[(0,t.Lk)("a",{class:"header-anchor",href:"#🧵-4-3-常见内存泄漏模式与定位技巧"},[(0,t.Lk)("span",null,"🧵 4.3 常见内存泄漏模式与定位技巧")])],-1)),s[3]||(s[3]=(0,t.Lk)("p",null,[(0,t.eW)("内存泄漏并非对象无法被 GC，而是对象"),(0,t.Lk)("strong",null,"不再被使用却仍被引用"),(0,t.eW)("，无法释放。此类问题不会立刻崩溃，却会持续吞噬内存，最终触发 OOM。")],-1)),s[4]||(s[4]=(0,t.Lk)("hr",null,null,-1)),(0,t.Q3)(" more "),s[5]||(s[5]=(0,t.Fv)('<h2 id="📌-java-中常见内存泄漏场景" tabindex="-1"><a class="header-anchor" href="#📌-java-中常见内存泄漏场景"><span>📌 Java 中常见内存泄漏场景</span></a></h2><table><thead><tr><th>场景</th><th>说明</th></tr></thead><tbody><tr><td>静态集合持有引用</td><td>如 <code>static List</code>、<code>Map</code> 缓存未清理</td></tr><tr><td>ThreadLocal 泄漏</td><td><code>ThreadLocal</code> 未调用 <code>remove()</code> 导致线程强引用</td></tr><tr><td>监听器/回调未注销</td><td>注册后未取消，导致回调引用常驻</td></tr><tr><td>大量 ClassLoader</td><td>动态类加载器未被卸载，如频繁使用 SPI、反射等</td></tr><tr><td>JDBC/IO 资源未关闭</td><td>导致连接句柄泄漏，间接引发堆外资源泄漏</td></tr></tbody></table><hr><h2 id="🧪-代码示例-静态集合泄漏" tabindex="-1"><a class="header-anchor" href="#🧪-代码示例-静态集合泄漏"><span>🧪 代码示例：静态集合泄漏</span></a></h2><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> LeakyCache</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> final</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> List</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Object</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> cache </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> ArrayList</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> add</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Object</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> obj</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        cache</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">add</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(obj); </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 无限制增长</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>解决：定期清理或使用 <code>WeakReference</code></p><hr><h2 id="🧪-代码示例-threadlocal-泄漏" tabindex="-1"><a class="header-anchor" href="#🧪-代码示例-threadlocal-泄漏"><span>🧪 代码示例：ThreadLocal 泄漏</span></a></h2><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">ThreadLocal</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">byte</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">[]</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> local </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> ThreadLocal</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">local</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">set</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">new</span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;"> byte</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1024</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> *</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1024</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">]);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>未调用 <code>local.remove()</code>，可能导致老年代中 <code>Thread</code> 持有无法释放的对象</p><hr><h2 id="🧠-如何定位内存泄漏" tabindex="-1"><a class="header-anchor" href="#🧠-如何定位内存泄漏"><span>🧠 如何定位内存泄漏？</span></a></h2><h3 id="✅-1-使用-mat-分析-retained-size" tabindex="-1"><a class="header-anchor" href="#✅-1-使用-mat-分析-retained-size"><span>✅ 1. 使用 MAT 分析 Retained Size</span></a></h3><ul><li>Dominator Tree 中保留对象最多的通常为泄漏根源</li></ul><h3 id="✅-2-leak-suspects-report-报告" tabindex="-1"><a class="header-anchor" href="#✅-2-leak-suspects-report-报告"><span>✅ 2. Leak Suspects Report 报告</span></a></h3><ul><li>Eclipse MAT 提供自动泄漏分析建议</li></ul><h3 id="✅-3-分析-gc-roots-路径" tabindex="-1"><a class="header-anchor" href="#✅-3-分析-gc-roots-路径"><span>✅ 3. 分析 GC Roots 路径</span></a></h3><ul><li>查看对象被哪个 static 字段/线程持有</li></ul><h3 id="✅-4-heap-histogram-分布" tabindex="-1"><a class="header-anchor" href="#✅-4-heap-histogram-分布"><span>✅ 4. Heap Histogram 分布</span></a></h3><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">jmap</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -histo:live</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">pi</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">d&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li>找出实例数量暴涨的类，如 <code>java.util.HashMap</code></li></ul><hr><h2 id="🎯-如何预防内存泄漏" tabindex="-1"><a class="header-anchor" href="#🎯-如何预防内存泄漏"><span>🎯 如何预防内存泄漏？</span></a></h2><table><thead><tr><th>建议</th><th>说明</th></tr></thead><tbody><tr><td>避免滥用 static 缓存</td><td>若使用必须设置失效策略</td></tr><tr><td>ThreadLocal 使用后 remove()</td><td>每次 set 后要主动清除</td></tr><tr><td>关闭资源</td><td>尽早释放连接、流、Statement 等资源</td></tr><tr><td>降低类加载复杂度</td><td>尽量复用类加载器，避免频繁生成</td></tr><tr><td>工具辅助监控</td><td>使用 MAT、Arthas、JProfiler 等结合分析内存</td></tr></tbody></table><hr><h2 id="📝-小结" tabindex="-1"><a class="header-anchor" href="#📝-小结"><span>📝 小结</span></a></h2><ul><li>Java 的内存泄漏来源广泛，排查核心是“可达但无用”对象</li><li>重点关注 static/ThreadLocal/类加载器引用链</li><li>推荐生产环境配置堆转储，并通过工具定期体检</li></ul><hr>',28)),(0,t.Lk)("p",null,[s[1]||(s[1]=(0,t.eW)("👉 下一篇推荐：")),(0,t.bF)(a,{to:"/JVM/%E4%B8%80%E5%91%BD%E9%80%9F%E9%80%9A/5.%E6%80%A7%E8%83%BD%E8%AF%8A%E6%96%AD%E4%B8%8E%E8%BF%90%E7%BB%B4%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/5.1JDK%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%E5%85%A8%E6%99%AF%E5%9B%BE%E4%B8%8E%E5%85%B8%E5%9E%8B%E7%94%A8%E9%80%94.html"},{default:(0,t.k6)((()=>s[0]||(s[0]=[(0,t.eW)("5.1 JDK 命令行工具全景图与典型用途")]))),_:1})])])}]]),h=JSON.parse('{"path":"/JVM/%E4%B8%80%E5%91%BD%E9%80%9F%E9%80%9A/4.%20JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E4%B8%8E%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7/4.3%E5%B8%B8%E8%A7%81%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%AE%9A%E4%BD%8D%E6%8A%80%E5%B7%A7.html","title":"4.3 常见内存泄漏模式与定位技巧","lang":"zh-CN","frontmatter":{"title":"4.3 常见内存泄漏模式与定位技巧","icon":"fa-solid fa-microchip","date":"2025-07-10T00:00:00.000Z","author":"JeanHu","category":["JVM","内存泄漏","故障排查"],"tag":["内存泄漏","实战经验","MAT分析"],"summary":"本文总结了 Java 中常见的内存泄漏模式，并结合工具和代码示例介绍定位技巧，帮助开发者高效应对系统内存持续上涨、隐匿性 OOM 等棘手问题。","gitInclude":[]},"headers":[{"level":2,"title":"📌 Java 中常见内存泄漏场景","slug":"📌-java-中常见内存泄漏场景","link":"#📌-java-中常见内存泄漏场景","children":[]},{"level":2,"title":"🧪 代码示例：静态集合泄漏","slug":"🧪-代码示例-静态集合泄漏","link":"#🧪-代码示例-静态集合泄漏","children":[]},{"level":2,"title":"🧪 代码示例：ThreadLocal 泄漏","slug":"🧪-代码示例-threadlocal-泄漏","link":"#🧪-代码示例-threadlocal-泄漏","children":[]},{"level":2,"title":"🧠 如何定位内存泄漏？","slug":"🧠-如何定位内存泄漏","link":"#🧠-如何定位内存泄漏","children":[{"level":3,"title":"✅ 1. 使用 MAT 分析 Retained Size","slug":"✅-1-使用-mat-分析-retained-size","link":"#✅-1-使用-mat-分析-retained-size","children":[]},{"level":3,"title":"✅ 2. Leak Suspects Report 报告","slug":"✅-2-leak-suspects-report-报告","link":"#✅-2-leak-suspects-report-报告","children":[]},{"level":3,"title":"✅ 3. 分析 GC Roots 路径","slug":"✅-3-分析-gc-roots-路径","link":"#✅-3-分析-gc-roots-路径","children":[]},{"level":3,"title":"✅ 4. Heap Histogram 分布","slug":"✅-4-heap-histogram-分布","link":"#✅-4-heap-histogram-分布","children":[]}]},{"level":2,"title":"🎯 如何预防内存泄漏？","slug":"🎯-如何预防内存泄漏","link":"#🎯-如何预防内存泄漏","children":[]},{"level":2,"title":"📝 小结","slug":"📝-小结","link":"#📝-小结","children":[]}],"readingTime":{"minutes":2.24,"words":673},"filePathRelative":"JVM/一命速通/4. JVM性能调优与监控工具/4.3常见内存泄漏模式与定位技巧.md","localizedDate":"2025年7月10日","excerpt":"\\n<p>内存泄漏并非对象无法被 GC，而是对象<strong>不再被使用却仍被引用</strong>，无法释放。此类问题不会立刻崩溃，却会持续吞噬内存，最终触发 OOM。</p>\\n<hr>\\n"}')}}]);