"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[285],{66262:(e,o)=>{o.A=(e,o)=>{const d=e.__vccOpts||e;for(const[e,c]of o)d[e]=c;return d}},75581:(e,o,d)=>{d.r(o),d.d(o,{comp:()=>l,data:()=>s});var c=d(20641);const a={},l=(0,d(66262).A)(a,[["render",function(e,o){return(0,c.uX)(),(0,c.CE)("div",null,o[0]||(o[0]=[(0,c.Fv)('<h1 id="_14-java-中-hashcode-和-equals-方法是什么-它们与-操作符有什么区别" tabindex="-1"><a class="header-anchor" href="#_14-java-中-hashcode-和-equals-方法是什么-它们与-操作符有什么区别"><span>14.Java 中 hashCode 和 equals 方法是什么？它们与 == 操作符有什么区别？</span></a></h1><h3 id="口述稿" tabindex="-1"><a class="header-anchor" href="#口述稿"><span>口述稿</span></a></h3><div class="hint-container important"><p class="hint-container-title">重要</p><p><code>hashCode</code>、<code>equals</code> 和 <code>==</code> 是 Java 中三个非常重要的概念，它们在对象比较和哈希结构中扮演着不同的角色。下面我来详细说明它们之间的区别。</p><p>首先，<code>==</code> 是 Java 中用于比较对象引用是否相等的操作符。它检查的是两个对象在<code>内存中的地址</code>是否相同，也就是说，<code>==</code> 判断的是两个对象是否指向同一个内存位置。如果两个对象的引用指向的是同一个对象，那么 <code>==</code> 返回 <code>true</code>；如果指向不同的对象，返回 <code>false</code>。</p><p>而 <code>equals</code> 是 <code>Object</code> 类中定义的方法，它用来比较两个对象的内容是否相等。默认情况下，<code>equals</code> 方法会比较对象的内存地址（类似于 <code>==</code> 的行为），但通常我们会在自定义类中重写 <code>equals</code> 方法，以实现对对象内容的比较。比如在 <code>String</code> 类中，<code>equals</code> 方法比较的是字符串的值，而不是它们在内存中的地址。因此，<code>equals</code> 是一种更为常见的内容比较方式，尤其是在集合操作中。</p><p>接下来是 <code>hashCode</code>，它是每个对象的哈希值，用于哈希存储结构中的对象查找和存储优化。<code>hashCode</code> 返回一个整数值，表示对象的哈希地址，它用于加速对象在哈希集合（如 <code>HashMap</code>、<code>HashSet</code>）中的查找。当我们将对象插入这些集合时，<code>hashCode</code> 被用来快速确定对象的存储位置。如果两个对象的 <code>hashCode</code> 不同，它们一定不相等（<code>equals</code> 返回 <code>false</code>）。但需要注意的是，<code>hashCode</code> 相同的对象不一定通过 <code>equals</code> 比较为相等。</p><p>总结一下它们之间的关系：</p><ul><li><code>==</code> 比较的是对象的引用，判断它们是否指向同一个内存地址。</li><li><code>equals</code> 比较的是对象的内容，判断它们的内容是否相等（需要根据具体实现来决定）。</li><li><code>hashCode</code> 是用于哈希结构中对象查找和存储的优化工具，通常需要与 <code>equals</code> 配合使用，以保证哈希结构的正确性。</li></ul><p>简单来说，<code>==</code> 是比较对象的引用，<code>equals</code> 是比较对象的内容，而 <code>hashCode</code> 是为了提高哈希结构效率所使用的哈希值。</p></div><hr><h3 id="_1-操作符" tabindex="-1"><a class="header-anchor" href="#_1-操作符"><span>1. <code>==</code> 操作符</span></a></h3><ul><li><strong>作用</strong>：比较两个对象的引用是否相等。</li><li><strong>工作原理</strong>：<code>==</code> 操作符用于判断两个对象引用是否指向同一个内存地址（即两个对象是否是同一个实例）。 <ul><li>对于基本数据类型，<code>==</code> 比较的是值。</li><li>对于对象引用类型，<code>==</code> 比较的是内存地址（引用）。</li></ul></li></ul><h3 id="_2-equals-方法" tabindex="-1"><a class="header-anchor" href="#_2-equals-方法"><span>2. <code>equals()</code> 方法</span></a></h3><ul><li><p><strong>作用</strong>：比较两个对象的内容是否相等。</p></li><li><p><strong>工作原理</strong>：<code>equals()</code> 方法是 <code>Object</code> 类中的一个方法，默认实现是比较对象引用的内存地址。通常，开发者需要重写 <code>equals()</code> 方法，定义对象内容的相等性逻辑。</p><ul><li>比如，在 <code>String</code> 类中，<code>equals()</code> 方法比较的是两个字符串的字符内容，而不是引用地址。</li></ul><p>重写 <code>equals()</code> 方法时，通常遵循以下约定：</p><ul><li><strong>自反性</strong>：对任何非空引用值 <code>x</code>，<code>x.equals(x)</code> 应返回 <code>true</code>。</li><li><strong>对称性</strong>：对于任何非空引用值 <code>x</code> 和 <code>y</code>，如果 <code>x.equals(y)</code> 返回 <code>true</code>，则 <code>y.equals(x)</code> 也应该返回 <code>true</code>。</li><li><strong>传递性</strong>：对于任何非空引用值 <code>x</code>、<code>y</code> 和 <code>z</code>，如果 <code>x.equals(y)</code> 和 <code>y.equals(z)</code> 都返回 <code>true</code>，那么 <code>x.equals(z)</code> 也应该返回 <code>true</code>。</li><li><strong>一致性</strong>：如果对象的比较属性没有改变，那么多次调用 <code>equals()</code> 方法应该返回相同的结果。</li><li><strong>null 值</strong>：<code>x.equals(null)</code> 应返回 <code>false</code>。</li></ul></li></ul><h3 id="_3-hashcode-方法" tabindex="-1"><a class="header-anchor" href="#_3-hashcode-方法"><span>3. <code>hashCode()</code> 方法</span></a></h3><ul><li><p><strong>作用</strong>：返回对象的哈希码（整数值），用于哈希数据结构（如 <code>HashMap</code>、<code>HashSet</code>）中快速查找对象。</p></li><li><p><strong>工作原理</strong>：<code>hashCode()</code> 方法返回一个整数，通常是对象内容的某种算法生成的散列值。不同对象的哈希码通常不同，但同样的内容的对象哈希码应该相同。</p><ul><li>如果两个对象通过 <code>equals()</code> 方法相等，那么它们的 <code>hashCode()</code> 必须相等。</li><li>如果两个对象的 <code>hashCode()</code> 相等，并不意味着它们相等。哈希冲突是可能的。</li></ul><p>需要重写 <code>hashCode()</code> 方法时，通常遵循以下约定：</p><ul><li>如果两个对象的 <code>equals()</code> 方法返回 <code>true</code>，那么它们的 <code>hashCode()</code> 必须相等。</li><li>如果两个对象的 <code>equals()</code> 方法返回 <code>false</code>，那么它们的 <code>hashCode()</code> 可以相等，也可以不同。</li></ul></li></ul><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h3><ul><li><code>==</code> 比较的是对象的引用（内存地址）是否相同。</li><li><code>equals()</code> 用于比较对象的内容是否相同，通常需要根据业务需求重写。</li><li><code>hashCode()</code> 用于为对象生成哈希码，通常与 <code>equals()</code> 一起使用，尤其在使用哈希数据结构时非常重要。</li></ul><p>这三个操作符和方法各自有不同的用途，但它们共同构成了 Java 中对象比较和哈希结构的基础。</p>',13)]))}]]),s=JSON.parse('{"path":"/Interview/Java/01%E5%9F%BA%E7%A1%80/14.Java%20%E4%B8%AD%20hashCode_equals%20%E6%96%B9%E6%B3%95%E5%92%8C__%20%E6%93%8D%E4%BD%9C%E7%AC%A6.html","title":"14.Java 中 hashCode 和 equals 方法是什么？它们与 == 操作符有什么区别？","lang":"zh-CN","frontmatter":{"icon":"fa-brands fa-java","date":"2025-01-10T00:00:00.000Z","category":["Java"],"tag":["必背"],"gitInclude":[]},"headers":[{"level":3,"title":"口述稿","slug":"口述稿","link":"#口述稿","children":[]},{"level":3,"title":"1. == 操作符","slug":"_1-操作符","link":"#_1-操作符","children":[]},{"level":3,"title":"2. equals() 方法","slug":"_2-equals-方法","link":"#_2-equals-方法","children":[]},{"level":3,"title":"3. hashCode() 方法","slug":"_3-hashcode-方法","link":"#_3-hashcode-方法","children":[]},{"level":3,"title":"总结","slug":"总结","link":"#总结","children":[]}],"readingTime":{"minutes":4.28,"words":1285},"filePathRelative":"Interview/Java/01基础/14.Java 中 hashCode,equals 方法和== 操作符.md","localizedDate":"2025年1月10日","excerpt":"\\n<h3>口述稿</h3>\\n<div class=\\"hint-container important\\">\\n<p class=\\"hint-container-title\\">重要</p>\\n<p><code>hashCode</code>、<code>equals</code> 和 <code>==</code> 是 Java 中三个非常重要的概念，它们在对象比较和哈希结构中扮演着不同的角色。下面我来详细说明它们之间的区别。</p>\\n<p>首先，<code>==</code> 是 Java 中用于比较对象引用是否相等的操作符。它检查的是两个对象在<code>内存中的地址</code>是否相同，也就是说，<code>==</code> 判断的是两个对象是否指向同一个内存位置。如果两个对象的引用指向的是同一个对象，那么 <code>==</code> 返回 <code>true</code>；如果指向不同的对象，返回 <code>false</code>。</p>\\n<p>而 <code>equals</code> 是 <code>Object</code> 类中定义的方法，它用来比较两个对象的内容是否相等。默认情况下，<code>equals</code> 方法会比较对象的内存地址（类似于 <code>==</code> 的行为），但通常我们会在自定义类中重写 <code>equals</code> 方法，以实现对对象内容的比较。比如在 <code>String</code> 类中，<code>equals</code> 方法比较的是字符串的值，而不是它们在内存中的地址。因此，<code>equals</code> 是一种更为常见的内容比较方式，尤其是在集合操作中。</p>\\n<p>接下来是 <code>hashCode</code>，它是每个对象的哈希值，用于哈希存储结构中的对象查找和存储优化。<code>hashCode</code> 返回一个整数值，表示对象的哈希地址，它用于加速对象在哈希集合（如 <code>HashMap</code>、<code>HashSet</code>）中的查找。当我们将对象插入这些集合时，<code>hashCode</code> 被用来快速确定对象的存储位置。如果两个对象的 <code>hashCode</code> 不同，它们一定不相等（<code>equals</code> 返回 <code>false</code>）。但需要注意的是，<code>hashCode</code> 相同的对象不一定通过 <code>equals</code> 比较为相等。</p>\\n<p>总结一下它们之间的关系：</p>\\n<ul>\\n<li><code>==</code> 比较的是对象的引用，判断它们是否指向同一个内存地址。</li>\\n<li><code>equals</code> 比较的是对象的内容，判断它们的内容是否相等（需要根据具体实现来决定）。</li>\\n<li><code>hashCode</code> 是用于哈希结构中对象查找和存储的优化工具，通常需要与 <code>equals</code> 配合使用，以保证哈希结构的正确性。</li>\\n</ul>\\n<p>简单来说，<code>==</code> 是比较对象的引用，<code>equals</code> 是比较对象的内容，而 <code>hashCode</code> 是为了提高哈希结构效率所使用的哈希值。</p>\\n</div>"}')}}]);