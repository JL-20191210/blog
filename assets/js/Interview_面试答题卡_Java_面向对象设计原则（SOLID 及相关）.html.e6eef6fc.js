"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[75723],{66262:(l,n)=>{n.A=(l,n)=>{const r=l.__vccOpts||l;for(const[l,s]of n)r[l]=s;return r}},51481:(l,n,r)=>{r.r(n),r.d(n,{comp:()=>t,data:()=>a});var s=r(20641);const i={},t=(0,r(66262).A)(i,[["render",function(l,n){return(0,s.uX)(),(0,s.CE)("div",null,n[0]||(n[0]=[(0,s.Fv)('<h1 id="☕java面试答题卡-面向对象设计原则-solid-及相关" tabindex="-1"><a class="header-anchor" href="#☕java面试答题卡-面向对象设计原则-solid-及相关"><span>☕Java面试答题卡：面向对象设计原则（SOLID 及相关）</span></a></h1><hr><h2 id="_1-单一职责原则-srp" tabindex="-1"><a class="header-anchor" href="#_1-单一职责原则-srp"><span>1. 单一职责原则（SRP）</span></a></h2><ul><li><strong>定义</strong>：一个类应该只有一个引起它变化的原因，即一个类只负责一项职责。</li><li><strong>作用</strong>：降低类的复杂度，提高可维护性。</li><li><strong>示例</strong>：将用户管理、数据存储和通知拆分到不同的类中。</li></ul><hr><h2 id="_2-开放封闭原则-ocp" tabindex="-1"><a class="header-anchor" href="#_2-开放封闭原则-ocp"><span>2. 开放封闭原则（OCP）</span></a></h2><ul><li><strong>定义</strong>：软件实体应对扩展开放，对修改封闭。</li><li><strong>作用</strong>：新增功能时，避免修改已有代码，降低风险。</li><li><strong>示例</strong>：使用抽象类和接口，通过继承和多态实现扩展。</li></ul><hr><h2 id="_3-里氏替换原则-lsp" tabindex="-1"><a class="header-anchor" href="#_3-里氏替换原则-lsp"><span>3. 里氏替换原则（LSP）</span></a></h2><ul><li><strong>定义</strong>：子类对象应该能够替换父类对象，且程序行为不变。</li><li><strong>作用</strong>：确保继承关系的正确性和可靠性。</li><li><strong>示例</strong>：子类重写方法时不改变父类预期行为。</li></ul><hr><h2 id="_4-接口隔离原则-isp" tabindex="-1"><a class="header-anchor" href="#_4-接口隔离原则-isp"><span>4. 接口隔离原则（ISP）</span></a></h2><ul><li><strong>定义</strong>：客户端不应该依赖它不使用的接口，接口应小而专。</li><li><strong>作用</strong>：降低接口冗余和实现复杂度。</li><li><strong>示例</strong>：将大接口拆分为多个小接口，按需实现。</li></ul><hr><h2 id="_5-依赖倒置原则-dip" tabindex="-1"><a class="header-anchor" href="#_5-依赖倒置原则-dip"><span>5. 依赖倒置原则（DIP）</span></a></h2><ul><li><strong>定义</strong>：高层模块不依赖低层模块，二者依赖抽象；抽象不依赖细节，细节依赖抽象。</li><li><strong>作用</strong>：实现模块解耦，提高灵活性。</li><li><strong>示例</strong>：通过接口和依赖注入实现松耦合。</li></ul><hr><h2 id="_6-最少知识原则-lod" tabindex="-1"><a class="header-anchor" href="#_6-最少知识原则-lod"><span>6. 最少知识原则（LoD）</span></a></h2><ul><li><strong>定义</strong>：一个对象应只与直接朋友通信，避免与陌生人交流。</li><li><strong>作用</strong>：减少类间耦合，提高模块内聚。</li><li><strong>示例</strong>：避免链式调用，封装内部对象调用。</li></ul><hr><h2 id="_7-合成复用原则-crp" tabindex="-1"><a class="header-anchor" href="#_7-合成复用原则-crp"><span>7. 合成复用原则（CRP）</span></a></h2><ul><li><strong>定义</strong>：优先使用对象组合/聚合，而非继承来复用代码。</li><li><strong>作用</strong>：减少继承带来的耦合和脆弱性。</li><li><strong>示例</strong>：通过组合其他类实现功能而非继承。</li></ul>',22)]))}]]),a=JSON.parse('{"path":"/Interview/%E9%9D%A2%E8%AF%95%E7%AD%94%E9%A2%98%E5%8D%A1/Java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%EF%BC%88SOLID%20%E5%8F%8A%E7%9B%B8%E5%85%B3%EF%BC%89.html","title":"☕Java面试答题卡：面向对象设计原则（SOLID 及相关）","lang":"zh-CN","frontmatter":{"gitInclude":[]},"headers":[{"level":2,"title":"1. 单一职责原则（SRP）","slug":"_1-单一职责原则-srp","link":"#_1-单一职责原则-srp","children":[]},{"level":2,"title":"2. 开放封闭原则（OCP）","slug":"_2-开放封闭原则-ocp","link":"#_2-开放封闭原则-ocp","children":[]},{"level":2,"title":"3. 里氏替换原则（LSP）","slug":"_3-里氏替换原则-lsp","link":"#_3-里氏替换原则-lsp","children":[]},{"level":2,"title":"4. 接口隔离原则（ISP）","slug":"_4-接口隔离原则-isp","link":"#_4-接口隔离原则-isp","children":[]},{"level":2,"title":"5. 依赖倒置原则（DIP）","slug":"_5-依赖倒置原则-dip","link":"#_5-依赖倒置原则-dip","children":[]},{"level":2,"title":"6. 最少知识原则（LoD）","slug":"_6-最少知识原则-lod","link":"#_6-最少知识原则-lod","children":[]},{"level":2,"title":"7. 合成复用原则（CRP）","slug":"_7-合成复用原则-crp","link":"#_7-合成复用原则-crp","children":[]}],"readingTime":{"minutes":1.59,"words":478},"filePathRelative":"Interview/面试答题卡/Java/面向对象设计原则（SOLID 及相关）.md","excerpt":"\\n<hr>\\n<h2>1. 单一职责原则（SRP）</h2>\\n<ul>\\n<li><strong>定义</strong>：一个类应该只有一个引起它变化的原因，即一个类只负责一项职责。</li>\\n<li><strong>作用</strong>：降低类的复杂度，提高可维护性。</li>\\n<li><strong>示例</strong>：将用户管理、数据存储和通知拆分到不同的类中。</li>\\n</ul>\\n<hr>\\n<h2>2. 开放封闭原则（OCP）</h2>\\n<ul>\\n<li><strong>定义</strong>：软件实体应对扩展开放，对修改封闭。</li>\\n<li><strong>作用</strong>：新增功能时，避免修改已有代码，降低风险。</li>\\n<li><strong>示例</strong>：使用抽象类和接口，通过继承和多态实现扩展。</li>\\n</ul>"}')}}]);