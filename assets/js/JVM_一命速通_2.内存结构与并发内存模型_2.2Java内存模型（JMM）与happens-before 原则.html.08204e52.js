"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[19437],{66262:(i,s)=>{s.A=(i,s)=>{const a=i.__vccOpts||i;for(const[i,e]of s)a[i]=e;return a}},86002:(i,s,a)=>{a.r(s),a.d(s,{comp:()=>l,data:()=>h});var e=a(20641);const n={},l=(0,a(66262).A)(n,[["render",function(i,s){const a=(0,e.g2)("RouteLink");return(0,e.uX)(),(0,e.CE)("div",null,[s[2]||(s[2]=(0,e.Fv)('<h1 id="_2-2-java-内存模型-jmm-与-happens-before-原则" tabindex="-1"><a class="header-anchor" href="#_2-2-java-内存模型-jmm-与-happens-before-原则"><span>2.2 Java 内存模型（JMM）与 happens-before 原则</span></a></h1><hr><h2 id="🧠-什么是-java-内存模型-jmm" tabindex="-1"><a class="header-anchor" href="#🧠-什么是-java-内存模型-jmm"><span>🧠 什么是 Java 内存模型（JMM）？</span></a></h2><p>Java 内存模型（Java Memory Model）定义了多线程环境下，Java 程序如何在主内存和线程本地工作内存之间交互的规范。JMM 确保了在不同 CPU 缓存与内存之间的一致性，避免了多线程环境下的可见性和有序性问题。</p><ul><li><strong>主内存</strong>：共享的内存区域，所有线程都可访问。</li><li><strong>工作内存</strong>：每个线程独立持有的本地内存，用于缓存主内存中的变量副本。</li></ul><p>JMM 规范了线程之间如何读写共享变量的规则，以保证程序执行的正确性。</p><hr>',7)),(0,e.Q3)(" more "),s[3]||(s[3]=(0,e.Fv)('<h2 id="🔍-jmm-三大核心特性" tabindex="-1"><a class="header-anchor" href="#🔍-jmm-三大核心特性"><span>🔍 JMM 三大核心特性</span></a></h2><table><thead><tr><th>特性</th><th>说明</th></tr></thead><tbody><tr><td><strong>原子性</strong></td><td>操作不可分割，要么全部执行成功，要么全部不执行（如 <code>i++</code> 实际包含多个步骤，非原子操作）。</td></tr><tr><td><strong>可见性</strong></td><td>一个线程对共享变量的修改，能及时被其他线程看到。</td></tr><tr><td><strong>有序性</strong></td><td>程序执行的顺序遵循代码顺序或内存屏障规则，不被乱序执行影响。</td></tr></tbody></table><hr><h2 id="🧩-线程与主内存之间的交互流程" tabindex="-1"><a class="header-anchor" href="#🧩-线程与主内存之间的交互流程"><span>🧩 线程与主内存之间的交互流程</span></a></h2><p>每个线程都有自己的<strong>工作内存</strong>，保存共享变量的副本。</p><p>读写变量时流程如下：</p><ul><li><strong>读取操作</strong>： <ol><li>线程从主内存中读取共享变量到工作内存。</li><li>在线程的工作内存中读取变量的值。</li></ol></li><li><strong>写入操作</strong>： <ol><li>线程修改工作内存中的变量副本。</li><li>将工作内存中的变量刷新回主内存。</li></ol></li></ul><p>不同线程的工作内存相互独立，因此可能导致变量值不一致。</p><hr><h2 id="🔁-happens-before-原则" tabindex="-1"><a class="header-anchor" href="#🔁-happens-before-原则"><span>🔁 happens-before 原则</span></a></h2><p>happens-before 是 JMM 用来定义操作执行顺序的一个规则：</p><blockquote><p>如果操作 A happens-before 操作 B，则 A 的执行结果对 B 可见，且 A 必须先于 B 执行。</p></blockquote><p>换言之，happens-before 保证内存可见性和操作执行顺序。</p><hr><h3 id="✔-happens-before-的关键规则" tabindex="-1"><a class="header-anchor" href="#✔-happens-before-的关键规则"><span>✔ happens-before 的关键规则</span></a></h3><table><thead><tr><th>规则</th><th>说明</th></tr></thead><tbody><tr><td>程序顺序规则</td><td>同一个线程内，按照代码顺序执行，前面的操作 happens-before 后面操作。</td></tr><tr><td>监视器锁规则</td><td>对一个锁的解锁操作 happens-before 之后对该锁的加锁操作。</td></tr><tr><td>volatile 变量规则</td><td>对 volatile 变量的写操作 happens-before 之后对该变量的读操作。</td></tr><tr><td>传递性规则</td><td>如果 A happens-before B，且 B happens-before C，则 A happens-before C。</td></tr><tr><td>线程启动规则</td><td>主线程调用 <code>Thread.start()</code> 先于新线程执行开始。</td></tr><tr><td>线程终结规则</td><td>线程执行完毕（终止）先于其他线程检测到它终止。</td></tr></tbody></table><hr><h2 id="🛠-jmm-关键示例解析" tabindex="-1"><a class="header-anchor" href="#🛠-jmm-关键示例解析"><span>🛠 JMM 关键示例解析</span></a></h2><h3 id="_1-volatile-保证可见性" tabindex="-1"><a class="header-anchor" href="#_1-volatile-保证可见性"><span>1. volatile 保证可见性</span></a></h3><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> VolatileExample</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> volatile</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> boolean</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> flag </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> false</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> writer</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        flag </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> true</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 写 volatile 变量</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> reader</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (flag) { </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 读 volatile 变量，保证可见</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">            System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;Flag is true&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        }</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>线程写 <code>flag</code> 后，其他线程能立即看到 <code>flag</code> 的最新值。</li><li><code>volatile</code> 变量的写操作会立刻刷新到主内存，读操作会从主内存中读取最新值。</li></ul><hr><h3 id="_2-synchronized-保证互斥与可见性" tabindex="-1"><a class="header-anchor" href="#_2-synchronized-保证互斥与可见性"><span>2. synchronized 保证互斥与可见性</span></a></h3><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> SyncExample</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> count </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> synchronized</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> increment</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        count++; </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 互斥修改，保证原子性</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> synchronized</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> getCount</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> count; </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 保证读操作可见</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>synchronized 锁住代码块，确保同一时刻只有一个线程访问。</li><li>释放锁时会将变量同步回主内存，保证其他线程能看到最新值。</li></ul><hr><h2 id="📌-jmm-常见问题" tabindex="-1"><a class="header-anchor" href="#📌-jmm-常见问题"><span>📌 JMM 常见问题</span></a></h2><h3 id="q1-为什么需要-jmm" tabindex="-1"><a class="header-anchor" href="#q1-为什么需要-jmm"><span>Q1: 为什么需要 JMM？</span></a></h3><p>多核 CPU 缓存与编译器重排序可能导致线程间数据不一致，JMM 通过规定 happens-before 关系，保证可见性和有序性。</p><h3 id="q2-volatile-能替代-synchronized-吗" tabindex="-1"><a class="header-anchor" href="#q2-volatile-能替代-synchronized-吗"><span>Q2: volatile 能替代 synchronized 吗？</span></a></h3><p>不能。volatile 只保证可见性和有序性，不保证操作的原子性。</p><h3 id="q3-什么是重排序-jmm-如何控制" tabindex="-1"><a class="header-anchor" href="#q3-什么是重排序-jmm-如何控制"><span>Q3: 什么是重排序？JMM 如何控制？</span></a></h3><p>重排序是 CPU 或编译器为优化性能调整指令执行顺序，JMM 通过内存屏障和 happens-before 规则限制可见的重排序范围。</p><hr><h2 id="📝-总结" tabindex="-1"><a class="header-anchor" href="#📝-总结"><span>📝 总结</span></a></h2><ul><li>JMM 是 Java 并发基础，规范多线程访问共享变量的行为。</li><li>happens-before 原则确保执行顺序和内存可见性。</li><li>正确理解 volatile、synchronized 是保障线程安全的关键。</li><li>深入掌握 JMM 有助于写出高性能且正确的并发程序。</li></ul>',36)),(0,e.Lk)("p",null,[s[1]||(s[1]=(0,e.eW)("👉 下一篇推荐阅读：")),(0,e.bF)(a,{to:"/JVM/%E4%B8%80%E5%91%BD%E9%80%9F%E9%80%9A/2.%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E4%B8%8E%E5%B9%B6%E5%8F%91%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/2.3%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98DirectMemory%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E9%A3%8E%E9%99%A9.html"},{default:(0,e.k6)((()=>s[0]||(s[0]=[(0,e.eW)("2.3直接内存DirectMemory的使用与风险")]))),_:1})])])}]]),h=JSON.parse('{"path":"/JVM/%E4%B8%80%E5%91%BD%E9%80%9F%E9%80%9A/2.%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E4%B8%8E%E5%B9%B6%E5%8F%91%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/2.2Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%88JMM%EF%BC%89%E4%B8%8Ehappens-before%20%E5%8E%9F%E5%88%99.html","title":"2.2 Java 内存模型（JMM）与 happens-before 原则","lang":"zh-CN","frontmatter":{"title":"2.2 Java 内存模型（JMM）与 happens-before 原则","icon":"fa-solid fa-network-wired","date":"2025-07-10T00:00:00.000Z","author":"JeanHu","category":["JVM"],"tag":["JVM","Java内存模型","JMM","happens-before","并发"],"summary":"本文深入讲解 Java 内存模型（JMM）及 happens-before 原则，解析多线程环境下内存可见性、有序性与原子性保障机制，帮助开发者理解并发编程核心理论。","gitInclude":[]},"headers":[{"level":2,"title":"🧠 什么是 Java 内存模型（JMM）？","slug":"🧠-什么是-java-内存模型-jmm","link":"#🧠-什么是-java-内存模型-jmm","children":[]},{"level":2,"title":"🔍 JMM 三大核心特性","slug":"🔍-jmm-三大核心特性","link":"#🔍-jmm-三大核心特性","children":[]},{"level":2,"title":"🧩 线程与主内存之间的交互流程","slug":"🧩-线程与主内存之间的交互流程","link":"#🧩-线程与主内存之间的交互流程","children":[]},{"level":2,"title":"🔁 happens-before 原则","slug":"🔁-happens-before-原则","link":"#🔁-happens-before-原则","children":[{"level":3,"title":"✔ happens-before 的关键规则","slug":"✔-happens-before-的关键规则","link":"#✔-happens-before-的关键规则","children":[]}]},{"level":2,"title":"🛠 JMM 关键示例解析","slug":"🛠-jmm-关键示例解析","link":"#🛠-jmm-关键示例解析","children":[{"level":3,"title":"1. volatile 保证可见性","slug":"_1-volatile-保证可见性","link":"#_1-volatile-保证可见性","children":[]},{"level":3,"title":"2. synchronized 保证互斥与可见性","slug":"_2-synchronized-保证互斥与可见性","link":"#_2-synchronized-保证互斥与可见性","children":[]}]},{"level":2,"title":"📌 JMM 常见问题","slug":"📌-jmm-常见问题","link":"#📌-jmm-常见问题","children":[{"level":3,"title":"Q1: 为什么需要 JMM？","slug":"q1-为什么需要-jmm","link":"#q1-为什么需要-jmm","children":[]},{"level":3,"title":"Q2: volatile 能替代 synchronized 吗？","slug":"q2-volatile-能替代-synchronized-吗","link":"#q2-volatile-能替代-synchronized-吗","children":[]},{"level":3,"title":"Q3: 什么是重排序？JMM 如何控制？","slug":"q3-什么是重排序-jmm-如何控制","link":"#q3-什么是重排序-jmm-如何控制","children":[]}]},{"level":2,"title":"📝 总结","slug":"📝-总结","link":"#📝-总结","children":[]}],"readingTime":{"minutes":4,"words":1199},"filePathRelative":"JVM/一命速通/2.内存结构与并发内存模型/2.2Java内存模型（JMM）与happens-before 原则.md","localizedDate":"2025年7月10日","excerpt":"\\n<hr>\\n<h2>🧠 什么是 Java 内存模型（JMM）？</h2>\\n<p>Java 内存模型（Java Memory Model）定义了多线程环境下，Java 程序如何在主内存和线程本地工作内存之间交互的规范。JMM 确保了在不同 CPU 缓存与内存之间的一致性，避免了多线程环境下的可见性和有序性问题。</p>\\n<ul>\\n<li><strong>主内存</strong>：共享的内存区域，所有线程都可访问。</li>\\n<li><strong>工作内存</strong>：每个线程独立持有的本地内存，用于缓存主内存中的变量副本。</li>\\n</ul>\\n<p>JMM 规范了线程之间如何读写共享变量的规则，以保证程序执行的正确性。</p>\\n<hr>\\n"}')}}]);