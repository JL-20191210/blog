"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[3934],{66262:(i,s)=>{s.A=(i,s)=>{const a=i.__vccOpts||i;for(const[i,n]of s)a[i]=n;return a}},29e3:(i,s,a)=>{a.r(s),a.d(s,{comp:()=>t,data:()=>e});var n=a(20641);const l={},t=(0,a(66262).A)(l,[["render",function(i,s){return(0,n.uX)(),(0,n.CE)("div",null,s[0]||(s[0]=[(0,n.Fv)('<h1 id="_8-什么是自旋锁" tabindex="-1"><a class="header-anchor" href="#_8-什么是自旋锁"><span>8.什么是自旋锁</span></a></h1><div class="hint-container important"><p class="hint-container-title">重要</p><p>自旋锁（Spinlock）是一种同步机制，用于在并发编程中保护共享资源，避免多个线程或进程同时访问同一资源。自旋锁的核心思想是，当一个线程尝试获取锁时，如果锁已经被其他线程持有，它不会进入休眠状态（像传统的互斥锁），而是持续地在<code>循环中“自旋”</code>，不断地检查锁是否可用，直到成功获取锁。</p></div><h3 id="自旋锁的工作原理" tabindex="-1"><a class="header-anchor" href="#自旋锁的工作原理"><span>自旋锁的工作原理：</span></a></h3><ol><li><strong>尝试获取锁</strong>：当线程请求锁时，如果锁当前没有被占用，线程立即获取锁并继续执行。</li><li><strong>自旋等待</strong>：如果锁已经被其他线程持有，线程不会进入阻塞状态，而是进入一个忙等待（自旋）的状态，不断地检查锁是否被释放。</li><li><strong>释放锁</strong>：当持有锁的线程完成任务后，它会释放锁，允许其他线程获取锁。</li></ol><h3 id="自旋锁的优缺点" tabindex="-1"><a class="header-anchor" href="#自旋锁的优缺点"><span>自旋锁的优缺点：</span></a></h3><h4 id="优点" tabindex="-1"><a class="header-anchor" href="#优点"><span>优点：</span></a></h4><ol><li><strong>减少上下文切换</strong>：自旋锁不涉及线程的阻塞和唤醒，因此避免了操作系统进行上下文切换的开销，适用于临界区执行时间较短的情况。</li><li><strong>高效性</strong>：在多核系统中，如果临界区很短，自旋锁能够比传统的互斥锁（阻塞锁）更高效，因为它避免了线程进入休眠状态。</li></ol><h4 id="缺点" tabindex="-1"><a class="header-anchor" href="#缺点"><span>缺点：</span></a></h4><ol><li><strong>忙等待浪费 CPU</strong>：自旋锁的缺点是当锁被长时间占用时，线程会不停地自旋等待，这会消耗大量的 CPU 资源，导致性能下降，特别是在多线程竞争严重时。</li><li><strong>适用场景有限</strong>：自旋锁适用于临界区时间非常短的场景，如果锁持有时间较长，应该使用其他同步机制，如互斥锁（mutex）或信号量（semaphore）。</li></ol><h3 id="自旋锁的示例" tabindex="-1"><a class="header-anchor" href="#自旋锁的示例"><span>自旋锁的示例：</span></a></h3><p>假设有一个全局变量 <code>count</code>，多个线程并发地增加它。我们使用自旋锁来保证对 <code>count</code> 的访问是同步的。</p><h4 id="示例代码-伪代码" tabindex="-1"><a class="header-anchor" href="#示例代码-伪代码"><span>示例代码（伪代码）：</span></a></h4><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">volatile</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> lock </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 自旋锁状态，0表示锁空闲，1表示锁已被占用</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">volatile</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> count </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 共享资源</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> spin_lock</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() {</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    while</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">__sync_lock_test_and_set</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">lock, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)) {</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 锁已被占用，线程继续自旋等待</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> spin_unlock</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() {</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    lock </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 释放锁</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> increment</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() {</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    spin_lock</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 获取锁</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    count</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">++</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">      // 访问共享资源</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    spin_unlock</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 释放锁</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，<code>__sync_lock_test_and_set()</code> 是一种原子操作，它会将 <code>lock</code> 设置为 1，并返回原来的值。线程不断检查 <code>lock</code> 是否为 0，只有当它为 0 时，线程才会成功获取锁。获取锁后，线程可以访问共享资源 <code>count</code>，操作完后释放锁。</p><h3 id="适用场景" tabindex="-1"><a class="header-anchor" href="#适用场景"><span>适用场景：</span></a></h3><ul><li><strong>短时间临界区</strong>：自旋锁适用于锁持有时间较短的场景。如果一个线程在获取锁后立即完成任务，其他线程的自旋等待就不会浪费太多的 CPU 资源。</li><li><strong>多核处理器系统</strong>：自旋锁在多核处理器系统中表现得更为高效，因为一个线程可以在等待锁的过程中执行其他线程可能已经处理好的代码，利用多核并行的优势。</li></ul><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结：</span></a></h3><p>自旋锁是一种通过忙等待的方式来控制对共享资源的访问的同步机制。它避免了传统锁机制中的线程阻塞和唤醒的开销，适用于临界区代码执行时间较短的情况。但如果锁持有时间较长，频繁的自旋会浪费大量的 CPU 资源，降低性能。</p>',18)]))}]]),e=JSON.parse('{"path":"/Interview/%E9%BB%91%E9%A9%ACJava2023/08%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/02%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8/8.%E4%BB%80%E4%B9%88%E6%98%AF%E8%87%AA%E6%97%8B%E9%94%81.html","title":"8.什么是自旋锁","lang":"zh-CN","frontmatter":{"gitInclude":[]},"headers":[{"level":3,"title":"自旋锁的工作原理：","slug":"自旋锁的工作原理","link":"#自旋锁的工作原理","children":[]},{"level":3,"title":"自旋锁的优缺点：","slug":"自旋锁的优缺点","link":"#自旋锁的优缺点","children":[]},{"level":3,"title":"自旋锁的示例：","slug":"自旋锁的示例","link":"#自旋锁的示例","children":[]},{"level":3,"title":"适用场景：","slug":"适用场景","link":"#适用场景","children":[]},{"level":3,"title":"总结：","slug":"总结","link":"#总结","children":[]}],"readingTime":{"minutes":3.07,"words":921},"filePathRelative":"Interview/黑马Java2023/08并发编程/02并发安全/8.什么是自旋锁.md","excerpt":"\\n<div class=\\"hint-container important\\">\\n<p class=\\"hint-container-title\\">重要</p>\\n<p>自旋锁（Spinlock）是一种同步机制，用于在并发编程中保护共享资源，避免多个线程或进程同时访问同一资源。自旋锁的核心思想是，当一个线程尝试获取锁时，如果锁已经被其他线程持有，它不会进入休眠状态（像传统的互斥锁），而是持续地在<code>循环中“自旋”</code>，不断地检查锁是否可用，直到成功获取锁。</p>\\n</div>\\n<h3>自旋锁的工作原理：</h3>\\n<ol>\\n<li><strong>尝试获取锁</strong>：当线程请求锁时，如果锁当前没有被占用，线程立即获取锁并继续执行。</li>\\n<li><strong>自旋等待</strong>：如果锁已经被其他线程持有，线程不会进入阻塞状态，而是进入一个忙等待（自旋）的状态，不断地检查锁是否被释放。</li>\\n<li><strong>释放锁</strong>：当持有锁的线程完成任务后，它会释放锁，允许其他线程获取锁。</li>\\n</ol>"}')}}]);