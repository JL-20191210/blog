"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[8549],{66262:(e,r)=>{r.A=(e,r)=>{const n=e.__vccOpts||e;for(const[e,o]of r)n[e]=o;return n}},2309:(e,r,n)=>{n.r(r),n.d(r,{comp:()=>a,data:()=>s});var o=n(20641);const t={},a=(0,n(66262).A)(t,[["render",function(e,r){return(0,o.uX)(),(0,o.CE)("div",null,r[0]||(r[0]=[(0,o.Fv)('<h1 id="☕-设计模式" tabindex="-1"><a class="header-anchor" href="#☕-设计模式"><span>☕ 设计模式</span></a></h1><p>设计模式是软件工程中常用的解决特定问题的模版或者蓝图，可以帮助我们开发者以一种更加清晰、高效和可重用的方式来编写代码。</p><p>通常分为三类：</p><ul><li><code>创建型模式</code>：涉及对象实例化，用于创建对象的模式，可以增加程序的灵活性和可重用性。常见的创建型模式有工厂方法、抽象工厂、单例、建造者、原型等。</li><li><code>结构型模式</code>：涉及类和对象的组合，用于设计类和对象的结构，以便更好地实现程序的功能。常见的结构型模式有适配器、桥接、组合、装饰、外观、享元、代理等。</li><li><code>行为型模式</code>：关注对象之间的通信，包括责任链、命令、解释器、迭代器、中介者、备忘录、观察者、状态、策略、模板方法、访问者等。</li></ul><h2 id="_1️⃣-单例模式-singleton" tabindex="-1"><a class="header-anchor" href="#_1️⃣-单例模式-singleton"><span>1️⃣ 单例模式（Singleton）</span></a></h2><p><strong>一句话定义</strong>：保证一个类只有一个实例，并提供全局访问点。 <strong>示例</strong>：<code>Logger.getInstance()</code> 全局唯一使用。</p><hr><h2 id="_2️⃣-工厂模式-factory" tabindex="-1"><a class="header-anchor" href="#_2️⃣-工厂模式-factory"><span>2️⃣ 工厂模式（Factory）</span></a></h2><p><strong>一句话定义</strong>：定义一个创建对象的接口，让子类决定实例化哪一个类。 <strong>示例</strong>：<code>ShapeFactory.create(&quot;Circle&quot;)</code> 返回不同形状对象。</p><hr><h2 id="_3️⃣-观察者模式-observer" tabindex="-1"><a class="header-anchor" href="#_3️⃣-观察者模式-observer"><span>3️⃣ 观察者模式（Observer）</span></a></h2><p><strong>一句话定义</strong>：当一个对象状态改变时，所有依赖对象自动更新。 <strong>示例</strong>：新闻订阅系统，新闻发布后所有订阅者收到通知。</p><hr><h2 id="_4️⃣-策略模式-strategy" tabindex="-1"><a class="header-anchor" href="#_4️⃣-策略模式-strategy"><span>4️⃣ 策略模式（Strategy）</span></a></h2><p><strong>一句话定义</strong>：定义一系列算法，将每个算法封装，使它们可互换。 <strong>示例</strong>：支付方式选择：<code>PayContext(new WeChatPay()).pay()</code>。</p><hr><h2 id="_5️⃣-装饰器模式-decorator" tabindex="-1"><a class="header-anchor" href="#_5️⃣-装饰器模式-decorator"><span>5️⃣ 装饰器模式（Decorator）</span></a></h2><p><strong>一句话定义</strong>：在不改变对象接口的情况下，动态给对象添加功能。 <strong>示例</strong>：<code>InputStream</code> + <code>BufferedInputStream</code> 增加缓冲功能。</p><hr><h2 id="_6️⃣-责任链模式-chain-of-responsibility" tabindex="-1"><a class="header-anchor" href="#_6️⃣-责任链模式-chain-of-responsibility"><span>6️⃣ 责任链模式（Chain of Responsibility）</span></a></h2><p><strong>一句话定义</strong>：请求沿处理链传递，直到有对象处理它。 <strong>示例</strong>：请假审批流程：班主任 → 系主任 → 院长。</p><hr><h2 id="_7️⃣-建造者模式-builder" tabindex="-1"><a class="header-anchor" href="#_7️⃣-建造者模式-builder"><span>7️⃣ 建造者模式（Builder）</span></a></h2><p><strong>一句话定义</strong>：将复杂对象的构建和表示分离，使构建过程独立。 <strong>示例</strong>：<code>User.builder().name(&quot;Jack&quot;).age(27).build()</code> 构建复杂对象。</p><hr><h2 id="_8️⃣-代理模式-proxy" tabindex="-1"><a class="header-anchor" href="#_8️⃣-代理模式-proxy"><span>8️⃣ 代理模式（Proxy）</span></a></h2><p><strong>一句话定义</strong>：为另一个对象提供代理，以控制对原对象的访问。 <strong>示例</strong>：图片懒加载代理：<code>ProxyImage</code> 先不加载真实图片，调用时才加载。</p><hr><p>✅ <strong>讲解技巧</strong>：</p><ol><li>先一句话定义概念</li><li>举一个 Java 或生活中的简单例子</li><li>不用深入实现细节，面试官通常看你对模式理解程度</li></ol>',30)]))}]]),s=JSON.parse('{"path":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html","title":"☕ 设计模式","lang":"zh-CN","frontmatter":{"gitInclude":[]},"headers":[{"level":2,"title":"1️⃣ 单例模式（Singleton）","slug":"_1️⃣-单例模式-singleton","link":"#_1️⃣-单例模式-singleton","children":[]},{"level":2,"title":"2️⃣ 工厂模式（Factory）","slug":"_2️⃣-工厂模式-factory","link":"#_2️⃣-工厂模式-factory","children":[]},{"level":2,"title":"3️⃣ 观察者模式（Observer）","slug":"_3️⃣-观察者模式-observer","link":"#_3️⃣-观察者模式-observer","children":[]},{"level":2,"title":"4️⃣ 策略模式（Strategy）","slug":"_4️⃣-策略模式-strategy","link":"#_4️⃣-策略模式-strategy","children":[]},{"level":2,"title":"5️⃣ 装饰器模式（Decorator）","slug":"_5️⃣-装饰器模式-decorator","link":"#_5️⃣-装饰器模式-decorator","children":[]},{"level":2,"title":"6️⃣ 责任链模式（Chain of Responsibility）","slug":"_6️⃣-责任链模式-chain-of-responsibility","link":"#_6️⃣-责任链模式-chain-of-responsibility","children":[]},{"level":2,"title":"7️⃣ 建造者模式（Builder）","slug":"_7️⃣-建造者模式-builder","link":"#_7️⃣-建造者模式-builder","children":[]},{"level":2,"title":"8️⃣ 代理模式（Proxy）","slug":"_8️⃣-代理模式-proxy","link":"#_8️⃣-代理模式-proxy","children":[]}],"readingTime":{"minutes":2.2,"words":659},"filePathRelative":"设计模式/设计模式.md","excerpt":"\\n<p>设计模式是软件工程中常用的解决特定问题的模版或者蓝图，可以帮助我们开发者以一种更加清晰、高效和可重用的方式来编写代码。</p>\\n<p>通常分为三类：</p>\\n<ul>\\n<li><code>创建型模式</code>：涉及对象实例化，用于创建对象的模式，可以增加程序的灵活性和可重用性。常见的创建型模式有工厂方法、抽象工厂、单例、建造者、原型等。</li>\\n<li><code>结构型模式</code>：涉及类和对象的组合，用于设计类和对象的结构，以便更好地实现程序的功能。常见的结构型模式有适配器、桥接、组合、装饰、外观、享元、代理等。</li>\\n<li><code>行为型模式</code>：关注对象之间的通信，包括责任链、命令、解释器、迭代器、中介者、备忘录、观察者、状态、策略、模板方法、访问者等。</li>\\n</ul>"}')}}]);