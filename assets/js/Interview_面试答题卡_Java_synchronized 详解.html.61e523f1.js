"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[86823],{66262:(i,s)=>{s.A=(i,s)=>{const n=i.__vccOpts||i;for(const[i,t]of s)n[i]=t;return n}},9173:(i,s,n)=>{n.r(s),n.d(s,{comp:()=>e,data:()=>d});var t=n(20641);const a={},e=(0,n(66262).A)(a,[["render",function(i,s){return(0,t.uX)(),(0,t.CE)("div",null,s[0]||(s[0]=[(0,t.Fv)('<h1 id="☕-java-面试答题卡-synchronized-详解" tabindex="-1"><a class="header-anchor" href="#☕-java-面试答题卡-synchronized-详解"><span>☕ Java 面试答题卡：<code>synchronized</code> 详解</span></a></h1><h2 id="✅-1-synchronized-是什么" tabindex="-1"><a class="header-anchor" href="#✅-1-synchronized-是什么"><span>✅ 1. <code>synchronized</code> 是什么？</span></a></h2><blockquote><p><code>synchronized</code> 是 Java 提供的一种<strong>内置锁机制</strong>，用于实现线程之间的<strong>互斥与可见性</strong>。它可以修饰方法或代码块，确保同一时间只能有一个线程访问被锁定的资源。</p></blockquote><h2 id="✅-2-三种基本用法" tabindex="-1"><a class="header-anchor" href="#✅-2-三种基本用法"><span>✅ 2. 三种基本用法</span></a></h2><table><thead><tr><th>用法形式</th><th>说明</th></tr></thead><tbody><tr><td><code>synchronized 方法</code></td><td>修饰实例方法，锁的是<strong>当前对象 this</strong></td></tr><tr><td><code>synchronized static 方法</code></td><td>修饰静态方法，锁的是<strong>类对象 Class&lt;?&gt;</strong></td></tr><tr><td><code>synchronized (obj)</code> 代码块</td><td>显式锁定某个对象</td></tr></tbody></table><h3 id="示例代码" tabindex="-1"><a class="header-anchor" href="#示例代码"><span>示例代码：</span></a></h3><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> synchronized</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> instanceMethod</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">() { }          </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 锁 this</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> synchronized</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> staticMethod</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">() { }     </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 锁 类的 Class 对象</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> customLock</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">() {</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    synchronized</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (lockObj) { </span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">...</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> }                     </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 锁指定对象</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="✅-3-synchronized-保证了哪些" tabindex="-1"><a class="header-anchor" href="#✅-3-synchronized-保证了哪些"><span>✅ 3. <code>synchronized</code> 保证了哪些？</span></a></h2><table><thead><tr><th>作用</th><th>描述</th></tr></thead><tbody><tr><td>互斥</td><td>同一时刻只有一个线程能进入被锁定的临界区</td></tr><tr><td>可见性</td><td>锁释放前，线程对共享变量的修改对其他线程立即可见（JMM 保证）</td></tr><tr><td>原子性</td><td>被 <code>synchronized</code> 包裹的操作是不可中断的（不会被打断执行一半）</td></tr></tbody></table><h2 id="✅-4-底层原理jdk-1-6" tabindex="-1"><a class="header-anchor" href="#✅-4-底层原理jdk-1-6"><span>✅ 4. 底层原理JDK 1.6+）</span></a></h2><p><code>synchronized</code> 的锁是基于<strong>对象头中的 monitor（监视器锁）</strong> 实现的。</p><h3 id="锁的状态-偏向锁-→-轻量级锁-→-重量级锁" tabindex="-1"><a class="header-anchor" href="#锁的状态-偏向锁-→-轻量级锁-→-重量级锁"><span>锁的状态（偏向锁 → 轻量级锁 → 重量级锁）</span></a></h3><table><thead><tr><th>锁状态</th><th>特点</th><th>适用场景</th></tr></thead><tbody><tr><td>无锁</td><td>默认状态，无竞争</td><td>单线程场景</td></tr><tr><td>偏向锁</td><td>第一次加锁记录线程 ID</td><td>线程长期访问一个对象</td></tr><tr><td>轻量级锁</td><td>多线程尝试加锁，使用自旋</td><td>多线程短时间竞争</td></tr><tr><td>重量级锁</td><td>自旋失败，阻塞其他线程</td><td>高竞争，线程频繁切换</td></tr></tbody></table><blockquote><p>JVM 会根据竞争情况自动升级和降级锁状态，无需开发者干预。</p></blockquote><h2 id="✅-5-对应字节码指令" tabindex="-1"><a class="header-anchor" href="#✅-5-对应字节码指令"><span>✅ 5. 对应字节码指令</span></a></h2><ul><li><code>synchronized</code> 代码块 → <code>monitorenter</code> / <code>monitorexit</code></li><li><code>synchronized</code> 方法 → <code>ACC_SYNCHRONIZED</code> 标志位</li></ul><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> synchronized</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> foo</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">() { } </span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 编译后在字节码中标记方法为 ACC_SYNCHRONIZED</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="✅-6-synchronized-与-volatile-的区别" tabindex="-1"><a class="header-anchor" href="#✅-6-synchronized-与-volatile-的区别"><span>✅ 6. synchronized 与 volatile 的区别</span></a></h2><table><thead><tr><th>特性</th><th><code>synchronized</code></th><th><code>volatile</code></th></tr></thead><tbody><tr><td>互斥性</td><td>✅ 有</td><td>❌ 无</td></tr><tr><td>可见性</td><td>✅ 有</td><td>✅ 有</td></tr><tr><td>原子性</td><td>✅ 有</td><td>❌ 无</td></tr><tr><td>使用场景</td><td>多线程访问共享资源</td><td>状态标志、单变量读写</td></tr></tbody></table><h2 id="✅-7-性能优化-jdk-1-6-后" tabindex="-1"><a class="header-anchor" href="#✅-7-性能优化-jdk-1-6-后"><span>✅ 7. 性能优化（JDK 1.6 后）</span></a></h2><p>JVM 针对 <code>synchronized</code> 做了大量优化：</p><ul><li><strong>锁粗化（Lock Coarsening）</strong></li><li><strong>锁消除（Lock Elimination）</strong></li><li><strong>偏向锁 / 轻量级锁 / 自旋锁</strong></li><li><strong>TLAB（线程本地分配缓存）</strong></li></ul><p>这些优化使得 <code>synchronized</code> 的性能大大提升，<strong>不再是“低性能代名词”</strong>！</p><h2 id="✅-8-面试常问问题与答案" tabindex="-1"><a class="header-anchor" href="#✅-8-面试常问问题与答案"><span>✅ 8. 面试常问问题与答案</span></a></h2><h3 id="q1-synchronized-和-lock-有什么区别" tabindex="-1"><a class="header-anchor" href="#q1-synchronized-和-lock-有什么区别"><span>Q1：synchronized 和 Lock 有什么区别？</span></a></h3><table><thead><tr><th>维度</th><th><code>synchronized</code></th><th><code>ReentrantLock</code></th></tr></thead><tbody><tr><td>可重入</td><td>✅ 支持</td><td>✅ 支持</td></tr><tr><td>中断响应</td><td>❌ 不支持</td><td>✅ 支持中断</td></tr><tr><td>是否公平锁</td><td>❌ 非公平</td><td>✅ 可配置为公平</td></tr><tr><td>可尝试获取</td><td>❌ 不支持</td><td>✅ tryLock() 支持超时/失败控制</td></tr><tr><td>条件变量</td><td>❌ 内部条件单一</td><td>✅ 可创建多个 Condition</td></tr></tbody></table><h3 id="q2-synchronized-会锁住整个对象吗" tabindex="-1"><a class="header-anchor" href="#q2-synchronized-会锁住整个对象吗"><span>Q2：synchronized 会锁住整个对象吗？</span></a></h3><p>不是。它的锁粒度取决于加在哪：</p><ul><li>加在实例方法：锁住的是<strong>当前对象（this）</strong></li><li>加在静态方法：锁住的是<strong>类对象（Class）</strong></li><li>加在代码块：锁的是<strong>指定对象引用</strong></li></ul><h3 id="q3-锁升级机制能否手动控制" tabindex="-1"><a class="header-anchor" href="#q3-锁升级机制能否手动控制"><span>Q3：锁升级机制能否手动控制？</span></a></h3><p>不能，JVM 会<strong>自动</strong>根据线程竞争情况进行升级（从偏向锁→轻量级锁→重量级锁），开发者只能控制是否开启偏向锁（通过 JVM 参数）。</p><h2 id="✅-9-示例-synchronized-的可重入性" tabindex="-1"><a class="header-anchor" href="#✅-9-示例-synchronized-的可重入性"><span>✅ 9. 示例：synchronized 的可重入性</span></a></h2><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> ReentrantExample</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> synchronized</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> method1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;method1&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">        method2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> synchronized</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> method2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;method2&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> main</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[] </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">args</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> ReentrantExample</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">().</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">method1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>method1</span></span>\n<span class="line"><span>method2</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>说明：同一个线程进入了两次锁（<strong>可重入性</strong>）。</p><h2 id="🎯-面试答题模板-建议背诵" tabindex="-1"><a class="header-anchor" href="#🎯-面试答题模板-建议背诵"><span>🎯 面试答题模板（建议背诵）</span></a></h2><blockquote><p><code>synchronized</code> 是 Java 提供的内置锁机制，用于保证多线程访问共享资源时的线程安全。它可以修饰方法或代码块，分别锁住实例或类对象。底层通过对象的 Monitor 实现，并支持锁的升级（偏向锁、轻量级锁、重量级锁）以提高性能。与 Lock 相比，synchronized 使用更简单，但灵活性略差。</p></blockquote>',38)]))}]]),d=JSON.parse('{"path":"/Interview/%E9%9D%A2%E8%AF%95%E7%AD%94%E9%A2%98%E5%8D%A1/Java/synchronized%20%E8%AF%A6%E8%A7%A3.html","title":"☕ Java 面试答题卡：synchronized 详解","lang":"zh-CN","frontmatter":{"gitInclude":[]},"headers":[{"level":2,"title":"✅ 1. synchronized 是什么？","slug":"✅-1-synchronized-是什么","link":"#✅-1-synchronized-是什么","children":[]},{"level":2,"title":"✅ 2. 三种基本用法","slug":"✅-2-三种基本用法","link":"#✅-2-三种基本用法","children":[{"level":3,"title":"示例代码：","slug":"示例代码","link":"#示例代码","children":[]}]},{"level":2,"title":"✅ 3. synchronized 保证了哪些？","slug":"✅-3-synchronized-保证了哪些","link":"#✅-3-synchronized-保证了哪些","children":[]},{"level":2,"title":"✅ 4. 底层原理JDK 1.6+）","slug":"✅-4-底层原理jdk-1-6","link":"#✅-4-底层原理jdk-1-6","children":[{"level":3,"title":"锁的状态（偏向锁 → 轻量级锁 → 重量级锁）","slug":"锁的状态-偏向锁-→-轻量级锁-→-重量级锁","link":"#锁的状态-偏向锁-→-轻量级锁-→-重量级锁","children":[]}]},{"level":2,"title":"✅ 5. 对应字节码指令","slug":"✅-5-对应字节码指令","link":"#✅-5-对应字节码指令","children":[]},{"level":2,"title":"✅ 6. synchronized 与 volatile 的区别","slug":"✅-6-synchronized-与-volatile-的区别","link":"#✅-6-synchronized-与-volatile-的区别","children":[]},{"level":2,"title":"✅ 7. 性能优化（JDK 1.6 后）","slug":"✅-7-性能优化-jdk-1-6-后","link":"#✅-7-性能优化-jdk-1-6-后","children":[]},{"level":2,"title":"✅ 8. 面试常问问题与答案","slug":"✅-8-面试常问问题与答案","link":"#✅-8-面试常问问题与答案","children":[{"level":3,"title":"Q1：synchronized 和 Lock 有什么区别？","slug":"q1-synchronized-和-lock-有什么区别","link":"#q1-synchronized-和-lock-有什么区别","children":[]},{"level":3,"title":"Q2：synchronized 会锁住整个对象吗？","slug":"q2-synchronized-会锁住整个对象吗","link":"#q2-synchronized-会锁住整个对象吗","children":[]},{"level":3,"title":"Q3：锁升级机制能否手动控制？","slug":"q3-锁升级机制能否手动控制","link":"#q3-锁升级机制能否手动控制","children":[]}]},{"level":2,"title":"✅ 9. 示例：synchronized 的可重入性","slug":"✅-9-示例-synchronized-的可重入性","link":"#✅-9-示例-synchronized-的可重入性","children":[]},{"level":2,"title":"🎯 面试答题模板（建议背诵）","slug":"🎯-面试答题模板-建议背诵","link":"#🎯-面试答题模板-建议背诵","children":[]}],"readingTime":{"minutes":3.2,"words":959},"filePathRelative":"Interview/面试答题卡/Java/synchronized 详解.md","excerpt":"\\n<h2>✅ 1. <code>synchronized</code> 是什么？</h2>\\n<blockquote>\\n<p><code>synchronized</code> 是 Java 提供的一种<strong>内置锁机制</strong>，用于实现线程之间的<strong>互斥与可见性</strong>。它可以修饰方法或代码块，确保同一时间只能有一个线程访问被锁定的资源。</p>\\n</blockquote>\\n<h2>✅ 2. 三种基本用法</h2>\\n<table>\\n<thead>\\n<tr>\\n<th>用法形式</th>\\n<th>说明</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td><code>synchronized 方法</code></td>\\n<td>修饰实例方法，锁的是<strong>当前对象 this</strong></td>\\n</tr>\\n<tr>\\n<td><code>synchronized static 方法</code></td>\\n<td>修饰静态方法，锁的是<strong>类对象 Class&lt;?&gt;</strong></td>\\n</tr>\\n<tr>\\n<td><code>synchronized (obj)</code> 代码块</td>\\n<td>显式锁定某个对象</td>\\n</tr>\\n</tbody>\\n</table>"}')}}]);