"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[80994],{66262:(e,n)=>{n.A=(e,n)=>{const l=e.__vccOpts||e;for(const[e,o]of n)l[e]=o;return l}},44974:(e,n,l)=>{l.r(n),l.d(n,{comp:()=>c,data:()=>a});var o=l(20641);const d={},c=(0,l(66262).A)(d,[["render",function(e,n){return(0,o.uX)(),(0,o.CE)("div",null,[n[0]||(n[0]=(0,o.Lk)("h1",{id:"核心概念理解",tabindex:"-1"},[(0,o.Lk)("a",{class:"header-anchor",href:"#核心概念理解"},[(0,o.Lk)("span",null,"核心概念理解")])],-1)),n[1]||(n[1]=(0,o.Lk)("h3",{id:"_1-树立正确的观念",tabindex:"-1"},[(0,o.Lk)("a",{class:"header-anchor",href:"#_1-树立正确的观念"},[(0,o.Lk)("span",null,[(0,o.eW)("1. "),(0,o.Lk)("strong",null,"树立正确的观念：")])])],-1)),n[2]||(n[2]=(0,o.Lk)("ul",null,[(0,o.Lk)("li",null,"在开始使用 Netty 之前，首先要有一个整体的框架观念，理解每个概念如何配合工作，才能更好地掌握 Netty。")],-1)),(0,o.Q3)(" more "),n[3]||(n[3]=(0,o.Fv)('<h3 id="_2-把-channel-理解为数据的通道" tabindex="-1"><a class="header-anchor" href="#_2-把-channel-理解为数据的通道"><span>2. <strong>把 <code>Channel</code> 理解为数据的通道：</strong></span></a></h3><ul><li><code>Channel</code> 就像是数据的传输通道，它连接着客户端和服务器。你可以想象它就像高速公路，数据从源头通过 <code>Channel</code> 传输到目的地。<code>Channel</code> 是基础的连接单元，负责网络连接的建立、数据的读写。</li></ul><h3 id="_3-把-msg-理解为流动的数据" tabindex="-1"><a class="header-anchor" href="#_3-把-msg-理解为流动的数据"><span>3. <strong>把 <code>msg</code> 理解为流动的数据：</strong></span></a></h3><ul><li>数据在 Netty 中的流动是通过 <code>msg</code> 表示的。最初，它是 <code>ByteBuf</code> 类型，意味着数据是以字节形式传输的。随着数据经过 <code>pipeline</code> 的多个 <code>handler</code>（数据处理步骤），这些字节数据会被转换成其他更高层次的对象（比如 Java 对象），直到最终再转化回 <code>ByteBuf</code>（或其他形式）进行输出。</li></ul><h3 id="_4-把-handler-理解为数据的处理工序" tabindex="-1"><a class="header-anchor" href="#_4-把-handler-理解为数据的处理工序"><span>4. <strong>把 <code>handler</code> 理解为数据的处理工序：</strong></span></a></h3><ul><li>每个 <code>handler</code> 负责对数据进行某种处理，就像流水线上的每道工序。一个 <code>handler</code> 可能负责解码数据（比如将字节数据转成对象），另一个 <code>handler</code> 负责处理业务逻辑，第三个 <code>handler</code> 负责编码数据（将对象转为字节数据）。</li><li>多个 <code>handler</code> 按顺序排列在 <code>pipeline</code> 中，共同完成数据处理的任务。</li></ul><h3 id="_5-pipeline-负责发布事件并传播给每个-handler" tabindex="-1"><a class="header-anchor" href="#_5-pipeline-负责发布事件并传播给每个-handler"><span>5. <strong><code>pipeline</code> 负责发布事件并传播给每个 <code>handler</code>：</strong></span></a></h3><ul><li><code>pipeline</code> 就是多个 <code>handler</code> 的集合，是一个处理数据的流水线。<code>pipeline</code> 会根据不同的事件类型（如读取数据、数据读取完成等）将事件发布给各个 <code>handler</code>，而每个 <code>handler</code> 会根据自己感兴趣的事件来进行处理。</li></ul><h3 id="_6-handler-分为-inbound-和-outbound-两类" tabindex="-1"><a class="header-anchor" href="#_6-handler-分为-inbound-和-outbound-两类"><span>6. <strong><code>handler</code> 分为 Inbound 和 Outbound 两类：</strong></span></a></h3><ul><li><strong>Inbound</strong>：处理接收的数据，如解码操作。Inbound 处理的是从外部流入的数据。</li><li><strong>Outbound</strong>：处理发送的数据，如编码操作。Outbound 处理的是将数据输出到外部的过程。</li><li>每个 <code>handler</code> 只处理它关注的事件（Inbound 或 Outbound）。</li></ul><h3 id="_7-把-eventloop-理解为处理数据的工人" tabindex="-1"><a class="header-anchor" href="#_7-把-eventloop-理解为处理数据的工人"><span>7. <strong>把 <code>EventLoop</code> 理解为处理数据的工人：</strong></span></a></h3><ul><li><code>EventLoop</code> 就像一个工人，负责处理 <code>Channel</code> 的 I/O 操作。一个工人（<code>EventLoop</code>）可以负责多个 <code>Channel</code> 的 I/O 操作。这个工人负责读取数据、处理数据并将其发送出去，直到任务完成。</li><li><code>EventLoop</code> 不仅执行 I/O 操作，还会处理一些其他的任务，像定时任务或其他后台任务。</li></ul><h3 id="_8-任务队列与任务类型" tabindex="-1"><a class="header-anchor" href="#_8-任务队列与任务类型"><span>8. <strong>任务队列与任务类型：</strong></span></a></h3><ul><li>每个 <code>EventLoop</code> 会有一个任务队列，任务可以是普通任务（比如读取或写入数据），也可以是定时任务（比如每隔一定时间执行某个操作）。</li><li>这些任务会根据 <code>EventLoop</code> 的工作流程进行处理，类似于工人在生产线上的工作，任务会被依次处理。</li></ul><h3 id="_9-工人按照-pipeline-顺序处理数据" tabindex="-1"><a class="header-anchor" href="#_9-工人按照-pipeline-顺序处理数据"><span>9. <strong>工人按照 <code>pipeline</code> 顺序处理数据：</strong></span></a></h3><ul><li>工人（<code>EventLoop</code>）按照 <code>pipeline</code> 的顺序来执行任务。每个 <code>handler</code> 就像工人执行任务的工序，任务按顺序处理，可以为每个工序分配不同的工人（<code>EventLoop</code>）。</li></ul><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结：</span></a></h3><ul><li><strong><code>Channel</code></strong>：数据的传输通道，像高速公路，负责数据的传递。</li><li><strong><code>msg</code></strong>：流动的数据，最开始是 <code>ByteBuf</code>，通过多道工序加工，变成其他类型，最后又转回 <code>ByteBuf</code>。</li><li><strong><code>handler</code></strong>：处理数据的工序，每个 <code>handler</code> 负责处理特定类型的事件（Inbound 或 Outbound）。</li><li><strong><code>pipeline</code></strong>：多个 <code>handler</code> 组成的流水线，负责按顺序处理数据。</li><li><strong><code>EventLoop</code></strong>：负责执行 I/O 操作的工人，处理多个 <code>Channel</code> 的任务，工人有自己的任务队列。</li><li><strong>任务队列</strong>：用于管理待处理的任务，分为普通任务和定时任务，任务按照顺序由 <code>EventLoop</code> 执行。</li></ul>',18))])}]]),a=JSON.parse('{"path":"/Netty/%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3.html","title":"核心概念理解","lang":"zh-CN","frontmatter":{"icon":"pen-to-square","date":"2025-02-11T00:00:00.000Z","category":["Netty"],"tag":["网络编程"],"gitInclude":[]},"headers":[{"level":3,"title":"1. 树立正确的观念：","slug":"_1-树立正确的观念","link":"#_1-树立正确的观念","children":[]},{"level":3,"title":"2. 把 Channel 理解为数据的通道：","slug":"_2-把-channel-理解为数据的通道","link":"#_2-把-channel-理解为数据的通道","children":[]},{"level":3,"title":"3. 把 msg 理解为流动的数据：","slug":"_3-把-msg-理解为流动的数据","link":"#_3-把-msg-理解为流动的数据","children":[]},{"level":3,"title":"4. 把 handler 理解为数据的处理工序：","slug":"_4-把-handler-理解为数据的处理工序","link":"#_4-把-handler-理解为数据的处理工序","children":[]},{"level":3,"title":"5. pipeline 负责发布事件并传播给每个 handler：","slug":"_5-pipeline-负责发布事件并传播给每个-handler","link":"#_5-pipeline-负责发布事件并传播给每个-handler","children":[]},{"level":3,"title":"6. handler 分为 Inbound 和 Outbound 两类：","slug":"_6-handler-分为-inbound-和-outbound-两类","link":"#_6-handler-分为-inbound-和-outbound-两类","children":[]},{"level":3,"title":"7. 把 EventLoop 理解为处理数据的工人：","slug":"_7-把-eventloop-理解为处理数据的工人","link":"#_7-把-eventloop-理解为处理数据的工人","children":[]},{"level":3,"title":"8. 任务队列与任务类型：","slug":"_8-任务队列与任务类型","link":"#_8-任务队列与任务类型","children":[]},{"level":3,"title":"9. 工人按照 pipeline 顺序处理数据：","slug":"_9-工人按照-pipeline-顺序处理数据","link":"#_9-工人按照-pipeline-顺序处理数据","children":[]},{"level":3,"title":"总结：","slug":"总结","link":"#总结","children":[]}],"readingTime":{"minutes":3.21,"words":964},"filePathRelative":"Netty/核心概念理解.md","localizedDate":"2025年2月11日","excerpt":"\\n<h3>1. <strong>树立正确的观念：</strong></h3>\\n<ul>\\n<li>在开始使用 Netty 之前，首先要有一个整体的框架观念，理解每个概念如何配合工作，才能更好地掌握 Netty。</li>\\n</ul>\\n"}')}}]);