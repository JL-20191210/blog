"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[15836],{66262:(n,s)=>{s.A=(n,s)=>{const i=n.__vccOpts||n;for(const[n,e]of s)i[n]=e;return i}},1012:(n,s,i)=>{i.r(s),i.d(s,{comp:()=>l,data:()=>t});var e=i(20641);const a={},l=(0,i(66262).A)(a,[["render",function(n,s){return(0,e.uX)(),(0,e.CE)("div",null,s[0]||(s[0]=[(0,e.Fv)('<h1 id="☕-java面试答题卡-为什么arraylist不是线程安全的" tabindex="-1"><a class="header-anchor" href="#☕-java面试答题卡-为什么arraylist不是线程安全的"><span>☕ Java面试答题卡：为什么ArrayList不是线程安全的？</span></a></h1><h2 id="✅-1-结论先行" tabindex="-1"><a class="header-anchor" href="#✅-1-结论先行"><span>✅ 1. 结论先行</span></a></h2><blockquote><p>ArrayList <strong>不是线程安全的</strong>，因为它的<strong>增删查改操作没有任何同步控制</strong>，多个线程同时修改共享的 ArrayList 实例，可能导致：</p></blockquote><ul><li>数据丢失</li><li>越界异常</li><li>并发修改异常（ConcurrentModificationException）</li><li>元素覆盖或脏读</li></ul><h2 id="✅-2-哪些方法不安全-举例说明" tabindex="-1"><a class="header-anchor" href="#✅-2-哪些方法不安全-举例说明"><span><strong>✅ 2. 哪些方法不安全？举例说明</strong></span></a></h2><p>来看 ArrayList 常用方法的源码（简化版）：</p><h3 id="🔸-add-e-e" tabindex="-1"><a class="header-anchor" href="#🔸-add-e-e"><span><strong>🔸 add(E e)</strong></span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>public boolean add(E e) {</span></span>\n<span class="line"><span>    ensureCapacityInternal(size + 1);</span></span>\n<span class="line"><span>    elementData[size++] = e;</span></span>\n<span class="line"><span>    return true;</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><strong>未加锁</strong></li><li>size++ 是非原子操作</li><li>多线程同时 add()，可能导致数据丢失或数组越界</li></ul><h3 id="🔸-get-int-index" tabindex="-1"><a class="header-anchor" href="#🔸-get-int-index"><span><strong>🔸 get(int index)</strong></span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>public E get(int index) {</span></span>\n<span class="line"><span>    return elementData[index]; // 也未加锁</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>如果此时其他线程在删除或扩容，可能读到错误值或抛出 IndexOutOfBoundsException</li></ul><h3 id="🔸-remove-int-index" tabindex="-1"><a class="header-anchor" href="#🔸-remove-int-index"><span><strong>🔸 remove(int index)</strong></span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>public E remove(int index) {</span></span>\n<span class="line"><span>    E oldValue = elementData[index];</span></span>\n<span class="line"><span>    int numMoved = size - index - 1;</span></span>\n<span class="line"><span>    System.arraycopy(elementData, index + 1, elementData, index, numMoved);</span></span>\n<span class="line"><span>    elementData[--size] = null;</span></span>\n<span class="line"><span>    return oldValue;</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>未加锁，且牵涉到数组移动和 size--</li><li>多线程操作时，可能导致： <ul><li>元素丢失</li><li>位置错乱</li><li>脏数据访问</li></ul></li></ul><h2 id="✅-3-多线程下的实际例子-数据丢失" tabindex="-1"><a class="header-anchor" href="#✅-3-多线程下的实际例子-数据丢失"><span><strong>✅ 3. 多线程下的实际例子（数据丢失）</strong></span></a></h2><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>Runnable task = () -&gt; {</span></span>\n<span class="line"><span>    for (int i = 0; i &lt; 1000; i++) {</span></span>\n<span class="line"><span>        list.add(i);</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>};</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>Thread t1 = new Thread(task);</span></span>\n<span class="line"><span>Thread t2 = new Thread(task);</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>t1.start();</span></span>\n<span class="line"><span>t2.start();</span></span>\n<span class="line"><span>t1.join();</span></span>\n<span class="line"><span>t2.join();</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>System.out.println(&quot;实际大小：&quot; + list.size()); // 小于 2000，说明丢数据了！</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="✅-4-为何不是线程安全的核心原因" tabindex="-1"><a class="header-anchor" href="#✅-4-为何不是线程安全的核心原因"><span><strong>✅ 4. 为何不是线程安全的核心原因？</strong></span></a></h2><table><thead><tr><th><strong>原因</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>没有加锁机制</td><td>所有方法中没有 synchronized、ReentrantLock 等控制</td></tr><tr><td>size++ 非原子</td><td>并发下会覆盖写入或跳过更新</td></tr><tr><td>内部数组 elementData 暴露</td><td>无保护机制，导致并发读写冲突</td></tr><tr><td>缺乏并发读写隔离</td><td>没有使用 volatile、不可变结构或复制机制</td></tr></tbody></table><h2 id="✅-5-如何让它线程安全" tabindex="-1"><a class="header-anchor" href="#✅-5-如何让它线程安全"><span><strong>✅ 5. 如何让它线程安全？</strong></span></a></h2><h3 id="✅-方式一-使用包装器" tabindex="-1"><a class="header-anchor" href="#✅-方式一-使用包装器"><span><strong>✅ 方式一：使用包装器</strong></span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>List&lt;String&gt; safeList = Collections.synchronizedList(new ArrayList&lt;&gt;());</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li>内部方法加了 synchronized</li><li>迭代时仍需手动加锁（否则仍可能抛异常）：</li></ul><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>synchronized (safeList) {</span></span>\n<span class="line"><span>    for (String s : safeList) {</span></span>\n<span class="line"><span>        // 安全迭代</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="✅-方式二-使用并发集合" tabindex="-1"><a class="header-anchor" href="#✅-方式二-使用并发集合"><span><strong>✅ 方式二：使用并发集合</strong></span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;();</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li>读写隔离，读无锁，写复制，适合读多写少的场景</li></ul><h2 id="✅-6-面试答题模板-建议背诵" tabindex="-1"><a class="header-anchor" href="#✅-6-面试答题模板-建议背诵"><span><strong>✅ 6. 面试答题模板（建议背诵）</strong></span></a></h2><div class="hint-container important"><p class="hint-container-title">重要</p><p>ArrayList 不是线程安全的，因为它没有任何同步机制。在多线程环境下同时进行 add()、remove() 或 get() 操作，会导致数据丢失、数组越界、并发修改异常等问题。主要原因是内部操作如 size++ 和数组移动是非原子的。解决方案包括使用 Collections.synchronizedList() 包装，或使用 CopyOnWriteArrayList 等并发集合类。</p></div>',29)]))}]]),t=JSON.parse('{"path":"/Interview/%E9%9D%A2%E8%AF%95%E7%AD%94%E9%A2%98%E5%8D%A1/Java/%E4%B8%BA%E4%BB%80%E4%B9%88%20ArrayList%20%E4%B8%8D%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84.html","title":"☕ Java面试答题卡：为什么ArrayList不是线程安全的？","lang":"zh-CN","frontmatter":{"gitInclude":[]},"headers":[{"level":2,"title":"✅ 1. 结论先行","slug":"✅-1-结论先行","link":"#✅-1-结论先行","children":[]},{"level":2,"title":"✅ 2. 哪些方法不安全？举例说明","slug":"✅-2-哪些方法不安全-举例说明","link":"#✅-2-哪些方法不安全-举例说明","children":[{"level":3,"title":"🔸 add(E e)","slug":"🔸-add-e-e","link":"#🔸-add-e-e","children":[]},{"level":3,"title":"🔸 get(int index)","slug":"🔸-get-int-index","link":"#🔸-get-int-index","children":[]},{"level":3,"title":"🔸 remove(int index)","slug":"🔸-remove-int-index","link":"#🔸-remove-int-index","children":[]}]},{"level":2,"title":"✅ 3. 多线程下的实际例子（数据丢失）","slug":"✅-3-多线程下的实际例子-数据丢失","link":"#✅-3-多线程下的实际例子-数据丢失","children":[]},{"level":2,"title":"✅ 4. 为何不是线程安全的核心原因？","slug":"✅-4-为何不是线程安全的核心原因","link":"#✅-4-为何不是线程安全的核心原因","children":[]},{"level":2,"title":"✅ 5. 如何让它线程安全？","slug":"✅-5-如何让它线程安全","link":"#✅-5-如何让它线程安全","children":[{"level":3,"title":"✅ 方式一：使用包装器","slug":"✅-方式一-使用包装器","link":"#✅-方式一-使用包装器","children":[]},{"level":3,"title":"✅ 方式二：使用并发集合","slug":"✅-方式二-使用并发集合","link":"#✅-方式二-使用并发集合","children":[]}]},{"level":2,"title":"✅ 6. 面试答题模板（建议背诵）","slug":"✅-6-面试答题模板-建议背诵","link":"#✅-6-面试答题模板-建议背诵","children":[]}],"readingTime":{"minutes":2.07,"words":621},"filePathRelative":"Interview/面试答题卡/Java/为什么 ArrayList 不是线程安全的.md","excerpt":"\\n<h2>✅ 1. 结论先行</h2>\\n<blockquote>\\n<p>ArrayList <strong>不是线程安全的</strong>，因为它的<strong>增删查改操作没有任何同步控制</strong>，多个线程同时修改共享的 ArrayList 实例，可能导致：</p>\\n</blockquote>\\n<ul>\\n<li>数据丢失</li>\\n<li>越界异常</li>\\n<li>并发修改异常（ConcurrentModificationException）</li>\\n<li>元素覆盖或脏读</li>\\n</ul>\\n<h2><strong>✅ 2. 哪些方法不安全？举例说明</strong></h2>"}')}}]);