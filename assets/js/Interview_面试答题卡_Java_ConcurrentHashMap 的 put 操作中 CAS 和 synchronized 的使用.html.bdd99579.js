"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[48110],{66262:(s,i)=>{i.A=(s,i)=>{const a=s.__vccOpts||s;for(const[s,n]of i)a[s]=n;return a}},4128:(s,i,a)=>{a.r(i),a.d(i,{comp:()=>h,data:()=>e});var n=a(20641);const l={},h=(0,a(66262).A)(l,[["render",function(s,i){return(0,n.uX)(),(0,n.CE)("div",null,i[0]||(i[0]=[(0,n.Fv)('<h1 id="☕-java-面试答题卡-concurrenthashmap-的-put-操作中-cas-和-synchronized-的使用" tabindex="-1"><a class="header-anchor" href="#☕-java-面试答题卡-concurrenthashmap-的-put-操作中-cas-和-synchronized-的使用"><span>☕ Java 面试答题卡：ConcurrentHashMap 的 put 操作中 CAS 和 synchronized 的使用</span></a></h1><hr><h2 id="✅-1-总体结构回顾-jdk-1-8" tabindex="-1"><a class="header-anchor" href="#✅-1-总体结构回顾-jdk-1-8"><span>✅ 1. 总体结构回顾（JDK 1.8）</span></a></h2><blockquote><p>JDK 1.8 的 <code>ConcurrentHashMap</code> 不再使用分段锁（Segment），而是使用：</p></blockquote><ul><li><strong>数组 + 链表 + 红黑树结构</strong></li><li><strong>节点槽位粒度的同步控制</strong></li><li>高效使用 <code>CAS + synchronized</code> 控制并发写入</li></ul><hr><h2 id="✅-2-put-流程图简化版" tabindex="-1"><a class="header-anchor" href="#✅-2-put-流程图简化版"><span>✅ 2. put() 流程图简化版</span></a></h2><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>put(key, val)</span></span>\n<span class="line"><span>   ↓</span></span>\n<span class="line"><span>定位桶 (index)</span></span>\n<span class="line"><span>   ↓</span></span>\n<span class="line"><span>[为空？] --- 是 --&gt; 用 CAS 插入（无需锁）</span></span>\n<span class="line"><span>   ↓ 否</span></span>\n<span class="line"><span>桶不为空（链表/红黑树）</span></span>\n<span class="line"><span>   ↓</span></span>\n<span class="line"><span>加 synchronized 锁（锁的是桶的首节点）</span></span>\n<span class="line"><span>   ↓</span></span>\n<span class="line"><span>插入 / 替换 / 树化等操作</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="✅-3-核心源码片段分析" tabindex="-1"><a class="header-anchor" href="#✅-3-核心源码片段分析"><span>✅ 3. 核心源码片段分析</span></a></h2><p>以 JDK 1.8 的 <code>putVal()</code> 为例：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">final</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> V</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> putVal</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">K</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> key</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> V</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> value</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> boolean</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> onlyIfAbsent) {</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    ...</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> hash </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> spread</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">key</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">hashCode</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> i </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (n </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">-</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> hash</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">    Node</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">K</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">V</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> f </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> tabAt</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(table</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> i)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // ✅ 第一步：桶为空，尝试用 CAS 插入新节点</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (f </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">==</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">casTabAt</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(table</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> i</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Node</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(hash</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> key</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> value</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">))) {</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">            break</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 插入成功，退出</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">        }</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    } </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">else</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> {</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // ❌ CAS 失败 or 桶已非空，使用 synchronized 加锁处理冲突</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        synchronized</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (f) {</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">            if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">tabAt</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(table</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> i) </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">==</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> f) {</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">                ...</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                // 链表添加 or 红黑树处理</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">            }</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">        }</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="✅-4-解释-cas-synchronized-的协作机制" tabindex="-1"><a class="header-anchor" href="#✅-4-解释-cas-synchronized-的协作机制"><span>✅ 4. 解释：CAS + synchronized 的协作机制</span></a></h2><table><thead><tr><th>阶段</th><th>机制</th><th>特点</th></tr></thead><tbody><tr><td>桶为空</td><td>使用 <code>CAS</code>（无锁插入）</td><td>高性能，减少锁竞争（适用于大多数并发插入场景）</td></tr><tr><td>CAS 失败 / 桶非空</td><td>使用 <code>synchronized</code> 加锁</td><td>竞争较大时保证线程安全，锁的是<strong>桶中首节点</strong></td></tr></tbody></table><hr><h2 id="✅-5-cas-是什么-为什么优先用它" tabindex="-1"><a class="header-anchor" href="#✅-5-cas-是什么-为什么优先用它"><span>✅ 5. CAS 是什么？为什么优先用它？</span></a></h2><ul><li><strong>CAS（Compare-And-Swap）</strong>：一种硬件原子指令，尝试把某个值从 A 改成 B，如果失败则返回 false</li><li>在 <code>put()</code> 中：用 <code>casTabAt()</code> 方法尝试将 table[i] 从 <code>null</code> 改为新节点</li><li>无锁高效 → 适合多线程首次向不同桶写入的情况</li></ul><hr><h2 id="✅-6-synchronized-是如何用的" tabindex="-1"><a class="header-anchor" href="#✅-6-synchronized-是如何用的"><span>✅ 6. synchronized 是如何用的？</span></a></h2><ul><li>如果该桶已经有节点（即发生 hash 冲突），则进入 <code>synchronized</code> 块</li><li>只对桶的<strong>头节点加锁</strong>，不是锁整个 map</li><li>保证该桶在链表插入或红黑树操作时线程安全</li></ul><hr><h2 id="✅-7-为什么这么设计-优点在哪" tabindex="-1"><a class="header-anchor" href="#✅-7-为什么这么设计-优点在哪"><span>✅ 7. 为什么这么设计？优点在哪？</span></a></h2><table><thead><tr><th>优点</th><th>说明</th></tr></thead><tbody><tr><td>🚀 优先使用 CAS 提高性能</td><td>在竞争小、桶为空时，完全无锁写入</td></tr><tr><td>🔒 synchronized 降低锁粒度</td><td>只锁桶位，不锁整张表，提高并发度</td></tr><tr><td>💥 避免全表锁</td><td>相比 Hashtable，性能提升明显</td></tr><tr><td>🧠 分散热点桶冲突</td><td>锁的粒度是节点级别，不影响其他桶写入</td></tr></tbody></table><hr><h2 id="✅-8-面试简答模板-建议背诵" tabindex="-1"><a class="header-anchor" href="#✅-8-面试简答模板-建议背诵"><span>✅ 8. 面试简答模板（建议背诵）</span></a></h2><blockquote><p>JDK 1.8 中的 <code>ConcurrentHashMap</code> 在执行 <code>put()</code> 操作时，首先通过 <code>CAS</code> 尝试将数据插入对应桶位（当该桶为空），如果 CAS 成功，则无锁写入；如果失败或桶已非空，则使用 <code>synchronized</code> 对该桶的首节点加锁来完成插入。这种设计结合了 CAS 的高效性和 synchronized 的可靠性，实现了粒度更细、性能更高的线程安全 Map</p></blockquote>',27)]))}]]),e=JSON.parse('{"path":"/Interview/%E9%9D%A2%E8%AF%95%E7%AD%94%E9%A2%98%E5%8D%A1/Java/ConcurrentHashMap%20%E7%9A%84%20put%20%E6%93%8D%E4%BD%9C%E4%B8%AD%20CAS%20%E5%92%8C%20synchronized%20%E7%9A%84%E4%BD%BF%E7%94%A8.html","title":"☕ Java 面试答题卡：ConcurrentHashMap 的 put 操作中 CAS 和 synchronized 的使用","lang":"zh-CN","frontmatter":{"gitInclude":[]},"headers":[{"level":2,"title":"✅ 1. 总体结构回顾（JDK 1.8）","slug":"✅-1-总体结构回顾-jdk-1-8","link":"#✅-1-总体结构回顾-jdk-1-8","children":[]},{"level":2,"title":"✅ 2. put() 流程图简化版","slug":"✅-2-put-流程图简化版","link":"#✅-2-put-流程图简化版","children":[]},{"level":2,"title":"✅ 3. 核心源码片段分析","slug":"✅-3-核心源码片段分析","link":"#✅-3-核心源码片段分析","children":[]},{"level":2,"title":"✅ 4. 解释：CAS + synchronized 的协作机制","slug":"✅-4-解释-cas-synchronized-的协作机制","link":"#✅-4-解释-cas-synchronized-的协作机制","children":[]},{"level":2,"title":"✅ 5. CAS 是什么？为什么优先用它？","slug":"✅-5-cas-是什么-为什么优先用它","link":"#✅-5-cas-是什么-为什么优先用它","children":[]},{"level":2,"title":"✅ 6. synchronized 是如何用的？","slug":"✅-6-synchronized-是如何用的","link":"#✅-6-synchronized-是如何用的","children":[]},{"level":2,"title":"✅ 7. 为什么这么设计？优点在哪？","slug":"✅-7-为什么这么设计-优点在哪","link":"#✅-7-为什么这么设计-优点在哪","children":[]},{"level":2,"title":"✅ 8. 面试简答模板（建议背诵）","slug":"✅-8-面试简答模板-建议背诵","link":"#✅-8-面试简答模板-建议背诵","children":[]}],"readingTime":{"minutes":2.29,"words":686},"filePathRelative":"Interview/面试答题卡/Java/ConcurrentHashMap 的 put 操作中 CAS 和 synchronized 的使用.md","excerpt":"\\n<hr>\\n<h2>✅ 1. 总体结构回顾（JDK 1.8）</h2>\\n<blockquote>\\n<p>JDK 1.8 的 <code>ConcurrentHashMap</code> 不再使用分段锁（Segment），而是使用：</p>\\n</blockquote>\\n<ul>\\n<li><strong>数组 + 链表 + 红黑树结构</strong></li>\\n<li><strong>节点槽位粒度的同步控制</strong></li>\\n<li>高效使用 <code>CAS + synchronized</code> 控制并发写入</li>\\n</ul>\\n<hr>\\n<h2>✅ 2. put() 流程图简化版</h2>"}')}}]);