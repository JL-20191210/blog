"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[51275],{66262:(i,s)=>{s.A=(i,s)=>{const a=i.__vccOpts||i;for(const[i,e]of s)a[i]=e;return a}},33620:(i,s,a)=>{a.r(s),a.d(s,{comp:()=>l,data:()=>n});var e=a(20641);const t={},l=(0,a(66262).A)(t,[["render",function(i,s){return(0,e.uX)(),(0,e.CE)("div",null,s[0]||(s[0]=[(0,e.Fv)('<h1 id="_2-3-《直接内存-directmemory-的使用与风险》" tabindex="-1"><a class="header-anchor" href="#_2-3-《直接内存-directmemory-的使用与风险》"><span>2.3 《直接内存 DirectMemory 的使用与风险》</span></a></h1><h2 id="📦-什么是直接内存-direct-memory" tabindex="-1"><a class="header-anchor" href="#📦-什么是直接内存-direct-memory"><span>📦 什么是直接内存（Direct Memory）？</span></a></h2><p>直接内存是 JVM 外的一块内存区域，不受 Java 堆空间限制。它通过 <code>sun.misc.Unsafe</code> 或 <code>java.nio.ByteBuffer.allocateDirect()</code> 分配，在 Java 程序中可用于高性能 IO 操作。</p><p>直接内存的最大优势是<strong>绕过 Java 堆内存与 GC 管理，提高数据传输效率</strong>，尤其适用于 Netty、Kafka、Zero-Copy 场景。</p><h2 id="📍-直接内存与堆内存对比" tabindex="-1"><a class="header-anchor" href="#📍-直接内存与堆内存对比"><span>📍 直接内存与堆内存对比</span></a></h2><table><thead><tr><th>对比项</th><th>直接内存（DirectMemory）</th><th>堆内存（Heap）</th></tr></thead><tbody><tr><td>分配方式</td><td><code>allocateDirect()</code>、<code>Unsafe</code></td><td><code>new</code> 操作符分配</td></tr><tr><td>内存位置</td><td>JVM 堆外，使用本地内存</td><td>JVM 堆中，由 GC 管理</td></tr><tr><td>是否 GC 管理</td><td>❌ 不受 GC 控制</td><td>✅ 被 GC 管理</td></tr><tr><td>访问速度</td><td>较快（减少复制）</td><td>较慢</td></tr><tr><td>用途</td><td>高性能 IO、Netty、NIO buffer</td><td>普通对象、字符串、数组等</td></tr></tbody></table><h2 id="🔧-使用方式示例" tabindex="-1"><a class="header-anchor" href="#🔧-使用方式示例"><span>🔧 使用方式示例</span></a></h2><h3 id="_1-使用-nio-bytebuffer-分配" tabindex="-1"><a class="header-anchor" href="#_1-使用-nio-bytebuffer-分配"><span>1. 使用 NIO ByteBuffer 分配</span></a></h3><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">ByteBuffer</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> buffer </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> ByteBuffer</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">allocateDirect</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1024</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 分配 1KB 直接内存</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="_2-使用-unsafe-低层-api-不推荐" tabindex="-1"><a class="header-anchor" href="#_2-使用-unsafe-低层-api-不推荐"><span>2. 使用 Unsafe 低层 API（不推荐）</span></a></h3><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Field</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> field </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> Unsafe</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">class</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getDeclaredField</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;theUnsafe&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">field</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">setAccessible</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">true</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>\n<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Unsafe</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> unsafe </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (Unsafe) </span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">field</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">get</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">null</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">long</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> address </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> unsafe</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">allocateMemory</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1024L</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 分配内存</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">unsafe</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">putByte</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(address, (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">byte</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">            // 写入数据</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">unsafe</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">freeMemory</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(address);</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                   // 手动释放</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>⚠️ 警告：<code>Unsafe</code> 是非标准 API，使用不当会导致内存泄漏甚至 JVM 崩溃。</p></blockquote><h2 id="🚨-直接内存的风险" tabindex="-1"><a class="header-anchor" href="#🚨-直接内存的风险"><span>🚨 直接内存的风险</span></a></h2><ol><li><strong>内存泄漏风险</strong>：必须手动释放，否则长期运行会导致系统内存耗尽。</li><li><strong>难以监控</strong>：不会显示在 JVM 堆相关工具（如 jstat、MAT）中，需要特殊工具如 NMT 监控。</li><li><strong>最大内存限制不透明</strong>：由 <code>-XX:MaxDirectMemorySize</code> 控制，默认与最大堆大小一致（如未设置）。</li></ol><h2 id="📊-如何监控与配置" tabindex="-1"><a class="header-anchor" href="#📊-如何监控与配置"><span>📊 如何监控与配置</span></a></h2><h3 id="_1-配置直接内存上限" tabindex="-1"><a class="header-anchor" href="#_1-配置直接内存上限"><span>1. 配置直接内存上限</span></a></h3><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">-</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">XX</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">MaxDirectMemorySize</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">256m</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="_2-诊断工具" tabindex="-1"><a class="header-anchor" href="#_2-诊断工具"><span>2. 诊断工具</span></a></h3><ul><li><code>jcmd &lt;pid&gt; VM.native_memory summary</code></li><li><code>jmap -heap &lt;pid&gt;</code><strong>查看运行中 Java 进程的堆内存使用情况</strong> 无法显示直接内存</li><li><code>Native Memory Tracking (NMT)</code> 可用于分析直接内存占用</li></ul><h2 id="📌-面试与实战问答" tabindex="-1"><a class="header-anchor" href="#📌-面试与实战问答"><span>📌 面试与实战问答</span></a></h2><ol><li>什么是直接内存？和堆内存有什么区别？</li><li>使用 <code>ByteBuffer.allocateDirect()</code> 有哪些风险？</li><li>直接内存是否会被 GC？如何回收？</li><li>如何限制直接内存占用并进行监控？</li></ol><h2 id="📝-小结" tabindex="-1"><a class="header-anchor" href="#📝-小结"><span>📝 小结</span></a></h2><ul><li>直接内存是高性能 IO 的利器，但使用不当会引发严重问题</li><li>建议通过 <code>allocateDirect()</code> 使用，并设置 <code>MaxDirectMemorySize</code></li><li>需要结合 NMT 工具、jcmd 等手段监控泄漏与异常</li></ul><p>👉 下一篇推荐阅读：3.1 Java 垃圾回收算法与分代机制（图解）</p>',24)]))}]]),n=JSON.parse('{"path":"/JVM/%E4%B8%93%E6%A0%8F%E5%90%88%E9%9B%86/2.%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E4%B8%8E%E5%B9%B6%E5%8F%91%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/2.3%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%20DirectMemory%20%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E9%A3%8E%E9%99%A9.html","title":"2.3 《直接内存 DirectMemory 的使用与风险》","lang":"zh-CN","frontmatter":{"gitInclude":[]},"headers":[{"level":2,"title":"📦 什么是直接内存（Direct Memory）？","slug":"📦-什么是直接内存-direct-memory","link":"#📦-什么是直接内存-direct-memory","children":[]},{"level":2,"title":"📍 直接内存与堆内存对比","slug":"📍-直接内存与堆内存对比","link":"#📍-直接内存与堆内存对比","children":[]},{"level":2,"title":"🔧 使用方式示例","slug":"🔧-使用方式示例","link":"#🔧-使用方式示例","children":[{"level":3,"title":"1. 使用 NIO ByteBuffer 分配","slug":"_1-使用-nio-bytebuffer-分配","link":"#_1-使用-nio-bytebuffer-分配","children":[]},{"level":3,"title":"2. 使用 Unsafe 低层 API（不推荐）","slug":"_2-使用-unsafe-低层-api-不推荐","link":"#_2-使用-unsafe-低层-api-不推荐","children":[]}]},{"level":2,"title":"🚨 直接内存的风险","slug":"🚨-直接内存的风险","link":"#🚨-直接内存的风险","children":[]},{"level":2,"title":"📊 如何监控与配置","slug":"📊-如何监控与配置","link":"#📊-如何监控与配置","children":[{"level":3,"title":"1. 配置直接内存上限","slug":"_1-配置直接内存上限","link":"#_1-配置直接内存上限","children":[]},{"level":3,"title":"2. 诊断工具","slug":"_2-诊断工具","link":"#_2-诊断工具","children":[]}]},{"level":2,"title":"📌 面试与实战问答","slug":"📌-面试与实战问答","link":"#📌-面试与实战问答","children":[]},{"level":2,"title":"📝 小结","slug":"📝-小结","link":"#📝-小结","children":[]}],"readingTime":{"minutes":2.02,"words":605},"filePathRelative":"JVM/专栏合集/2.内存结构与并发内存模型/2.3直接内存 DirectMemory 的使用与风险.md","excerpt":"\\n<h2>📦 什么是直接内存（Direct Memory）？</h2>\\n<p>直接内存是 JVM 外的一块内存区域，不受 Java 堆空间限制。它通过 <code>sun.misc.Unsafe</code> 或 <code>java.nio.ByteBuffer.allocateDirect()</code> 分配，在 Java 程序中可用于高性能 IO 操作。</p>\\n<p>直接内存的最大优势是<strong>绕过 Java 堆内存与 GC 管理，提高数据传输效率</strong>，尤其适用于 Netty、Kafka、Zero-Copy 场景。</p>\\n<h2>📍 直接内存与堆内存对比</h2>"}')}}]);