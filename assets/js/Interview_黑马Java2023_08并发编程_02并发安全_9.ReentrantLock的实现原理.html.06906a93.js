"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[30499],{66262:(e,i)=>{i.A=(e,i)=>{const n=e.__vccOpts||e;for(const[e,t]of i)n[e]=t;return n}},79009:(e,i,n)=>{n.r(i),n.d(i,{comp:()=>r,data:()=>l});var t=n(20641);const a={},r=(0,n(66262).A)(a,[["render",function(e,i){return(0,t.uX)(),(0,t.CE)("div",null,i[0]||(i[0]=[(0,t.Fv)('<h1 id="_9-reentrantlock的实现原理" tabindex="-1"><a class="header-anchor" href="#_9-reentrantlock的实现原理"><span>9. ReentrantLock的实现原理</span></a></h1><blockquote><p>难易程度：☆☆☆☆</p><p>出现频率：☆☆☆</p></blockquote><div class="hint-container important"><p class="hint-container-title">重要</p><ul><li>ReentrantLock是一个可重入锁:，调用 lock 方 法获取了锁之后，再次调用 lock，是不会再阻塞，内部直接增加重入次数就行了，标识这个线程已经重复获取一把锁而不需要等待锁的释放。</li><li>ReentrantLock是属于juc报下的类，属于api层面的锁，跟synchronized一样，都是悲观锁。通过lock()用来获取锁，unlock()释放锁。</li><li>它的底层实现原理主要利用<strong>CAS+AQS队列</strong>来实现。它支持公平锁和非公平锁，两者的实现类似</li><li>构造方法接受一个可选的公平参数（<strong>默认非公平锁</strong>），当设置为true时，表示公平锁，否则为非公平锁。公平锁的效率往往没有非公平锁的效率高。</li></ul></div><h2 id="_1-概述" tabindex="-1"><a class="header-anchor" href="#_1-概述"><span>1.<strong>概述</strong></span></a></h2><p>ReentrantLock翻译过来是可重入锁，相对于synchronized它具备以下特点：</p><ul><li><p>可中断</p></li><li><p>可以设置超时时间</p></li><li><p>可以设置公平锁</p></li><li><p>支持多个条件变量</p></li><li><p>与synchronized一样，都支持重入</p></li></ul><figure><img src="/Users/felix/VsCodeProjects/my-docs/src/Interview/黑马Java2023/08并发编程/02并发安全/assets/wps4.jpg" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h2 id="_2-实现原理" tabindex="-1"><a class="header-anchor" href="#_2-实现原理"><span>2.<strong>实现原理</strong></span></a></h2><p>ReentrantLock主要利用CAS+AQS队列来实现。它支持公平锁和非公平锁，两者的实现类似</p><p>构造方法接受一个可选的公平参数（默认非公平锁），当设置为true时，表示公平锁，否则为非公平锁。公平锁的效率往往没有非公平锁的效率高，在许多线程访问的情况下，公平锁表现出较低的吞吐量。</p><p>查看ReentrantLock源码中的构造方法：</p><figure><img src="/Users/felix/VsCodeProjects/my-docs/src/Interview/黑马Java2023/08并发编程/02并发安全/assets/wps5.jpg" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>提供了两个构造方法，不带参数的默认为非公平</p><p>如果使用带参数的构造函数，并且传的值为true，则是公平锁</p><p>其中NonfairSync和FairSync这两个类父类都是Sync</p><figure><img src="/Users/felix/VsCodeProjects/my-docs/src/Interview/黑马Java2023/08并发编程/02并发安全/assets/wps6.jpg" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>而Sync的父类是AQS，所以可以得出ReentrantLock底层主要实现就是基于AQS来实现的</p><figure><img src="/Users/felix/VsCodeProjects/my-docs/src/Interview/黑马Java2023/08并发编程/02并发安全/assets/wps7.jpg" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p><strong>工作流程</strong></p><figure><img src="/Users/felix/VsCodeProjects/my-docs/src/Interview/黑马Java2023/08并发编程/02并发安全/assets/wps8.jpg" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><ul><li><p>线程来抢锁后使用cas的方式修改state状态，修改状态成功为1，则让exclusiveOwnerThread属性指向当前线程，获取锁成功</p></li><li><p>假如修改状态失败，则会进入双向队列中等待，head指向双向队列头部，tail指向双向队列尾部</p></li><li><p>当exclusiveOwnerThread为null的时候，则会唤醒在双向队列中等待的线程</p></li><li><p>公平锁则体现在按照先后顺序获取锁，非公平体现在不在排队的线程也可以抢锁</p></li></ul>',21)]))}]]),l=JSON.parse('{"path":"/Interview/%E9%BB%91%E9%A9%ACJava2023/08%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/02%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8/9.ReentrantLock%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.html","title":"9. ReentrantLock的实现原理","lang":"zh-CN","frontmatter":{"gitInclude":[]},"headers":[{"level":2,"title":"1.概述","slug":"_1-概述","link":"#_1-概述","children":[]},{"level":2,"title":"2.实现原理","slug":"_2-实现原理","link":"#_2-实现原理","children":[]}],"readingTime":{"minutes":2.35,"words":705},"filePathRelative":"Interview/黑马Java2023/08并发编程/02并发安全/9.ReentrantLock的实现原理.md","excerpt":"\\n<blockquote>\\n<p>难易程度：☆☆☆☆</p>\\n<p>出现频率：☆☆☆</p>\\n</blockquote>\\n<div class=\\"hint-container important\\">\\n<p class=\\"hint-container-title\\">重要</p>\\n<ul>\\n<li>ReentrantLock是一个可重入锁:，调用 lock 方 法获取了锁之后，再次调用 lock，是不会再阻塞，内部直接增加重入次数就行了，标识这个线程已经重复获取一把锁而不需要等待锁的释放。</li>\\n<li>ReentrantLock是属于juc报下的类，属于api层面的锁，跟synchronized一样，都是悲观锁。通过lock()用来获取锁，unlock()释放锁。</li>\\n<li>它的底层实现原理主要利用<strong>CAS+AQS队列</strong>来实现。它支持公平锁和非公平锁，两者的实现类似</li>\\n<li>构造方法接受一个可选的公平参数（<strong>默认非公平锁</strong>），当设置为true时，表示公平锁，否则为非公平锁。公平锁的效率往往没有非公平锁的效率高。</li>\\n</ul>\\n</div>"}')}}]);