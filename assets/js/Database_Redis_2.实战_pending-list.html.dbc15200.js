"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[38523],{66262:(n,e)=>{e.A=(n,e)=>{const t=n.__vccOpts||n;for(const[n,s]of e)t[n]=s;return t}},85514:(n,e,t)=>{t.r(e),t.d(e,{comp:()=>i,data:()=>r});var s=t(20641);const o={},i=(0,t(66262).A)(o,[["render",function(n,e){return(0,s.uX)(),(0,s.CE)("div",null,e[0]||(e[0]=[(0,s.Fv)('<h1 id="pending-list" tabindex="-1"><a class="header-anchor" href="#pending-list"><span>Pending List</span></a></h1><p>🍃<strong>Pending List</strong>存的就是已经分配给消费者了，但是消费者还没有处理完，没有确认的消息</p><p><code>命令 1: XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS stream.orders &gt;</code></p><p><code>&gt;</code>: 这个符号表示消费者 <code>c1</code> 只会读取那些 <strong>尚未被其他消费者组消费的消息</strong>【<strong>pending-list</strong>】。也就是说，<code>&gt;</code> 确保了它只会消费那些 &quot;未被任何消费者确认&quot; 或 &quot;尚未被处理&quot; 的消息。</p><p><code>命令 2: XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS stream.orders 0</code></p><p><code>0</code>: 这个数字表示将从<strong>流</strong>的 <strong>最早未消费消息</strong> 开始读取。它并不依赖于消费者是否已经处理或确认这些消息。</p><p><strong>Pending List（待处理列表）</strong> 是 Redis Streams 中用于存储消费者组尚未确认的消息的数据结构。它的主要作用是跟踪每个消费者组中每个消费者的消息处理状态，特别是未被确认的消息。</p><h3 id="关键特点" tabindex="-1"><a class="header-anchor" href="#关键特点"><span>关键特点：</span></a></h3><ol><li><p><strong>消息来源</strong>：当消费者组使用 <code>XREADGROUP</code> 命令读取消息时，消息会被分配给消费者。如果消费者没有使用 <code>XACK</code> 命令确认消息，这些消息就会进入 <strong>pending list</strong>。</p></li><li><p><strong>存储内容</strong>：<strong>Pending list</strong> 存储了所有 <strong>未被确认</strong> 的消息，包括：</p><ul><li>消费者已经读取但尚未确认的消息。</li><li>这些消息处于待处理状态，直到消费者确认（通过 <code>XACK</code> 命令）。</li></ul></li><li><p><strong>命令操作</strong>：</p><ul><li><code>XPENDING</code> 命令：用于查看 <strong>pending list</strong> 中的消息，显示哪些消息被哪些消费者读取，但尚未确认。</li><li><code>XACK</code> 命令：用于确认消息，确认后这些消息会从 <strong>pending list</strong> 中移除。</li></ul></li><li><p><strong>自动清理</strong>：如果消息在一段时间内没有被确认，可能会被认为是“处理失败”，但 Redis 本身并没有自动清除它们的机制，通常由消费者在处理逻辑中管理。</p></li></ol><h3 id="使用场景" tabindex="-1"><a class="header-anchor" href="#使用场景"><span>使用场景：</span></a></h3><ul><li><strong>消息重试</strong>：可以通过 <code>XPENDING</code> 查看哪些消息尚未确认，方便进行消息重试或进一步处理。</li><li><strong>消费者失败管理</strong>：如果某个消费者无法处理消息，其他消费者可以重新获取并处理这些未确认的消息。</li></ul><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结：</span></a></h3><p><strong>Pending list</strong> 是一个用于存储消费者组内未确认消息的临时存储区，帮助 Redis 管理消息的消费状态，确保每条消息至少被处理一次</p>',13)]))}]]),r=JSON.parse('{"path":"/Database/Redis/2.%E5%AE%9E%E6%88%98/pending-list.html","title":"Pending List","lang":"zh-CN","frontmatter":{"gitInclude":[]},"headers":[{"level":3,"title":"关键特点：","slug":"关键特点","link":"#关键特点","children":[]},{"level":3,"title":"使用场景：","slug":"使用场景","link":"#使用场景","children":[]},{"level":3,"title":"总结：","slug":"总结","link":"#总结","children":[]}],"readingTime":{"minutes":2.04,"words":611},"filePathRelative":"Database/Redis/2.实战/pending-list.md","excerpt":"\\n<p>🍃<strong>Pending List</strong>存的就是已经分配给消费者了，但是消费者还没有处理完，没有确认的消息</p>\\n<p><code>命令 1: XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS stream.orders &gt;</code></p>\\n<p><code>&gt;</code>: 这个符号表示消费者 <code>c1</code> 只会读取那些 <strong>尚未被其他消费者组消费的消息</strong>【<strong>pending-list</strong>】。也就是说，<code>&gt;</code> 确保了它只会消费那些 \\"未被任何消费者确认\\" 或 \\"尚未被处理\\" 的消息。</p>"}')}}]);