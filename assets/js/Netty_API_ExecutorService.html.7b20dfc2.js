"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[32650],{66262:(e,l)=>{l.A=(e,l)=>{const o=e.__vccOpts||e;for(const[e,c]of l)o[e]=c;return o}},95628:(e,l,o)=>{o.r(l),o.d(l,{comp:()=>i,data:()=>d});var c=o(20641);const t={},i=(0,o(66262).A)(t,[["render",function(e,l){return(0,c.uX)(),(0,c.CE)("div",null,[l[0]||(l[0]=(0,c.Lk)("h1",{id:"executorservice",tabindex:"-1"},[(0,c.Lk)("a",{class:"header-anchor",href:"#executorservice"},[(0,c.Lk)("span",null,"ExecutorService")])],-1)),l[1]||(l[1]=(0,c.Lk)("p",null,[(0,c.Lk)("code",null,"ExecutorService"),(0,c.eW)(" 是 Java 中的一个接口，它继承自 "),(0,c.Lk)("code",null,"Executor"),(0,c.eW)(" 接口，用于提供更为高级的任务执行功能。它定义了线程池的基本操作，能够提交和管理任务，并且提供了一些额外的方法来控制和管理线程池的生命周期。下面是对 "),(0,c.Lk)("code",null,"ExecutorService"),(0,c.eW)(" 的总结和接口文档的概述：")],-1)),(0,c.Q3)(" more "),l[2]||(l[2]=(0,c.Fv)('<h3 id="主要方法" tabindex="-1"><a class="header-anchor" href="#主要方法"><span>主要方法</span></a></h3><ol><li><p><strong><code>submit(Callable&lt;T&gt; task)</code></strong>:</p><ul><li>提交一个 <code>Callable</code> 任务，并返回一个 <code>Future&lt;T&gt;</code> 对象，表示该任务的异步执行结果。</li><li>任务会在后台线程池中执行，调用 <code>Future.get()</code> 可以获取任务的结果。</li></ul></li><li><p><strong><code>submit(Runnable task)</code></strong>:</p><ul><li>提交一个 <code>Runnable</code> 任务，并返回一个 <code>Future&lt;?&gt;</code> 对象，表示该任务的异步执行状态。</li><li>任务会在后台线程池中执行，调用 <code>Future.get()</code> 可以获取任务的完成状态。</li></ul></li><li><p><strong><code>invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</code></strong>:</p><ul><li>提交一组 <code>Callable</code> 任务，并返回一个包含每个任务执行结果的 <code>List&lt;Future&lt;T&gt;&gt;</code>。</li><li>所有任务会在后台线程池中执行，且任务按提交顺序等待执行。</li></ul></li><li><p><strong><code>invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</code></strong>:</p><ul><li>提交一组 <code>Callable</code> 任务并返回执行完成的第一个任务的结果。</li><li>如果至少有一个任务成功执行，则返回该任务的结果。如果所有任务都失败，则抛出异常。</li></ul></li><li><p><strong><code>shutdown()</code></strong>:</p><ul><li>优雅地关闭线程池，停止接受新任务，并且在所有已提交的任务完成后关闭线程池。</li><li>该方法不会立即终止已提交任务的执行，已提交任务会在执行完成后关闭。</li></ul></li><li><p><strong><code>shutdownNow()</code></strong>:</p><ul><li>尝试停止所有正在执行的任务，并返回尚未执行的任务列表。</li><li>不保证会中断正在执行的任务，通常是通过中断线程来尽可能地停止任务。</li></ul></li><li><p><strong><code>sShutdown()</code></strong>:</p><ul><li>返回一个布尔值，表示线程池是否已经关闭（通过调用 <code>shutdown()</code> 或 <code>shutdownNow()</code>）。</li></ul></li><li><p><strong><code>isTerminated()</code></strong>:</p><ul><li>返回一个布尔值，表示线程池中的所有任务是否都已经完成。</li></ul></li><li><p><strong><code>awaitTermination(long timeout, TimeUnit unit)</code></strong>:</p><ul><li>在指定的时间内等待所有任务完成。</li><li>如果所有任务在超时之前完成，则返回 <code>true</code>，否则返回 <code>false</code>。</li></ul></li></ol><h3 id="继承自-executor-接口的方法" tabindex="-1"><a class="header-anchor" href="#继承自-executor-接口的方法"><span>继承自 <code>Executor</code> 接口的方法</span></a></h3><ul><li><strong><code>execute(Runnable command)</code></strong>: <ul><li>提交一个 <code>Runnable</code> 任务进行执行。与 <code>ExecutorService</code> 中的 <code>submit</code> 方法不同，它不会返回 <code>Future</code> 对象，且不能获取任务的执行结果。</li></ul></li></ul><h3 id="线程池的特点" tabindex="-1"><a class="header-anchor" href="#线程池的特点"><span>线程池的特点</span></a></h3><ul><li><strong>线程池大小管理</strong>：<code>ExecutorService</code> 实现通常会使用一个线程池来处理提交的任务，能够有效地管理线程资源。</li><li><strong>任务管理</strong>：支持任务的排队、执行和结果返回。<code>ExecutorService</code> 的实现可以灵活地处理异步任务和结果的同步。</li><li><strong>生命周期管理</strong>：提供了线程池的生命周期管理方法，如 <code>shutdown</code> 和 <code>shutdownNow</code>，可以方便地控制线程池的关闭和任务的执行状态。</li></ul><h3 id="常用实现类" tabindex="-1"><a class="header-anchor" href="#常用实现类"><span>常用实现类</span></a></h3><ul><li><strong><code>ThreadPoolExecutor</code></strong>：最常用的线程池实现类，允许详细配置线程池的参数（如核心线程数、最大线程数、空闲线程存活时间等）。</li><li><strong><code>ScheduledThreadPoolExecutor</code></strong>：支持任务定时执行的线程池实现，能够执行周期性或延迟的任务。</li></ul><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h3><p><code>ExecutorService</code> 提供了一个完整的任务执行框架，能够有效地管理线程池和任务的生命周期。通过 <code>submit</code>、<code>invokeAll</code>、<code>invokeAny</code> 等方法，可以灵活地提交任务并获得执行结果，适合用于需要异步执行并管理多个任务的场景。</p>',10))])}]]),d=JSON.parse('{"path":"/Netty/API/ExecutorService.html","title":"ExecutorService","lang":"zh-CN","frontmatter":{"icon":"pen-to-square","date":"2025-02-12T00:00:00.000Z","category":["Netty"],"tag":["API"],"gitInclude":[]},"headers":[{"level":3,"title":"主要方法","slug":"主要方法","link":"#主要方法","children":[]},{"level":3,"title":"继承自 Executor 接口的方法","slug":"继承自-executor-接口的方法","link":"#继承自-executor-接口的方法","children":[]},{"level":3,"title":"线程池的特点","slug":"线程池的特点","link":"#线程池的特点","children":[]},{"level":3,"title":"常用实现类","slug":"常用实现类","link":"#常用实现类","children":[]},{"level":3,"title":"总结","slug":"总结","link":"#总结","children":[]}],"readingTime":{"minutes":3.03,"words":910},"filePathRelative":"Netty/API/ExecutorService.md","localizedDate":"2025年2月12日","excerpt":"\\n<p><code>ExecutorService</code> 是 Java 中的一个接口，它继承自 <code>Executor</code> 接口，用于提供更为高级的任务执行功能。它定义了线程池的基本操作，能够提交和管理任务，并且提供了一些额外的方法来控制和管理线程池的生命周期。下面是对 <code>ExecutorService</code> 的总结和接口文档的概述：</p>\\n"}')}}]);