"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[26349],{66262:(n,s)=>{s.A=(n,s)=>{const a=n.__vccOpts||n;for(const[n,e]of s)a[n]=e;return a}},28349:(n,s,a)=>{a.r(s),a.d(s,{comp:()=>t,data:()=>l});var e=a(20641);const i={},t=(0,a(66262).A)(i,[["render",function(n,s){return(0,e.uX)(),(0,e.CE)("div",null,s[0]||(s[0]=[(0,e.Fv)('<h1 id="☕-java-面试答题卡-priorityqueue详解" tabindex="-1"><a class="header-anchor" href="#☕-java-面试答题卡-priorityqueue详解"><span>☕ Java 面试答题卡： PriorityQueue详解</span></a></h1><h2 id="✅-1-简介-什么是-priorityqueue" tabindex="-1"><a class="header-anchor" href="#✅-1-简介-什么是-priorityqueue"><span><strong>✅ 1. 简介：什么是 PriorityQueue？</strong></span></a></h2><blockquote><p>PriorityQueue 是 Java 中基于<strong>优先级堆（最小堆或最大堆）实现的队列结构</strong>，属于 java.util 包，实现了 Queue 接口。</p></blockquote><p>它保证每次出队（poll()）返回<strong>优先级最高（或最低）的元素，而不是按元素入队顺序</strong>返回。</p><h2 id="✅-2-特性总结" tabindex="-1"><a class="header-anchor" href="#✅-2-特性总结"><span><strong>✅ 2. 特性总结</strong></span></a></h2><table><thead><tr><th><strong>特性</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>内部结构</td><td>默认使用 <strong>最小堆</strong>（小顶堆），基于数组实现</td></tr><tr><td>元素顺序</td><td>入队无序，出队有序（优先级高的先出）</td></tr><tr><td>默认排序方式</td><td>元素需实现 Comparable 接口</td></tr><tr><td>自定义排序</td><td>可通过构造方法传入 Comparator</td></tr><tr><td>允许重复元素</td><td>✅ 允许</td></tr><tr><td>线程安全性</td><td>❌ 非线程安全（需手动加锁或使用 PriorityBlockingQueue）</td></tr></tbody></table><h2 id="✅-3-构造方法" tabindex="-1"><a class="header-anchor" href="#✅-3-构造方法"><span><strong>✅ 3. 构造方法</strong></span></a></h2><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>PriorityQueue()                            // 默认容量 11，元素需实现 Comparable</span></span>\n<span class="line"><span>PriorityQueue(int initialCapacity)         // 指定初始容量</span></span>\n<span class="line"><span>PriorityQueue(Comparator&lt;? super E&gt; comp)  // 自定义比较器</span></span>\n<span class="line"><span>PriorityQueue(Collection&lt;? extends E&gt; c)   // 从已有集合创建</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="✅-4-使用示例-默认最小堆" tabindex="-1"><a class="header-anchor" href="#✅-4-使用示例-默认最小堆"><span><strong>✅ 4. 使用示例（默认最小堆）</strong></span></a></h2><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;();</span></span>\n<span class="line"><span>pq.offer(3);</span></span>\n<span class="line"><span>pq.offer(1);</span></span>\n<span class="line"><span>pq.offer(5);</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>while (!pq.isEmpty()) {</span></span>\n<span class="line"><span>    System.out.println(pq.poll());  // 输出：1 3 5</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="✅-5-自定义最大堆" tabindex="-1"><a class="header-anchor" href="#✅-5-自定义最大堆"><span><strong>✅ 5. 自定义最大堆</strong></span></a></h2><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>PriorityQueue&lt;Integer&gt; maxHeap = new PriorityQueue&lt;&gt;((a, b) -&gt; b - a);</span></span>\n<span class="line"><span>maxHeap.addAll(Arrays.asList(2, 9, 1, 6));</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>System.out.println(maxHeap.poll()); // 输出 9（最大堆）</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="✅-6-自定义对象排序" tabindex="-1"><a class="header-anchor" href="#✅-6-自定义对象排序"><span><strong>✅ 6. 自定义对象排序</strong></span></a></h2><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>class Task {</span></span>\n<span class="line"><span>    String name;</span></span>\n<span class="line"><span>    int priority;</span></span>\n<span class="line"><span>    public Task(String name, int priority) {</span></span>\n<span class="line"><span>        this.name = name;</span></span>\n<span class="line"><span>        this.priority = priority;</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>}</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>// 优先级从小到大</span></span>\n<span class="line"><span>PriorityQueue&lt;Task&gt; tasks = new PriorityQueue&lt;&gt;(Comparator.comparingInt(t -&gt; t.priority));</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>tasks.add(new Task(&quot;A&quot;, 5));</span></span>\n<span class="line"><span>tasks.add(new Task(&quot;B&quot;, 1));</span></span>\n<span class="line"><span>tasks.add(new Task(&quot;C&quot;, 3));</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>System.out.println(tasks.poll().name); // 输出 B</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="✅-7-底层原理-简要" tabindex="-1"><a class="header-anchor" href="#✅-7-底层原理-简要"><span><strong>✅ 7. 底层原理（简要）</strong></span></a></h2><ul><li><p>底层是一个 <strong>最小堆（heap）</strong> 实现，使用 <strong>数组</strong> 保存元素。</p></li><li><p>核心操作：</p><ul><li>offer(): 插入元素 → siftUp（上浮）保持堆序</li><li>poll(): 弹出堆顶元素 → 将末尾元素置顶，再 siftDown（下沉）</li></ul></li><li><p>堆排序规则依赖 Comparable 或 Comparator</p></li></ul><h2 id="✅-8-时间复杂度分析" tabindex="-1"><a class="header-anchor" href="#✅-8-时间复杂度分析"><span><strong>✅ 8. 时间复杂度分析</strong></span></a></h2><table><thead><tr><th><strong>操作</strong></th><th><strong>时间复杂度</strong></th></tr></thead><tbody><tr><td>offer()</td><td>O(log n)</td></tr><tr><td>poll()</td><td>O(log n)</td></tr><tr><td>peek()</td><td>O(1)</td></tr><tr><td>遍历所有元素</td><td>无序（O(n)）</td></tr></tbody></table><h2 id="✅-9-注意事项" tabindex="-1"><a class="header-anchor" href="#✅-9-注意事项"><span><strong>✅ 9. 注意事项</strong></span></a></h2><ul><li>PriorityQueue <strong>不保证插入顺序</strong>，迭代器输出是无序的。</li><li>不支持 null 元素，否则抛 NullPointerException。</li><li>不适合用于并发场景（请用 PriorityBlockingQueue）。</li><li>执行排序需满足<strong>一致性比较规则</strong>（否则抛 ClassCastException 或排序错乱）。</li></ul><h2 id="🎯-面试简答模板-建议背诵" tabindex="-1"><a class="header-anchor" href="#🎯-面试简答模板-建议背诵"><span><strong>🎯 面试简答模板（建议背诵）</strong></span></a></h2><blockquote><p>PriorityQueue 是 Java 中的优先级队列，底层使用最小堆实现，保证每次出队的都是优先级最高或最低的元素。它不保证插入顺序，但能快速获取最小/最大值。支持自定义比较器，也可用 Comparable 约定排序规则。该结构适合用于任务调度、路径算法等需要动态最值的数据结构场景。</p></blockquote>',22)]))}]]),l=JSON.parse('{"path":"/Interview/%E9%9D%A2%E8%AF%95%E7%AD%94%E9%A2%98%E5%8D%A1/Java/PriorityQueue.html","title":"☕ Java 面试答题卡： PriorityQueue详解","lang":"zh-CN","frontmatter":{"gitInclude":[]},"headers":[{"level":2,"title":"✅ 1. 简介：什么是 PriorityQueue？","slug":"✅-1-简介-什么是-priorityqueue","link":"#✅-1-简介-什么是-priorityqueue","children":[]},{"level":2,"title":"✅ 2. 特性总结","slug":"✅-2-特性总结","link":"#✅-2-特性总结","children":[]},{"level":2,"title":"✅ 3. 构造方法","slug":"✅-3-构造方法","link":"#✅-3-构造方法","children":[]},{"level":2,"title":"✅ 4. 使用示例（默认最小堆）","slug":"✅-4-使用示例-默认最小堆","link":"#✅-4-使用示例-默认最小堆","children":[]},{"level":2,"title":"✅ 5. 自定义最大堆","slug":"✅-5-自定义最大堆","link":"#✅-5-自定义最大堆","children":[]},{"level":2,"title":"✅ 6. 自定义对象排序","slug":"✅-6-自定义对象排序","link":"#✅-6-自定义对象排序","children":[]},{"level":2,"title":"✅ 7. 底层原理（简要）","slug":"✅-7-底层原理-简要","link":"#✅-7-底层原理-简要","children":[]},{"level":2,"title":"✅ 8. 时间复杂度分析","slug":"✅-8-时间复杂度分析","link":"#✅-8-时间复杂度分析","children":[]},{"level":2,"title":"✅ 9. 注意事项","slug":"✅-9-注意事项","link":"#✅-9-注意事项","children":[]},{"level":2,"title":"🎯 面试简答模板（建议背诵）","slug":"🎯-面试简答模板-建议背诵","link":"#🎯-面试简答模板-建议背诵","children":[]}],"readingTime":{"minutes":2.18,"words":653},"filePathRelative":"Interview/面试答题卡/Java/PriorityQueue.md","excerpt":"\\n<h2><strong>✅ 1. 简介：什么是 PriorityQueue？</strong></h2>\\n<blockquote>\\n<p>PriorityQueue 是 Java 中基于<strong>优先级堆（最小堆或最大堆）实现的队列结构</strong>，属于 java.util 包，实现了 Queue 接口。</p>\\n</blockquote>\\n<p>它保证每次出队（poll()）返回<strong>优先级最高（或最低）的元素，而不是按元素入队顺序</strong>返回。</p>\\n<h2><strong>✅ 2. 特性总结</strong></h2>\\n<table>\\n<thead>\\n<tr>\\n<th><strong>特性</strong></th>\\n<th><strong>描述</strong></th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>内部结构</td>\\n<td>默认使用 <strong>最小堆</strong>（小顶堆），基于数组实现</td>\\n</tr>\\n<tr>\\n<td>元素顺序</td>\\n<td>入队无序，出队有序（优先级高的先出）</td>\\n</tr>\\n<tr>\\n<td>默认排序方式</td>\\n<td>元素需实现 Comparable 接口</td>\\n</tr>\\n<tr>\\n<td>自定义排序</td>\\n<td>可通过构造方法传入 Comparator</td>\\n</tr>\\n<tr>\\n<td>允许重复元素</td>\\n<td>✅ 允许</td>\\n</tr>\\n<tr>\\n<td>线程安全性</td>\\n<td>❌ 非线程安全（需手动加锁或使用 PriorityBlockingQueue）</td>\\n</tr>\\n</tbody>\\n</table>"}')}}]);