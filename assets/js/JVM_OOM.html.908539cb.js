"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[6391],{6262:(e,l)=>{l.A=(e,l)=>{const a=e.__vccOpts||e;for(const[e,i]of l)a[e]=i;return a}},1215:(e,l,a)=>{a.r(l),a.d(l,{comp:()=>c,data:()=>t});var i=a(641);const o={},c=(0,a(6262).A)(o,[["render",function(e,l){return(0,i.uX)(),(0,i.CE)("div",null,[l[0]||(l[0]=(0,i.Lk)("h1",{id:"内存溢出",tabindex:"-1"},[(0,i.Lk)("a",{class:"header-anchor",href:"#内存溢出"},[(0,i.Lk)("span",null,"内存溢出")])],-1)),l[1]||(l[1]=(0,i.Lk)("blockquote",null,[(0,i.Lk)("p",null,"OOM 是 Out of Memory（内存溢出）的缩写，表示程序在运行过程中请求内存时超出了可用内存的限制，从而导致程序崩溃或无法继续执行。OOM 是一种常见的错误，尤其在涉及大规模数据处理或长时间运行的应用中较为频繁。")],-1)),(0,i.Q3)(" more "),l[2]||(l[2]=(0,i.Fv)('<h2 id="oom类型及解决方案" tabindex="-1"><a class="header-anchor" href="#oom类型及解决方案"><span>OOM类型及解决方案</span></a></h2><p>在 Java 中，Out of Memory Error 是由 JVM 在尝试分配内存时触发的一种错误，通常有以下几种类型：</p><h3 id="_1-java-heap-space-堆内存溢出" tabindex="-1"><a class="header-anchor" href="#_1-java-heap-space-堆内存溢出"><span>1. Java Heap Space (堆内存溢出)</span></a></h3><blockquote><p>发生在 JVM 堆内存中，当堆空间不足以分配新的对象时，JVM 会抛出 <code>java.lang.OutOfMemoryError: Java heap space</code> 错误。</p></blockquote><p><strong>常见原因</strong>：</p><ul><li>程序中创建了大量对象，超过了堆内存的配置。</li><li>对象生命周期过长，导致垃圾回收无法释放内存。</li><li>存在内存泄漏（即无法回收的对象）。</li></ul><p><strong>解决方案</strong>：</p><ul><li>增加堆内存：可以通过 JVM 参数 <code>-Xmx</code>（最大堆内存）和 <code>-Xms</code>（初始堆内存）来调整。</li><li>优化内存使用，减少不必要的对象创建。</li><li>使用内存分析工具（如 <code>VisualVM</code>、<code>YourKit</code>）分析内存泄漏。</li></ul><h3 id="_2-permgen-space-永久代内存溢出-jdk-7-及以前" tabindex="-1"><a class="header-anchor" href="#_2-permgen-space-永久代内存溢出-jdk-7-及以前"><span>2. PermGen Space (永久代内存溢出) [JDK 7 及以前]</span></a></h3><ul><li>在 JDK 7 及之前，Java 使用永久代（PermGen）来存储类的元数据（如类定义、常量池等）。如果永久代内存不足，会触发 <code>java.lang.OutOfMemoryError: PermGen space</code> 错误。</li></ul><p><strong>常见原因</strong>：</p><ul><li>应用程序加载了大量类（例如，使用了大量反射、动态代理等）。</li><li>热部署或类加载器泄漏，导致类无法回收。</li></ul><p><strong>解决方案</strong>：</p><ul><li>增加 PermGen 空间：使用 JVM 参数 <code>-XX:PermSize</code>（初始大小）和 <code>-XX:MaxPermSize</code>（最大大小）调整。</li><li>从 JDK 8 开始，PermGen 被移除，取而代之的是 Metaspace。</li></ul><h3 id="_3-metaspace-元空间内存溢出-jdk-8-及以后" tabindex="-1"><a class="header-anchor" href="#_3-metaspace-元空间内存溢出-jdk-8-及以后"><span>3. Metaspace (元空间内存溢出) [JDK 8 及以后]</span></a></h3><ul><li>在 JDK 8 及以后的版本中，PermGen 被 Metaspace 替代，Metaspace 存储类的元数据。如果 Metaspace 内存不足，会触发 <code>java.lang.OutOfMemoryError: Metaspace</code> 错误。</li></ul><p><strong>常见原因</strong>：</p><ul><li>动态类加载过多，或类加载器泄漏，导致 Metaspace 内存占用过大。</li><li>类定义数量过多或类的元数据过于庞大。</li></ul><p><strong>解决方案</strong>：</p><ul><li>增加 Metaspace 内存：使用 JVM 参数 <code>-XX:MetaspaceSize</code> 和 <code>-XX:MaxMetaspaceSize</code> 调整 Metaspace 的大小。</li><li>优化类加载，避免不必要的动态类加载或类泄漏。</li></ul><h3 id="_4-stack-space-栈内存溢出" tabindex="-1"><a class="header-anchor" href="#_4-stack-space-栈内存溢出"><span>4. Stack Space (栈内存溢出)</span></a></h3><ul><li>发生在每个线程的栈内存中，当线程的栈空间不足以分配新的方法调用时，会触发 <code>java.lang.StackOverflowError</code>（栈溢出）错误。</li></ul><p><strong>常见原因</strong>：</p><ul><li>递归调用没有终止条件，导致无限递归。</li><li>创建过多线程，每个线程的栈空间有限。</li></ul><p><strong>解决方案</strong>：</p><ul><li>增加线程栈空间：使用 <code>-Xss</code> 参数调整线程栈大小。</li><li>优化递归方法，避免无限递归。</li></ul><h3 id="_5-direct-memory-直接内存溢出" tabindex="-1"><a class="header-anchor" href="#_5-direct-memory-直接内存溢出"><span>5. Direct Memory (直接内存溢出)</span></a></h3><ul><li>直接内存是通过 <code>java.nio.Buffer</code> 类来分配的内存，而非 JVM 堆内存。使用 <code>-XX:MaxDirectMemorySize</code> 参数设置直接内存的最大值。如果直接内存不足，会触发 <code>java.lang.OutOfMemoryError: Direct buffer memory</code> 错误。</li></ul><p><strong>常见原因</strong>：</p><ul><li>使用了大量的 NIO（Non-blocking I/O）操作，分配了过多的直接内存。</li></ul><p><strong>解决方案</strong>：</p><ul><li>调整直接内存的大小：使用 <code>-XX:MaxDirectMemorySize</code> 参数。</li><li>优化 NIO 使用，避免过多直接内存的分配。</li></ul><h2 id="如何诊断和解决-oom-问题" tabindex="-1"><a class="header-anchor" href="#如何诊断和解决-oom-问题"><span>如何诊断和解决 OOM 问题</span></a></h2><ol><li><p><strong>分析堆内存使用情况</strong>：</p><ul><li>使用 <code>jmap</code> 或 <code>VisualVM</code> 等工具生成堆转储（heap dump），分析内存泄漏。</li><li>使用 MAT（Memory Analyzer Tool）来分析堆转储，查看哪些对象占用内存过多。</li></ul></li><li><p><strong>调整 JVM 内存配置</strong>：</p><ul><li>通过 <code>-Xmx</code> 设置最大堆内存，增加可用内存。</li><li>使用 <code>-XX:MetaspaceSize</code> 或 <code>-XX:MaxPermSize</code> 调整 Metaspace 或 PermGen 空间。</li><li>设置合适的 <code>-Xms</code>（初始堆内存大小）以减少内存频繁扩展的开销。</li></ul></li><li><p><strong>垃圾回收调优</strong>：</p><ul><li>使用合适的垃圾回收器（如 G1 GC、ZGC 等）来优化内存管理。</li><li>通过 <code>-XX:+PrintGCDetails</code> 和 <code>-XX:+PrintGCDateStamps</code> 输出 GC 相关信息，分析 GC 的执行情况。</li></ul></li><li><p><strong>减少对象创建和内存泄漏</strong>：</p><ul><li>避免频繁创建短生命周期对象，尽量使用对象池来复用对象。</li><li>检查代码中是否存在内存泄漏，尤其是长时间持有对大对象的引用。</li></ul></li><li><p><strong>使用分析工具</strong>：</p><ul><li><code>VisualVM</code>、<code>YourKit</code> 等工具可以帮助你监控堆内存的使用、查看类加载情况，以及进行垃圾回收日志分析。</li></ul></li><li><p><strong>限制线程栈大小</strong>：</p><ul><li>如果栈内存溢出，尝试调整线程栈大小，避免栈过深的递归调用。</li></ul></li></ol><h2 id="oom-错误的常见-jvm-参数" tabindex="-1"><a class="header-anchor" href="#oom-错误的常见-jvm-参数"><span>OOM 错误的常见 JVM 参数</span></a></h2><ul><li><code>-Xms&lt;size&gt;</code>：设置初始堆内存大小。</li><li><code>-Xmx&lt;size&gt;</code>：设置最大堆内存大小。</li><li><code>-Xss&lt;size&gt;</code>：设置每个线程的栈内存大小。</li><li><code>-XX:PermSize=&lt;size&gt;</code>：设置永久代的初始大小（JDK 7 及以前）。</li><li><code>-XX:MaxPermSize=&lt;size&gt;</code>：设置永久代的最大大小（JDK 7 及以前）。</li><li><code>-XX:MetaspaceSize=&lt;size&gt;</code>：设置 Metaspace 的初始大小（JDK 8 及以后）。</li><li><code>-XX:MaxMetaspaceSize=&lt;size&gt;</code>：设置 Metaspace 的最大大小（JDK 8 及以后）。</li><li><code>-XX:+PrintGCDetails</code>：打印 GC 的详细日志。</li><li><code>-XX:+PrintStringTableStatistics</code>：打印字符串常量池（StringTable）的统计信息。</li></ul>',36))])}]]),t=JSON.parse('{"path":"/JVM/OOM.html","title":"内存溢出","lang":"zh-CN","frontmatter":{"icon":"fa-solid fa-microchip","date":"2024-12-17T00:00:00.000Z","category":["JVM"],"tag":["总结"],"gitInclude":[]},"headers":[{"level":2,"title":"OOM类型及解决方案","slug":"oom类型及解决方案","link":"#oom类型及解决方案","children":[{"level":3,"title":"1. Java Heap Space (堆内存溢出)","slug":"_1-java-heap-space-堆内存溢出","link":"#_1-java-heap-space-堆内存溢出","children":[]},{"level":3,"title":"2. PermGen Space (永久代内存溢出) [JDK 7 及以前]","slug":"_2-permgen-space-永久代内存溢出-jdk-7-及以前","link":"#_2-permgen-space-永久代内存溢出-jdk-7-及以前","children":[]},{"level":3,"title":"3. Metaspace (元空间内存溢出) [JDK 8 及以后]","slug":"_3-metaspace-元空间内存溢出-jdk-8-及以后","link":"#_3-metaspace-元空间内存溢出-jdk-8-及以后","children":[]},{"level":3,"title":"4. Stack Space (栈内存溢出)","slug":"_4-stack-space-栈内存溢出","link":"#_4-stack-space-栈内存溢出","children":[]},{"level":3,"title":"5. Direct Memory (直接内存溢出)","slug":"_5-direct-memory-直接内存溢出","link":"#_5-direct-memory-直接内存溢出","children":[]}]},{"level":2,"title":"如何诊断和解决 OOM 问题","slug":"如何诊断和解决-oom-问题","link":"#如何诊断和解决-oom-问题","children":[]},{"level":2,"title":"OOM 错误的常见 JVM 参数","slug":"oom-错误的常见-jvm-参数","link":"#oom-错误的常见-jvm-参数","children":[]}],"readingTime":{"minutes":4.37,"words":1310},"filePathRelative":"JVM/OOM.md","localizedDate":"2024年12月17日","excerpt":"\\n<blockquote>\\n<p>OOM 是 Out of Memory（内存溢出）的缩写，表示程序在运行过程中请求内存时超出了可用内存的限制，从而导致程序崩溃或无法继续执行。OOM 是一种常见的错误，尤其在涉及大规模数据处理或长时间运行的应用中较为频繁。</p>\\n</blockquote>\\n"}')}}]);