"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[27883],{66262:(l,i)=>{i.A=(l,i)=>{const n=l.__vccOpts||l;for(const[l,t]of i)n[l]=t;return n}},43375:(l,i,n)=>{n.r(i),n.d(i,{comp:()=>r,data:()=>e});var t=n(20641);const s={},r=(0,n(66262).A)(s,[["render",function(l,i){return(0,t.uX)(),(0,t.CE)("div",null,i[0]||(i[0]=[(0,t.Fv)('<h1 id="两种缓存重建方案" tabindex="-1"><a class="header-anchor" href="#两种缓存重建方案"><span>两种缓存重建方案</span></a></h1><h2 id="方案-a-消息驱动缓存重建" tabindex="-1"><a class="header-anchor" href="#方案-a-消息驱动缓存重建"><span>方案 A：消息驱动缓存重建</span></a></h2><ol><li><strong>数据更新数据库</strong><ul><li>每条业务数据变更后，首先在数据库中完成状态更新。</li></ul></li><li><strong>发送 MQ 消息</strong><ul><li>消息中只携带 <strong>数据主键 ID</strong>，不包含完整对象。</li><li>目的是通知缓存服务该数据需要更新。</li></ul></li><li><strong>消费 MQ 重建缓存</strong><ul><li>缓存服务消费消息后，根据 ID 从数据库查询最新数据。</li><li>将最新数据写入 Redis 缓存。</li></ul></li></ol><p>✅ <strong>优化点</strong></p><ul><li>消息只携带 ID，减小 MQ 消息体积，提高吞吐。</li><li>数据库查询最新状态，保证缓存与 DB 一致性。</li><li>可以结合 <strong>批量积累</strong> 或 <strong>延迟队列</strong>，减少单条缓存写入压力。</li></ul><hr><h2 id="方案-b-批量缓存更新" tabindex="-1"><a class="header-anchor" href="#方案-b-批量缓存更新"><span>方案 B：批量缓存更新</span></a></h2><ol><li><strong>积累待更新数据 ID</strong><ul><li>每条数据库更新完成后，将 <strong>数据 ID</strong> 放入 <strong>Redis 队列</strong>（List 或 Set）。</li><li>Redis SET 可用于去重，避免重复写缓存。</li></ul></li><li><strong>批量触发缓存重建</strong><ul><li>服务端定时任务（如每 5 秒或每达到 N 条）检查 Redis 队列。</li><li>使用 <strong>分布式锁</strong>（如 Redisson）确保多实例同时运行时，只会有一个任务执行批量重建。</li></ul></li><li><strong>批量读取数据库并写缓存</strong><ul><li>根据队列中的 ID 批量查询数据库最新数据。</li><li>使用 <strong>Redis Pipeline</strong> 批量写缓存，减少网络往返，提高性能。</li></ul></li><li><strong>清理队列</strong><ul><li>写入缓存成功后，从队列中删除已处理 ID。</li><li>失败的 ID 可重新放回队列，保证最终一致性。</li></ul></li></ol><p>✅ <strong>优化点</strong></p><ul><li>批量操作降低 Redis 压力，提高吞吐。</li><li>分布式锁保证多实例环境下的幂等性。</li><li>队列去重防止重复写缓存。</li><li>可以结合阈值触发和定时触发，兼顾延迟和实时性。</li></ul><hr><h3 id="对比与选择" tabindex="-1"><a class="header-anchor" href="#对比与选择"><span><strong>对比与选择</strong></span></a></h3><table><thead><tr><th>方案</th><th>优点</th><th>适用场景</th></tr></thead><tbody><tr><td>MQ 消息驱动</td><td>实时性高，缓存接近数据库更新</td><td>数据量中小，延迟要求高</td></tr><tr><td>Redis 队列 + 批量写</td><td>减少 Redis 写入压力，适合高吞吐量</td><td>大量数据更新，缓存写入压力大</td></tr></tbody></table><hr><h3 id="推荐实践" tabindex="-1"><a class="header-anchor" href="#推荐实践"><span><strong>推荐实践</strong></span></a></h3><ul><li><strong>高并发大数据量</strong> → 方案 B（批量重建 + Pipeline + 分布式锁）</li><li><strong>低并发、对缓存实时性要求高</strong> → 方案 A（MQ 消息驱动）</li><li><strong>企业项目常用</strong> → 将两者结合：MQ 消息驱动积累待更新 ID，定时批量重建缓存。</li></ul>',16)]))}]]),e=JSON.parse('{"path":"/Interview/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E4%B8%A4%E7%A7%8D%E7%BC%93%E5%AD%98%E9%87%8D%E5%BB%BA%E6%96%B9%E6%A1%88.html","title":"两种缓存重建方案","lang":"zh-CN","frontmatter":{"gitInclude":[]},"headers":[{"level":2,"title":"方案 A：消息驱动缓存重建","slug":"方案-a-消息驱动缓存重建","link":"#方案-a-消息驱动缓存重建","children":[]},{"level":2,"title":"方案 B：批量缓存更新","slug":"方案-b-批量缓存更新","link":"#方案-b-批量缓存更新","children":[{"level":3,"title":"对比与选择","slug":"对比与选择","link":"#对比与选择","children":[]},{"level":3,"title":"推荐实践","slug":"推荐实践","link":"#推荐实践","children":[]}]}],"readingTime":{"minutes":2.02,"words":605},"filePathRelative":"Interview/面试准备/两种缓存重建方案.md","excerpt":"\\n<h2>方案 A：消息驱动缓存重建</h2>\\n<ol>\\n<li><strong>数据更新数据库</strong>\\n<ul>\\n<li>每条业务数据变更后，首先在数据库中完成状态更新。</li>\\n</ul>\\n</li>\\n<li><strong>发送 MQ 消息</strong>\\n<ul>\\n<li>消息中只携带 <strong>数据主键 ID</strong>，不包含完整对象。</li>\\n<li>目的是通知缓存服务该数据需要更新。</li>\\n</ul>\\n</li>\\n<li><strong>消费 MQ 重建缓存</strong>\\n<ul>\\n<li>缓存服务消费消息后，根据 ID 从数据库查询最新数据。</li>\\n<li>将最新数据写入 Redis 缓存。</li>\\n</ul>\\n</li>\\n</ol>"}')}}]);