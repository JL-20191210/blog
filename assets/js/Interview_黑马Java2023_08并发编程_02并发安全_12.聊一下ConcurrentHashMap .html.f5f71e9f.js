"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[2336],{66262:(n,a)=>{a.A=(n,a)=>{const e=n.__vccOpts||n;for(const[n,t]of a)e[n]=t;return e}},81135:(n,a,e)=>{e.r(a),e.d(a,{comp:()=>p,data:()=>c});var t=e(20641);const r=e.p+"assets/img/17411821375747.cacd84bb.png",s=e.p+"assets/img/17411821304601.e0474956.png",i=e.p+"assets/img/17411821340824.a567016c.png",h={},p=(0,e(66262).A)(h,[["render",function(n,a){return(0,t.uX)(),(0,t.CE)("div",null,a[0]||(a[0]=[(0,t.Fv)('<h1 id="_12-聊一下concurrenthashmap" tabindex="-1"><a class="header-anchor" href="#_12-聊一下concurrenthashmap"><span>12.聊一下ConcurrentHashMap</span></a></h1><div class="hint-container important"><p class="hint-container-title">重要</p><p><strong>参考回答</strong></p><p>ConcurrentHashMap 是一种<code>线程安全</code>的<code>高效</code>Map集合，jdk1.7和1.8也做了很多调整。</p><ul><li>JDK1.7的底层采用是<strong>分段的数组</strong>+<strong>链表</strong> 实现</li><li>JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表/红黑二叉树。</li></ul><p>在jdk1.7中 ConcurrentHashMap 里包含一个 Segment 数组。Segment 的结构和HashMap类似，是一 种数组和链表结构，一个 Segment 包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素，每个 Segment 守护着一个HashEntry数组里的元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment的锁。</p><p>Segment 是一种可重入的锁 ReentrantLock，每个 Segment 守护一个HashEntry 数组里得元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment 锁</p><p>在jdk1.8中的ConcurrentHashMap 做了较大的优化，性能提升了不少。首先是它的数据结构与jdk1.8的hashMap数据结构完全一致。其次是放弃了Segment臃肿的设计，取而代之的是采用Node + CAS + Synchronized来保 证并发安全进行实现，synchronized只锁定当前链表或红黑二叉树的首节点，这样<code>只要hash不冲突</code>，就不会产生并发 , 效率得到提升</p></div><hr><ol><li><h3 id="concurrenthashmap" tabindex="-1"><a class="header-anchor" href="#concurrenthashmap"><span>ConcurrentHashMap</span></a></h3></li></ol><blockquote><p>难易程度：☆☆☆</p><p>出现频率：☆☆☆☆</p></blockquote><p>ConcurrentHashMap 是一种线程安全的高效Map集合</p><p>底层数据结构：</p><ul><li>JDK1.7底层采用分段的数组+链表实现</li><li>JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表/红黑二叉树。</li></ul><h4 id="_1-jdk1-7中concurrenthashmap" tabindex="-1"><a class="header-anchor" href="#_1-jdk1-7中concurrenthashmap"><span>（1） JDK1.7中concurrentHashMap</span></a></h4><p>数据结构</p><figure><img src="'+r+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><blockquote><ul><li>提供了一个segment数组，在初始化ConcurrentHashMap 的时候可以指定数组的长度，默认是16，一旦初始化之后中间不可扩容</li><li>在每个segment中都可以挂一个HashEntry数组，数组里面可以存储具体的元素，HashEntry数组是可以扩容的</li><li>在HashEntry存储的数组中存储的元素，如果发生冲突，则可以挂单向链表</li></ul></blockquote><p>存储流程</p><figure><img src="'+s+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><ul><li>先去计算key的hash值，然后确定segment数组下标</li><li>再通过hash值确定hashEntry数组中的下标存储数据</li><li>在进行操作数据的之前，会先判断当前segment对应下标位置是否有线程进行操作，为了线程安全使用的是ReentrantLock进行加锁，如果获取锁是被会使用cas自旋锁进行尝试</li></ul><h4 id="_2-jdk1-8中concurrenthashmap" tabindex="-1"><a class="header-anchor" href="#_2-jdk1-8中concurrenthashmap"><span>（2） JDK1.8中concurrentHashMap</span></a></h4><p>在JDK1.8中，放弃了Segment臃肿的设计，数据结构跟HashMap的数据结构是一样的：数组+红黑树+链表</p><p>采用 CAS + Synchronized来保证并发安全进行实现</p><ul><li>CAS控制数组节点的添加</li><li>synchronized只锁定当前链表或红黑二叉树的首节点，只要hash不冲突，就不会产生并发的问题 , 效率得到提升</li></ul><figure><img src="'+i+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure>',20)]))}]]),c=JSON.parse('{"path":"/Interview/%E9%BB%91%E9%A9%ACJava2023/08%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/02%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8/12.%E8%81%8A%E4%B8%80%E4%B8%8BConcurrentHashMap%20.html","title":"12.聊一下ConcurrentHashMap","lang":"zh-CN","frontmatter":{"gitInclude":[]},"headers":[],"readingTime":{"minutes":2.42,"words":727},"filePathRelative":"Interview/黑马Java2023/08并发编程/02并发安全/12.聊一下ConcurrentHashMap .md","excerpt":"\\n<div class=\\"hint-container important\\">\\n<p class=\\"hint-container-title\\">重要</p>\\n<p><strong>参考回答</strong></p>\\n<p>ConcurrentHashMap 是一种<code>线程安全</code>的<code>高效</code>Map集合，jdk1.7和1.8也做了很多调整。</p>\\n<ul>\\n<li>JDK1.7的底层采用是<strong>分段的数组</strong>+<strong>链表</strong> 实现</li>\\n<li>JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表/红黑二叉树。</li>\\n</ul>\\n<p>在jdk1.7中 ConcurrentHashMap 里包含一个 Segment 数组。Segment 的结构和HashMap类似，是一 种数组和链表结构，一个 Segment 包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素，每个 Segment 守护着一个HashEntry数组里的元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment的锁。</p>\\n<p>Segment 是一种可重入的锁 ReentrantLock，每个 Segment 守护一个HashEntry 数组里得元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment 锁</p>\\n<p>在jdk1.8中的ConcurrentHashMap 做了较大的优化，性能提升了不少。首先是它的数据结构与jdk1.8的hashMap数据结构完全一致。其次是放弃了Segment臃肿的设计，取而代之的是采用Node + CAS + Synchronized来保 证并发安全进行实现，synchronized只锁定当前链表或红黑二叉树的首节点，这样<code>只要hash不冲突</code>，就不会产生并发 , 效率得到提升</p>\\n</div>"}')}}]);