"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[113],{66262:(t,e)=>{e.A=(t,e)=>{const n=t.__vccOpts||t;for(const[t,s]of e)n[t]=s;return n}},55923:(t,e,n)=>{n.r(e),n.d(e,{comp:()=>d,data:()=>l});var s=n(20641);const a={},d=(0,n(66262).A)(a,[["render",function(t,e){return(0,s.uX)(),(0,s.CE)("div",null,[e[0]||(e[0]=(0,s.Lk)("h1",{id:"☕-jvm面试答题卡-垃圾回收器-cms-与-g1-的区别详解",tabindex:"-1"},[(0,s.Lk)("a",{class:"header-anchor",href:"#☕-jvm面试答题卡-垃圾回收器-cms-与-g1-的区别详解"},[(0,s.Lk)("span",null,"☕ JVM面试答题卡：垃圾回收器 CMS 与 G1 的区别详解")])],-1)),e[1]||(e[1]=(0,s.Lk)("h2",{id:"✅-一句话概括",tabindex:"-1"},[(0,s.Lk)("a",{class:"header-anchor",href:"#✅-一句话概括"},[(0,s.Lk)("span",null,"✅ 一句话概括")])],-1)),e[2]||(e[2]=(0,s.Lk)("blockquote",null,[(0,s.Lk)("p",null,"CMS 是一款低延迟、基于“标记-清除”算法的并发回收器，而 G1 是面向服务端的低延迟垃圾回收器，采用分区式管理、并发标记和“标记-整理”算法，具备更好的吞吐量和更可控的 GC 停顿时间。")],-1)),e[3]||(e[3]=(0,s.Lk)("hr",null,null,-1)),(0,s.Q3)(" more "),e[4]||(e[4]=(0,s.Fv)('<h2 id="🧱-基本原理" tabindex="-1"><a class="header-anchor" href="#🧱-基本原理"><span>🧱 基本原理</span></a></h2><table><thead><tr><th>对比项</th><th>CMS（Concurrent Mark-Sweep）</th><th>G1（Garbage First）</th></tr></thead><tbody><tr><td>设计目标</td><td>低停顿（Low Latency）</td><td>高吞吐+可预测低延迟</td></tr><tr><td>收集区域</td><td>年轻代 + 老年代（传统 Eden/Survivor/Old）</td><td>全堆划分为多个 Region（包括年轻代和老年代）</td></tr><tr><td>算法</td><td>年轻代为复制算法，老年代为 <strong>标记-清除</strong></td><td>年轻代为复制算法，老年代为 <strong>标记-整理</strong></td></tr><tr><td>并发能力</td><td>年轻代 STW，老年代可并发标记/清理</td><td>多阶段并发，支持预测暂停时间</td></tr><tr><td>停顿时间</td><td>不可预测，取决于对象数量和碎片程度</td><td>可配置目标停顿时间（如 <code>MaxGCPauseMillis</code>）</td></tr><tr><td>碎片问题</td><td>清除后有内存碎片，不可压缩</td><td>自动整理内存，碎片少</td></tr><tr><td>失败回退</td><td>CMS 失败后触发 Full GC（单线程 STW）</td><td>G1 内部 Full GC 是并发多线程</td></tr></tbody></table><hr><h2 id="📈-cms-回收流程简图" tabindex="-1"><a class="header-anchor" href="#📈-cms-回收流程简图"><span>📈 CMS 回收流程简图</span></a></h2><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>1. 初始标记(STW)</span></span>\n<span class="line"><span>2. 并发标记</span></span>\n<span class="line"><span>3. 预清理（可选）</span></span>\n<span class="line"><span>4. 重新标记(STW)</span></span>\n<span class="line"><span>5. 并发清除</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="📊-g1-回收流程简图" tabindex="-1"><a class="header-anchor" href="#📊-g1-回收流程简图"><span>📊 G1 回收流程简图</span></a></h2><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>1. 初始标记(STW)</span></span>\n<span class="line"><span>2. 并发标记</span></span>\n<span class="line"><span>3. 最终标记(STW)</span></span>\n<span class="line"><span>4. 筛选回收集(Region)</span></span>\n<span class="line"><span>5. 并发复制/压缩整理</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="🔍-详细对比分析" tabindex="-1"><a class="header-anchor" href="#🔍-详细对比分析"><span>🔍 详细对比分析</span></a></h2><table><thead><tr><th>特性</th><th>CMS</th><th>G1</th></tr></thead><tbody><tr><td>并发回收</td><td>支持（老年代）</td><td>更强（多个阶段并发）</td></tr><tr><td>内存碎片</td><td>有，清除后不压缩</td><td>无，回收同时整理</td></tr><tr><td>STW 频率和时间</td><td>较高且不可预测</td><td>可配置、可预估</td></tr><tr><td>内存分区</td><td>按代划分（年轻代、老年代）</td><td>分为多个均等 Region，按需角色</td></tr><tr><td>吞吐量</td><td>中等</td><td>高</td></tr><tr><td>适用场景</td><td>响应敏感型应用，如 Web 服务器</td><td>大内存场景、长时间运行的服务端应用</td></tr><tr><td>是否即将淘汰</td><td>✅ 是（JDK 9 之后已标记为 Deprecated）</td><td>✅ 否（G1 是默认 GC，持续优化）</td></tr></tbody></table><hr><h2 id="🚨-cms-的典型问题" tabindex="-1"><a class="header-anchor" href="#🚨-cms-的典型问题"><span>🚨 CMS 的典型问题</span></a></h2><ul><li>清除后不整理内存，导致<strong>碎片严重</strong></li><li>如果 Full GC 被触发，会退化为单线程 Serial GC，<strong>性能骤降</strong></li><li>并发阶段与用户线程同时运行，可能影响吞吐</li></ul><hr><h2 id="🌟-g1-的优势" tabindex="-1"><a class="header-anchor" href="#🌟-g1-的优势"><span>🌟 G1 的优势</span></a></h2><ul><li><strong>可预测的 GC 停顿时间</strong></li><li><strong>自动整理 Region 内存</strong>，无碎片困扰</li><li>支持 <strong>大堆内存（&gt;4GB）</strong> 场景</li><li>结合了 CMS 的低停顿优势 + 串行/并行 GC 的效率</li></ul><hr><h2 id="✅-面试答题参考句" tabindex="-1"><a class="header-anchor" href="#✅-面试答题参考句"><span>✅ 面试答题参考句</span></a></h2><blockquote><p>CMS 是一种“标记-清除”算法的并发垃圾回收器，能减少老年代 GC 的停顿时间，但存在内存碎片问题；G1 则通过将堆划分为多个 Region，实现按需回收、标记-整理，具有更好的吞吐量控制和可预测的停顿时间，是 JDK 默认推荐的 GC 策略。</p></blockquote>',20))])}]]),l=JSON.parse('{"path":"/Interview/%E9%9D%A2%E8%AF%95%E7%AD%94%E9%A2%98%E5%8D%A1/JVM/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%20CMS%20%E4%B8%8E%20G1%20%E7%9A%84%E5%8C%BA%E5%88%AB%E8%AF%A6%E8%A7%A3.html","title":"垃圾回收器 CMS 与 G1 的区别详解","lang":"zh-CN","frontmatter":{"title":"垃圾回收器 CMS 与 G1 的区别详解","icon":"fa-solid fa-recycle","date":"2025-07-13T00:00:00.000Z","author":"JeanHu","category":["JVM","GC机制"],"tag":["JVM","GC","CMS","G1","回收器对比"],"summary":"本文对比分析了 CMS 与 G1 两种垃圾回收器在回收算法、内存布局、STW 行为与适用场景方面的核心差异，帮助开发者在性能调优中合理选型。","gitInclude":[]},"headers":[{"level":2,"title":"✅ 一句话概括","slug":"✅-一句话概括","link":"#✅-一句话概括","children":[]},{"level":2,"title":"🧱 基本原理","slug":"🧱-基本原理","link":"#🧱-基本原理","children":[]},{"level":2,"title":"📈 CMS 回收流程简图","slug":"📈-cms-回收流程简图","link":"#📈-cms-回收流程简图","children":[]},{"level":2,"title":"📊 G1 回收流程简图","slug":"📊-g1-回收流程简图","link":"#📊-g1-回收流程简图","children":[]},{"level":2,"title":"🔍 详细对比分析","slug":"🔍-详细对比分析","link":"#🔍-详细对比分析","children":[]},{"level":2,"title":"🚨 CMS 的典型问题","slug":"🚨-cms-的典型问题","link":"#🚨-cms-的典型问题","children":[]},{"level":2,"title":"🌟 G1 的优势","slug":"🌟-g1-的优势","link":"#🌟-g1-的优势","children":[]},{"level":2,"title":"✅ 面试答题参考句","slug":"✅-面试答题参考句","link":"#✅-面试答题参考句","children":[]}],"readingTime":{"minutes":2.82,"words":845},"filePathRelative":"Interview/面试答题卡/JVM/垃圾回收器 CMS 与 G1 的区别详解.md","localizedDate":"2025年7月13日","excerpt":"\\n<h2>✅ 一句话概括</h2>\\n<blockquote>\\n<p>CMS 是一款低延迟、基于“标记-清除”算法的并发回收器，而 G1 是面向服务端的低延迟垃圾回收器，采用分区式管理、并发标记和“标记-整理”算法，具备更好的吞吐量和更可控的 GC 停顿时间。</p>\\n</blockquote>\\n<hr>\\n"}')}}]);