"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[10194],{66262:(n,e)=>{e.A=(n,e)=>{const a=n.__vccOpts||n;for(const[n,s]of e)a[n]=s;return a}},79925:(n,e,a)=>{a.r(e),a.d(e,{comp:()=>t,data:()=>l});var s=a(20641);const i={},t=(0,a(66262).A)(i,[["render",function(n,e){return(0,s.uX)(),(0,s.CE)("div",null,[e[0]||(e[0]=(0,s.Fv)('<h1 id="☕-spring-三级缓存解决循环依赖详解" tabindex="-1"><a class="header-anchor" href="#☕-spring-三级缓存解决循环依赖详解"><span>☕ Spring 三级缓存解决循环依赖详解</span></a></h1><hr><h2 id="✅-一句话概括" tabindex="-1"><a class="header-anchor" href="#✅-一句话概括"><span>✅ 一句话概括</span></a></h2><blockquote><p>Spring 通过三级缓存（单例池、提前暴露的半成品缓存、工厂缓存）机制，有效解决单例 Bean 在创建过程中因相互依赖导致的循环依赖问题。</p></blockquote><div class="hint-container important"><p class="hint-container-title">重要</p><p>自始至终BeanA和BeanB都只有一个对象实例。</p><p><strong>A 还没完全初始化完时，就能被 B 引用</strong></p><p>提前暴露的半成品 Bean 其实就像是一个“承诺”，告诉其他依赖它的 Bean：“我已经实例化了，你可以先引用我，后续我会完善你看到的功能。”</p></div><hr>',6)),(0,s.Q3)(" more "),e[1]||(e[1]=(0,s.Fv)('<h2 id="🧱-三个缓存说明" tabindex="-1"><a class="header-anchor" href="#🧱-三个缓存说明"><span>🧱 三个缓存说明</span></a></h2><table><thead><tr><th>缓存名称</th><th>作用</th><th>存储对象</th></tr></thead><tbody><tr><td>一级缓存（singletonObjects）</td><td>存放完全初始化好的单例 Bean</td><td>完整的 Bean 实例（成品）</td></tr><tr><td>二级缓存（earlySingletonObjects）</td><td>存放提前暴露的 Bean 实例（半成品）</td><td>尚未完成依赖注入的 Bean</td></tr><tr><td>三级缓存（singletonFactories）</td><td>存放可以创建 Bean 的工厂对象</td><td>ObjectFactory 接口对象</td></tr></tbody></table><hr><h2 id="🔍-三级缓存解决循环依赖的流程" tabindex="-1"><a class="header-anchor" href="#🔍-三级缓存解决循环依赖的流程"><span>🔍 三级缓存解决循环依赖的流程</span></a></h2><ol><li><strong>实例化 Bean</strong> Spring 创建 Bean 实例，但还未进行依赖注入（属性填充）。</li><li><strong>放入三级缓存</strong> 将创建好的 Bean 工厂对象（ObjectFactory）放入三级缓存 <code>singletonFactories</code>。</li><li><strong>提前暴露半成品 Bean</strong> 当另一个 Bean 需要此 Bean 时，先从三级缓存获取 ObjectFactory，调用其 <code>getObject()</code> 方法，生成并放入二级缓存 <code>earlySingletonObjects</code>。</li><li><strong>依赖注入完成</strong> 完成依赖注入，Bean 初始化完成后，移除三级缓存和二级缓存，放入一级缓存（成品池）。</li></ol><hr><h2 id="📈-简单示意图" tabindex="-1"><a class="header-anchor" href="#📈-简单示意图"><span>📈 简单示意图</span></a></h2><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>BeanA -&gt; 需要 BeanB</span></span>\n<span class="line"><span>BeanB -&gt; 需要 BeanA</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>创建 BeanA 实例（未填充属性）</span></span>\n<span class="line"><span>  ↓</span></span>\n<span class="line"><span>放入三级缓存 singletonFactories（工厂）</span></span>\n<span class="line"><span>  ↓</span></span>\n<span class="line"><span>BeanA 依赖 BeanB，创建 BeanB 实例，放入三级缓存</span></span>\n<span class="line"><span>  ↓</span></span>\n<span class="line"><span>BeanB 依赖 BeanA，从三级缓存取 ObjectFactory，暴露 BeanA 半成品</span></span>\n<span class="line"><span>  ↓</span></span>\n<span class="line"><span>属性填充完成，BeanA、BeanB 均完成初始化，放入一级缓存</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="⚠️-注意事项" tabindex="-1"><a class="header-anchor" href="#⚠️-注意事项"><span>⚠️ 注意事项</span></a></h2><ul><li>仅<strong>单例 Bean</strong>支持通过三级缓存解决循环依赖，原型 Bean 不支持。</li><li>三级缓存中的 ObjectFactory 能够延迟创建对象，避免死循环。</li><li>Spring 只能解决构造器注入（constructor injection）外的循环依赖问题，构造器注入的循环依赖会抛异常。</li></ul><hr><h2 id="📝-面试答题模板" tabindex="-1"><a class="header-anchor" href="#📝-面试答题模板"><span>📝 面试答题模板</span></a></h2><blockquote><p>Spring 通过三级缓存机制解决循环依赖问题。首先在实例化 Bean 时，将其 ObjectFactory 放入三级缓存，允许提前暴露半成品 Bean。当其他 Bean 需要注入时，可以先从三级缓存拿到半成品 Bean 进行依赖注入。注入完成后，Bean 移入一级缓存，完成生命周期。该机制只适用于单例 Bean，且不能解决构造器注入的循环依赖。</p></blockquote>',14))])}]]),l=JSON.parse('{"path":"/Interview/%E9%9D%A2%E8%AF%95%E7%AD%94%E9%A2%98%E5%8D%A1/Spring/Spring%20%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E8%AF%A6%E8%A7%A3.html","title":"Spring 三级缓存解决循环依赖详解","lang":"zh-CN","frontmatter":{"title":"Spring 三级缓存解决循环依赖详解","icon":"fa-solid fa-layer-group","date":"2025-07-14T00:00:00.000Z","author":"JeanHu","category":["Spring","依赖注入"],"tag":["Spring","三级缓存","循环依赖","依赖注入"],"summary":"本文详细讲解 Spring 框架中三级缓存机制如何解决 Bean 循环依赖问题，涵盖缓存原理、创建流程。帮助开发者深入理解依赖注入底层细节。","gitInclude":[]},"headers":[{"level":2,"title":"✅ 一句话概括","slug":"✅-一句话概括","link":"#✅-一句话概括","children":[]},{"level":2,"title":"🧱 三个缓存说明","slug":"🧱-三个缓存说明","link":"#🧱-三个缓存说明","children":[]},{"level":2,"title":"🔍 三级缓存解决循环依赖的流程","slug":"🔍-三级缓存解决循环依赖的流程","link":"#🔍-三级缓存解决循环依赖的流程","children":[]},{"level":2,"title":"📈 简单示意图","slug":"📈-简单示意图","link":"#📈-简单示意图","children":[]},{"level":2,"title":"⚠️ 注意事项","slug":"⚠️-注意事项","link":"#⚠️-注意事项","children":[]},{"level":2,"title":"📝 面试答题模板","slug":"📝-面试答题模板","link":"#📝-面试答题模板","children":[]}],"readingTime":{"minutes":2.61,"words":784},"filePathRelative":"Interview/面试答题卡/Spring/Spring 三级缓存解决循环依赖详解.md","localizedDate":"2025年7月14日","excerpt":"\\n<hr>\\n<h2>✅ 一句话概括</h2>\\n<blockquote>\\n<p>Spring 通过三级缓存（单例池、提前暴露的半成品缓存、工厂缓存）机制，有效解决单例 Bean 在创建过程中因相互依赖导致的循环依赖问题。</p>\\n</blockquote>\\n<div class=\\"hint-container important\\">\\n<p class=\\"hint-container-title\\">重要</p>\\n<p>自始至终BeanA和BeanB都只有一个对象实例。</p>\\n<p><strong>A 还没完全初始化完时，就能被 B 引用</strong></p>\\n<p>提前暴露的半成品 Bean 其实就像是一个“承诺”，告诉其他依赖它的 Bean：“我已经实例化了，你可以先引用我，后续我会完善你看到的功能。”</p>\\n</div>\\n<hr>\\n"}')}}]);