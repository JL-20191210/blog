"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[10184],{66262:(n,a)=>{a.A=(n,a)=>{const t=n.__vccOpts||n;for(const[n,s]of a)t[n]=s;return t}},5418:(n,a,t)=>{t.r(a),t.d(a,{comp:()=>i,data:()=>l});var s=t(20641);const e={},i=(0,t(66262).A)(e,[["render",function(n,a){return(0,s.uX)(),(0,s.CE)("div",null,a[0]||(a[0]=[(0,s.Fv)('<h1 id="☕java面试答题卡-java-中注解的原理" tabindex="-1"><a class="header-anchor" href="#☕java面试答题卡-java-中注解的原理"><span><strong>☕Java面试答题卡：Java 中注解的原理</strong></span></a></h1><h2 id="❓面试题目" tabindex="-1"><a class="header-anchor" href="#❓面试题目"><span><strong>❓面试题目：</strong></span></a></h2><p><strong>请简述 Java 注解的原理及其实现机制。</strong></p><h2 id="✅-答题要点" tabindex="-1"><a class="header-anchor" href="#✅-答题要点"><span><strong>✅ 答题要点：</strong></span></a></h2><h3 id="_1️⃣-什么是注解-annotation" tabindex="-1"><a class="header-anchor" href="#_1️⃣-什么是注解-annotation"><span><strong>1️⃣ 什么是注解（Annotation）</strong></span></a></h3><ul><li>注解是 Java 5 引入的一种元数据机制，用于在 <strong>源代码中嵌入信息</strong>，这些信息可供编译器、工具或运行时使用。</li><li>注解本质上是 <strong>继承了 java.lang.annotation.Annotation 接口的特殊接口</strong>。</li></ul><h3 id="_2️⃣-注解的分类-按作用时机" tabindex="-1"><a class="header-anchor" href="#_2️⃣-注解的分类-按作用时机"><span><strong>2️⃣ 注解的分类（按作用时机）</strong></span></a></h3><table><thead><tr><th><strong>类型</strong></th><th><strong>使用时机</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td>源码注解（SOURCE）</td><td>编译时丢弃，仅用于编译检查</td><td>@Override, @SuppressWarnings</td></tr><tr><td>编译时注解（CLASS）</td><td>编译进 .class 文件，运行时不可见</td><td>一些 IDE 工具注解</td></tr><tr><td>运行时注解（RUNTIME）</td><td>编译进 .class，运行时可通过反射读取</td><td>@Autowired, @RequestMapping 等</td></tr></tbody></table><blockquote><p>通过 @Retention(RetentionPolicy.RUNTIME) 控制注解的生命周期</p></blockquote><h3 id="_3️⃣-注解的实现原理" tabindex="-1"><a class="header-anchor" href="#_3️⃣-注解的实现原理"><span><strong>3️⃣ 注解的实现原理</strong></span></a></h3><h4 id="✅-注解本质是一个接口" tabindex="-1"><a class="header-anchor" href="#✅-注解本质是一个接口"><span><strong>✅ 注解本质是一个接口</strong></span></a></h4><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>public @interface MyAnnotation {</span></span>\n<span class="line"><span>    String value();</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>编译后会生成一个继承了 java.lang.annotation.Annotation 的接口文件。</p></blockquote><h4 id="✅-运行时通过反射获取注解信息" tabindex="-1"><a class="header-anchor" href="#✅-运行时通过反射获取注解信息"><span><strong>✅ 运行时通过反射获取注解信息</strong></span></a></h4><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>Method method = MyClass.class.getMethod(&quot;sayHello&quot;);</span></span>\n<span class="line"><span>MyAnnotation annotation = method.getAnnotation(MyAnnotation.class);</span></span>\n<span class="line"><span>System.out.println(annotation.value());</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>JVM 在加载类时，会把注解作为<strong>类元信息</strong>保存在 .class 文件中；</p></li><li><p>若注解是 RUNTIME 类型，JVM 会通过反射 API 提供访问入口；</p></li><li><p>常用反射类：</p><ul><li>Class：类级注解</li><li>Method：方法级注解</li><li>Field：字段注解</li><li>Annotation：注解本身的元信息</li></ul></li></ul><h3 id="_4️⃣-注解处理器-apt-机制【进阶】" tabindex="-1"><a class="header-anchor" href="#_4️⃣-注解处理器-apt-机制【进阶】"><span><strong>4️⃣ 注解处理器（APT）机制【进阶】</strong></span></a></h3><ul><li><strong>APT（Annotation Processing Tool）</strong>：Java 提供的编译期注解处理机制，用于分析源代码中的注解，并生成新代码、配置等。</li><li>实现方式：继承 AbstractProcessor，配合 @SupportedAnnotationTypes 和 @SupportedSourceVersion</li></ul><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>@SupportedAnnotationTypes(&quot;com.example.MyAnnotation&quot;)</span></span>\n<span class="line"><span>@SupportedSourceVersion(SourceVersion.RELEASE_8)</span></span>\n<span class="line"><span>public class MyProcessor extends AbstractProcessor {</span></span>\n<span class="line"><span>    @Override</span></span>\n<span class="line"><span>    public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {</span></span>\n<span class="line"><span>        // 处理注解</span></span>\n<span class="line"><span>        return true;</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>如 Lombok、Dagger、AutoService、ButterKnife 等库使用此机制实现编译期增强。</p></blockquote><h3 id="_5️⃣-注解的用途-实际应用场景" tabindex="-1"><a class="header-anchor" href="#_5️⃣-注解的用途-实际应用场景"><span><strong>5️⃣ 注解的用途（实际应用场景）</strong></span></a></h3><table><thead><tr><th><strong>类型</strong></th><th><strong>示例</strong></th><th><strong>功能描述</strong></th></tr></thead><tbody><tr><td>编译检查类</td><td>@Override, @Deprecated</td><td>帮助编译器进行语法校验</td></tr><tr><td>配置类</td><td>@Controller, @Service</td><td>通过注解驱动框架行为（Spring）</td></tr><tr><td>元注解</td><td>@Target, @Retention</td><td>注解用来修饰注解本身</td></tr><tr><td>文档类</td><td>@Documented</td><td>生成 Javadoc 时包含注解信息</td></tr></tbody></table><h2 id="📌-总结口诀" tabindex="-1"><a class="header-anchor" href="#📌-总结口诀"><span><strong>📌 总结口诀</strong></span></a></h2><blockquote><p>注解是接口，保存在字节码；</p></blockquote><blockquote><p>配合反射用，运行时读取它；</p></blockquote><blockquote><p>APT 编译查，源码动态造。</p></blockquote>',26)]))}]]),l=JSON.parse('{"path":"/Interview/%E9%9D%A2%E8%AF%95%E7%AD%94%E9%A2%98%E5%8D%A1/Java/Java%E6%B3%A8%E8%A7%A3%E5%8E%9F%E7%90%86.html","title":"☕Java面试答题卡：Java 中注解的原理","lang":"zh-CN","frontmatter":{"gitInclude":[]},"headers":[{"level":2,"title":"❓面试题目：","slug":"❓面试题目","link":"#❓面试题目","children":[]},{"level":2,"title":"✅ 答题要点：","slug":"✅-答题要点","link":"#✅-答题要点","children":[{"level":3,"title":"1️⃣ 什么是注解（Annotation）","slug":"_1️⃣-什么是注解-annotation","link":"#_1️⃣-什么是注解-annotation","children":[]},{"level":3,"title":"2️⃣ 注解的分类（按作用时机）","slug":"_2️⃣-注解的分类-按作用时机","link":"#_2️⃣-注解的分类-按作用时机","children":[]},{"level":3,"title":"3️⃣ 注解的实现原理","slug":"_3️⃣-注解的实现原理","link":"#_3️⃣-注解的实现原理","children":[]},{"level":3,"title":"4️⃣ 注解处理器（APT）机制【进阶】","slug":"_4️⃣-注解处理器-apt-机制【进阶】","link":"#_4️⃣-注解处理器-apt-机制【进阶】","children":[]},{"level":3,"title":"5️⃣ 注解的用途（实际应用场景）","slug":"_5️⃣-注解的用途-实际应用场景","link":"#_5️⃣-注解的用途-实际应用场景","children":[]}]},{"level":2,"title":"📌 总结口诀","slug":"📌-总结口诀","link":"#📌-总结口诀","children":[]}],"readingTime":{"minutes":1.87,"words":560},"filePathRelative":"Interview/面试答题卡/Java/Java注解原理.md","excerpt":"\\n<h2><strong>❓面试题目：</strong></h2>\\n<p><strong>请简述 Java 注解的原理及其实现机制。</strong></p>\\n<h2><strong>✅ 答题要点：</strong></h2>\\n<h3><strong>1️⃣ 什么是注解（Annotation）</strong></h3>\\n<ul>\\n<li>注解是 Java 5 引入的一种元数据机制，用于在 <strong>源代码中嵌入信息</strong>，这些信息可供编译器、工具或运行时使用。</li>\\n<li>注解本质上是 <strong>继承了 java.lang.annotation.Annotation 接口的特殊接口</strong>。</li>\\n</ul>"}')}}]);