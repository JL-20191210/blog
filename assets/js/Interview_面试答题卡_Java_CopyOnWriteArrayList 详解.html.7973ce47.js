"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[35305],{66262:(n,s)=>{s.A=(n,s)=>{const a=n.__vccOpts||n;for(const[n,e]of s)a[n]=e;return a}},86843:(n,s,a)=>{a.r(s),a.d(s,{comp:()=>t,data:()=>l});var e=a(20641);const i={},t=(0,a(66262).A)(i,[["render",function(n,s){return(0,e.uX)(),(0,e.CE)("div",null,s[0]||(s[0]=[(0,e.Fv)('<h1 id="☕-java-面试答题卡-copyonwritearraylist详解" tabindex="-1"><a class="header-anchor" href="#☕-java-面试答题卡-copyonwritearraylist详解"><span>☕ Java 面试答题卡：CopyOnWriteArrayList详解</span></a></h1><h2 id="✅-1-什么是-copyonwritearraylist" tabindex="-1"><a class="header-anchor" href="#✅-1-什么是-copyonwritearraylist"><span><strong>✅ 1. 什么是 CopyOnWriteArrayList？</strong></span></a></h2><blockquote><p>CopyOnWriteArrayList 是 Java 提供的一个 <strong>线程安全</strong> 的 List 实现，底层通过“<strong>写时复制（Copy-On-Write）</strong>”机制来实现并发安全，适用于<strong>读多写少</strong>的场景。</p></blockquote><p>它是 ArrayList 的并发替代方案，属于 java.util.concurrent 包。</p><h2 id="✅-2-底层原理-什么是写时复制" tabindex="-1"><a class="header-anchor" href="#✅-2-底层原理-什么是写时复制"><span><strong>✅ 2. 底层原理：什么是写时复制？</strong></span></a></h2><blockquote><p>所谓 <strong>写时复制</strong>：在修改（写操作）时不直接修改原始数据，而是<strong>复制出一份副本</strong>，修改副本，再将引用指向副本。</p></blockquote><h3 id="📦-举个例子" tabindex="-1"><a class="header-anchor" href="#📦-举个例子"><span><strong>📦 举个例子：</strong></span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>原数组 A：[1, 2, 3]</span></span>\n<span class="line"><span>线程1 读取 A，不受影响</span></span>\n<span class="line"><span>线程2 执行 add(4)：</span></span>\n<span class="line"><span>  → 复制数组为 A&#39;：[1, 2, 3, 4]</span></span>\n<span class="line"><span>  → 用新数组 A&#39; 替换旧数组引用</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="✅-3-核心字段" tabindex="-1"><a class="header-anchor" href="#✅-3-核心字段"><span><strong>✅ 3. 核心字段</strong></span></a></h2><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>private volatile transient Object[] array;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li>所有读操作直接基于这个 array 数组</li><li>所有写操作先复制，再替换（写期间不影响读）</li></ul><h2 id="✅-4-构造方法和用法" tabindex="-1"><a class="header-anchor" href="#✅-4-构造方法和用法"><span><strong>✅ 4. 构造方法和用法</strong></span></a></h2><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;();</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>list.add(&quot;Java&quot;);</span></span>\n<span class="line"><span>list.add(&quot;Python&quot;);</span></span>\n<span class="line"><span>System.out.println(list.get(1)); // 输出：Python</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>list.remove(&quot;Java&quot;);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="✅-5-适合的使用场景" tabindex="-1"><a class="header-anchor" href="#✅-5-适合的使用场景"><span><strong>✅ 5. 适合的使用场景</strong></span></a></h2><table><thead><tr><th><strong>场景</strong></th><th><strong>是否推荐</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>多线程只读 / 读远多于写</td><td>✅ 推荐</td><td>写操作开销大，但读操作无锁、高效</td></tr><tr><td>数据频繁变动、增删操作频繁</td><td>❌ 不推荐</td><td>每次写都复制整个数组，性能差</td></tr><tr><td>迭代时不希望出现并发修改异常</td><td>✅ 推荐</td><td>支持弱一致性迭代器（快照副本）</td></tr></tbody></table><h2 id="✅-6-与其他集合对比" tabindex="-1"><a class="header-anchor" href="#✅-6-与其他集合对比"><span><strong>✅ 6. 与其他集合对比</strong></span></a></h2><table><thead><tr><th><strong>特性</strong></th><th>ArrayList</th><th>Vector</th><th>CopyOnWriteArrayList</th></tr></thead><tbody><tr><td>是否线程安全</td><td>❌</td><td>✅（重同步）</td><td>✅（无锁读、写复制）</td></tr><tr><td>读操作效率</td><td>高</td><td>中</td><td>✅ 高（读不加锁）</td></tr><tr><td>写操作开销</td><td>低</td><td>高（加锁）</td><td>⚠️ 很高（复制整个数组）</td></tr><tr><td>是否支持并发迭代</td><td>❌ 抛异常</td><td>❌ 抛异常</td><td>✅ 支持（快照机制）</td></tr></tbody></table><h2 id="✅-7-源码片段分析-以add-为例" tabindex="-1"><a class="header-anchor" href="#✅-7-源码片段分析-以add-为例"><span>✅ 7. 源码片段分析（以add()为例)</span></a></h2><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>public boolean add(E e) {</span></span>\n<span class="line"><span>    final ReentrantLock lock = this.lock;</span></span>\n<span class="line"><span>    lock.lock();</span></span>\n<span class="line"><span>    try {</span></span>\n<span class="line"><span>        Object[] elements = getArray();     // 获取当前数组</span></span>\n<span class="line"><span>        int len = elements.length;</span></span>\n<span class="line"><span>        Object[] newElements = Arrays.copyOf(elements, len + 1); // 复制新数组</span></span>\n<span class="line"><span>        newElements[len] = e;</span></span>\n<span class="line"><span>        setArray(newElements);              // 替换旧数组</span></span>\n<span class="line"><span>        return true;</span></span>\n<span class="line"><span>    } finally {</span></span>\n<span class="line"><span>        lock.unlock();</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>采用显式 ReentrantLock 加锁</li><li>所有修改操作都会复制整个数组并替换</li></ul><h2 id="✅-8-为什么迭代时不会抛异常" tabindex="-1"><a class="header-anchor" href="#✅-8-为什么迭代时不会抛异常"><span><strong>✅ 8. 为什么迭代时不会抛异常？</strong></span></a></h2><ul><li>CopyOnWriteArrayList 的迭代器基于“快照数组”</li><li>即使原集合被修改，迭代器仍使用原数组 → 不抛 ConcurrentModificationException</li></ul><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>for (String s : list) {</span></span>\n<span class="line"><span>    list.remove(s); // ✅ 安全，不影响当前 for-each</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="✅-9-面试常问问题答法" tabindex="-1"><a class="header-anchor" href="#✅-9-面试常问问题答法"><span><strong>✅ 9. 面试常问问题答法</strong></span></a></h2><h3 id="🔹-q1-copyonwritearraylist-如何实现线程安全" tabindex="-1"><a class="header-anchor" href="#🔹-q1-copyonwritearraylist-如何实现线程安全"><span><strong>🔹 Q1：CopyOnWriteArrayList 如何实现线程安全？</strong></span></a></h3><blockquote><p>读操作无锁，写操作通过加锁并复制新数组，然后原子替换；保证读写隔离，不发生冲突。</p></blockquote><h3 id="🔹-q2-适合什么场景" tabindex="-1"><a class="header-anchor" href="#🔹-q2-适合什么场景"><span><strong>🔹 Q2：适合什么场景？</strong></span></a></h3><blockquote><p>读远多于写的场景，例如黑名单、配置表、订阅列表；不适合频繁写的环境。</p></blockquote><h3 id="🔹-q3-为啥不抛-concurrentmodificationexception" tabindex="-1"><a class="header-anchor" href="#🔹-q3-为啥不抛-concurrentmodificationexception"><span><strong>🔹 Q3：为啥不抛 ConcurrentModificationException？</strong></span></a></h3><blockquote><p>因为它的迭代器是基于旧数组的快照，遍历的是旧数据，不受写操作影响。</p></blockquote><h2 id="🎯-面试答题模板-建议背诵" tabindex="-1"><a class="header-anchor" href="#🎯-面试答题模板-建议背诵"><span><strong>🎯 面试答题模板（建议背诵）</strong></span></a></h2><blockquote><p>CopyOnWriteArrayList 是 Java 中线程安全的 List 实现，通过写时复制（Copy-On-Write）机制实现读写隔离。读操作无锁、写操作通过复制新数组实现。适用于读多写少、且希望避免并发修改异常的场景，如配置缓存、订阅列表等。</p></blockquote>',32)]))}]]),l=JSON.parse('{"path":"/Interview/%E9%9D%A2%E8%AF%95%E7%AD%94%E9%A2%98%E5%8D%A1/Java/CopyOnWriteArrayList%20%E8%AF%A6%E8%A7%A3.html","title":"☕ Java 面试答题卡：CopyOnWriteArrayList详解","lang":"zh-CN","frontmatter":{"gitInclude":[]},"headers":[{"level":2,"title":"✅ 1. 什么是 CopyOnWriteArrayList？","slug":"✅-1-什么是-copyonwritearraylist","link":"#✅-1-什么是-copyonwritearraylist","children":[]},{"level":2,"title":"✅ 2. 底层原理：什么是写时复制？","slug":"✅-2-底层原理-什么是写时复制","link":"#✅-2-底层原理-什么是写时复制","children":[{"level":3,"title":"📦 举个例子：","slug":"📦-举个例子","link":"#📦-举个例子","children":[]}]},{"level":2,"title":"✅ 3. 核心字段","slug":"✅-3-核心字段","link":"#✅-3-核心字段","children":[]},{"level":2,"title":"✅ 4. 构造方法和用法","slug":"✅-4-构造方法和用法","link":"#✅-4-构造方法和用法","children":[]},{"level":2,"title":"✅ 5. 适合的使用场景","slug":"✅-5-适合的使用场景","link":"#✅-5-适合的使用场景","children":[]},{"level":2,"title":"✅ 6. 与其他集合对比","slug":"✅-6-与其他集合对比","link":"#✅-6-与其他集合对比","children":[]},{"level":2,"title":"✅ 7. 源码片段分析（以add()为例)","slug":"✅-7-源码片段分析-以add-为例","link":"#✅-7-源码片段分析-以add-为例","children":[]},{"level":2,"title":"✅ 8. 为什么迭代时不会抛异常？","slug":"✅-8-为什么迭代时不会抛异常","link":"#✅-8-为什么迭代时不会抛异常","children":[]},{"level":2,"title":"✅ 9. 面试常问问题答法","slug":"✅-9-面试常问问题答法","link":"#✅-9-面试常问问题答法","children":[{"level":3,"title":"🔹 Q1：CopyOnWriteArrayList 如何实现线程安全？","slug":"🔹-q1-copyonwritearraylist-如何实现线程安全","link":"#🔹-q1-copyonwritearraylist-如何实现线程安全","children":[]},{"level":3,"title":"🔹 Q2：适合什么场景？","slug":"🔹-q2-适合什么场景","link":"#🔹-q2-适合什么场景","children":[]},{"level":3,"title":"🔹 Q3：为啥不抛 ConcurrentModificationException？","slug":"🔹-q3-为啥不抛-concurrentmodificationexception","link":"#🔹-q3-为啥不抛-concurrentmodificationexception","children":[]}]},{"level":2,"title":"🎯 面试答题模板（建议背诵）","slug":"🎯-面试答题模板-建议背诵","link":"#🎯-面试答题模板-建议背诵","children":[]}],"readingTime":{"minutes":2.61,"words":782},"filePathRelative":"Interview/面试答题卡/Java/CopyOnWriteArrayList 详解.md","excerpt":"\\n<h2><strong>✅ 1. 什么是 CopyOnWriteArrayList？</strong></h2>\\n<blockquote>\\n<p>CopyOnWriteArrayList 是 Java 提供的一个 <strong>线程安全</strong> 的 List 实现，底层通过“<strong>写时复制（Copy-On-Write）</strong>”机制来实现并发安全，适用于<strong>读多写少</strong>的场景。</p>\\n</blockquote>\\n<p>它是 ArrayList 的并发替代方案，属于 java.util.concurrent 包。</p>\\n<h2><strong>✅ 2. 底层原理：什么是写时复制？</strong></h2>"}')}}]);