"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[2133],{66262:(i,s)=>{s.A=(i,s)=>{const a=i.__vccOpts||i;for(const[i,n]of s)a[i]=n;return a}},94696:(i,s,a)=>{a.r(s),a.d(s,{comp:()=>t,data:()=>p});var n=a(20641);const l=a.p+"assets/img/e0d880256cc6cf449e4bbe56e63b9ec4.e264d769.png",e=a.p+"assets/img/55798c5ea77cfadb11e3090dcb2d1d91.9f734106.png",h={},t=(0,a(66262).A)(h,[["render",function(i,s){return(0,n.uX)(),(0,n.CE)("div",null,s[0]||(s[0]=[(0,n.Fv)('<h1 id="_6-直接内存" tabindex="-1"><a class="header-anchor" href="#_6-直接内存"><span>6.直接内存</span></a></h1><h2 id="_6-1-什么是直接内存" tabindex="-1"><a class="header-anchor" href="#_6-1-什么是直接内存"><span>6.1 什么是直接内存？</span></a></h2><h3 id="_6-1-1-直接内存的定义" tabindex="-1"><a class="header-anchor" href="#_6-1-1-直接内存的定义"><span>6.1.1 直接内存的定义</span></a></h3><blockquote><p>直接内存（Direct Memory）是一种特殊的内存区域，常见于 Java NIO（New Input/Output）操作中，用作数据缓冲区。</p></blockquote><figure><img src="'+l+'" alt="不使用直接内存" tabindex="0" loading="lazy"><figcaption>不使用直接内存</figcaption></figure><figure><img src="'+e+'" alt="使用直接内存" tabindex="0" loading="lazy"><figcaption>使用直接内存</figcaption></figure><h3 id="_6-1-2-直接内存的特点" tabindex="-1"><a class="header-anchor" href="#_6-1-2-直接内存的特点"><span>6.1.2 直接内存的特点</span></a></h3><ul><li><p>性能优势：直接内存不需要在 Java 堆和操作系统内存之间频繁复制数据，读写性能高。</p></li><li><p>管理方式：直接内存由操作系统分配和回收，不受 JVM 垃圾回收（GC）管理。</p></li><li><p>使用代价：分配和回收的成本较高，需要谨慎管理，否则容易导致内存泄漏。</p></li></ul><h2 id="_6-2-为什么要使用直接内存" tabindex="-1"><a class="header-anchor" href="#_6-2-为什么要使用直接内存"><span>6.2 为什么要使用直接内存？</span></a></h2><h3 id="_6-2-1-文件读写的常规流程" tabindex="-1"><a class="header-anchor" href="#_6-2-1-文件读写的常规流程"><span>6.2.1 文件读写的常规流程</span></a></h3><p>在 Java 中，文件读取通常涉及以下步骤：</p><ol><li><p>使用本地方法切换到内核态，通过系统调用读取磁盘文件。</p></li><li><p>将数据存储到系统缓冲区。</p></li><li><p>将系统缓冲区中的数据复制到 Java 堆内存中。</p></li></ol><p><strong>缺点</strong>：</p><p>这种方法会在系统缓冲区和 Java 堆内存中各存储一份数据，增加了不必要的内存复制操作，降低性能。</p><h3 id="_6-2-2-使用直接内存的改进" tabindex="-1"><a class="header-anchor" href="#_6-2-2-使用直接内存的改进"><span>6.2.2 使用直接内存的改进</span></a></h3><p>通过 DirectBuffer 使用直接内存后，操作系统和 Java 程序共享直接内存区域，避免了从系统缓冲区到 Java 堆的复制步骤，从而显著提升读写效率。</p><h2 id="_6-3-直接内存的回收机制" tabindex="-1"><a class="header-anchor" href="#_6-3-直接内存的回收机制"><span>6.3 直接内存的回收机制</span></a></h2><h3 id="_6-3-1-基于-unsafe-的内存分配和释放" tabindex="-1"><a class="header-anchor" href="#_6-3-1-基于-unsafe-的内存分配和释放"><span>6.3.1 基于 Unsafe 的内存分配和释放</span></a></h3><p>以下是直接内存分配和释放的核心代码：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">long</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> size </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> Math</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">max</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1L</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">long</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) capacity);</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">long</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> base </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> unsafe</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">allocateMemory</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(size);</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 分配内存</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">unsafe</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">setMemory</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(base, size, (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">byte</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 初始化内存</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_6-3-2-bytebuffer-的实现" tabindex="-1"><a class="header-anchor" href="#_6-3-2-bytebuffer-的实现"><span>6.3.2 ByteBuffer 的实现</span></a></h3><p>直接内存的分配可以通过 ByteBuffer.allocateDirect 方法实现：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> ByteBuffer</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> allocateDirect</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> capacity) {</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  return</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> DirectByteBuffer</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(capacity)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_6-3-2-1-directbytebuffer-的构造过程" tabindex="-1"><a class="header-anchor" href="#_6-3-2-1-directbytebuffer-的构造过程"><span>6.3.2.1 DirectByteBuffer 的构造过程</span></a></h4><p>以下是 DirectByteBuffer 的核心构造代码：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">DirectByteBuffer</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> cap) {</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">  super</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">-</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> cap</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> cap)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  long</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> size </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> Math</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">max</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1L</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">long</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) cap);</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  long</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> base </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> unsafe</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">allocateMemory</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(size);</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 分配内存</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">  unsafe</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">setMemory</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(base, size, (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">byte</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 初始化</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">  cleaner </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> Cleaner</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">create</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> Deallocator</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(base, size, cap));</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 注册虚引用</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_6-3-3-cleaner-的作用" tabindex="-1"><a class="header-anchor" href="#_6-3-3-cleaner-的作用"><span>6.3.3 Cleaner 的作用</span></a></h3><p>Cleaner 是基于虚引用的工具，用于监测 DirectByteBuffer 对象。当对象被 GC 回收时，会调用 Cleaner 的 clean 方法释放内存：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> clean</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">() {</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">remove</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">this</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)) {</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">\t\t\tthis</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">thunk</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">run</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 调用 Deallocator 的 run 方法</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">  }</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>6.3.3.1 Deallocator 的 run 方法</p><p>Deallocator 的 run 方法核心逻辑如下：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> run</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">() {</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">  unsafe</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">freeMemory</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(address);</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 释放直接内存</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">  address </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_6-3-4-显式调用-gc-的限制" tabindex="-1"><a class="header-anchor" href="#_6-3-4-显式调用-gc-的限制"><span>6.3.4 显式调用 GC 的限制</span></a></h3><p>通过 System.gc() 可以手动触发垃圾回收，但在配置了 -XX:+DisableExplicitGC 时，该方法会失效。这种配置在生产环境中常用，以避免显式 GC 引起的长时间停顿。</p><h2 id="_6-4-直接内存的管理注意事项" tabindex="-1"><a class="header-anchor" href="#_6-4-直接内存的管理注意事项"><span>6.4 直接内存的管理注意事项</span></a></h2><h3 id="_6-4-1-内存泄漏风险" tabindex="-1"><a class="header-anchor" href="#_6-4-1-内存泄漏风险"><span>6.4.1 内存泄漏风险</span></a></h3><p>直接内存不受 JVM 自动管理。分配后需要显式释放，或者通过 Cleaner 间接回收，否则容易造成内存泄漏。</p><h3 id="_6-4-2-内存大小限制" tabindex="-1"><a class="header-anchor" href="#_6-4-2-内存大小限制"><span>6.4.2 内存大小限制</span></a></h3><p>直接内存的大小由 -XX:MaxDirectMemorySize 参数限制。若未指定，默认值与堆内存大小相等。</p><h3 id="_6-4-3-调优建议" tabindex="-1"><a class="header-anchor" href="#_6-4-3-调优建议"><span>6.4.3 调优建议</span></a></h3><ul><li><p>使用 -XX:+DisableExplicitGC 禁止手动调用 GC，减少性能抖动。</p></li><li><p>定期检查直接内存使用情况，避免超出限制引发 OutOfMemoryError。</p></li></ul><h2 id="_6-5-总结" tabindex="-1"><a class="header-anchor" href="#_6-5-总结"><span>6.5 总结</span></a></h2><h3 id="_6-5-1-优点" tabindex="-1"><a class="header-anchor" href="#_6-5-1-优点"><span>6.5.1 优点</span></a></h3><ul><li><p>减少内存复制步骤，提升 I/O 性能。</p></li><li><p>适合处理大文件或高频数据传输场景。</p></li></ul><h3 id="_6-5-2-缺点" tabindex="-1"><a class="header-anchor" href="#_6-5-2-缺点"><span>6.5.2 缺点</span></a></h3><ul><li>分配和释放成本较高。</li><li>不受 GC 管理，使用不当可能导致内存泄漏。</li></ul><h3 id="_6-5-3-关键机制" tabindex="-1"><a class="header-anchor" href="#_6-5-3-关键机制"><span>6.5.3 关键机制</span></a></h3><p>通过 Unsafe 和 Cleaner 实现分配和回收，程序需额外关注内存使用和释放逻辑。</p>',48)]))}]]),p=JSON.parse('{"path":"/JVM/2.%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/2.6%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98.html","title":"6.直接内存","lang":"zh-CN","frontmatter":{"gitInclude":[]},"headers":[{"level":2,"title":"6.1 什么是直接内存？","slug":"_6-1-什么是直接内存","link":"#_6-1-什么是直接内存","children":[{"level":3,"title":"6.1.1 直接内存的定义","slug":"_6-1-1-直接内存的定义","link":"#_6-1-1-直接内存的定义","children":[]},{"level":3,"title":"6.1.2 直接内存的特点","slug":"_6-1-2-直接内存的特点","link":"#_6-1-2-直接内存的特点","children":[]}]},{"level":2,"title":"6.2 为什么要使用直接内存？","slug":"_6-2-为什么要使用直接内存","link":"#_6-2-为什么要使用直接内存","children":[{"level":3,"title":"6.2.1 文件读写的常规流程","slug":"_6-2-1-文件读写的常规流程","link":"#_6-2-1-文件读写的常规流程","children":[]},{"level":3,"title":"6.2.2 使用直接内存的改进","slug":"_6-2-2-使用直接内存的改进","link":"#_6-2-2-使用直接内存的改进","children":[]}]},{"level":2,"title":"6.3 直接内存的回收机制","slug":"_6-3-直接内存的回收机制","link":"#_6-3-直接内存的回收机制","children":[{"level":3,"title":"6.3.1 基于 Unsafe 的内存分配和释放","slug":"_6-3-1-基于-unsafe-的内存分配和释放","link":"#_6-3-1-基于-unsafe-的内存分配和释放","children":[]},{"level":3,"title":"6.3.2 ByteBuffer 的实现","slug":"_6-3-2-bytebuffer-的实现","link":"#_6-3-2-bytebuffer-的实现","children":[]},{"level":3,"title":"6.3.3 Cleaner 的作用","slug":"_6-3-3-cleaner-的作用","link":"#_6-3-3-cleaner-的作用","children":[]},{"level":3,"title":"6.3.4 显式调用 GC 的限制","slug":"_6-3-4-显式调用-gc-的限制","link":"#_6-3-4-显式调用-gc-的限制","children":[]}]},{"level":2,"title":"6.4 直接内存的管理注意事项","slug":"_6-4-直接内存的管理注意事项","link":"#_6-4-直接内存的管理注意事项","children":[{"level":3,"title":"6.4.1 内存泄漏风险","slug":"_6-4-1-内存泄漏风险","link":"#_6-4-1-内存泄漏风险","children":[]},{"level":3,"title":"6.4.2 内存大小限制","slug":"_6-4-2-内存大小限制","link":"#_6-4-2-内存大小限制","children":[]},{"level":3,"title":"6.4.3 调优建议","slug":"_6-4-3-调优建议","link":"#_6-4-3-调优建议","children":[]}]},{"level":2,"title":"6.5 总结","slug":"_6-5-总结","link":"#_6-5-总结","children":[{"level":3,"title":"6.5.1 优点","slug":"_6-5-1-优点","link":"#_6-5-1-优点","children":[]},{"level":3,"title":"6.5.2 缺点","slug":"_6-5-2-缺点","link":"#_6-5-2-缺点","children":[]},{"level":3,"title":"6.5.3 关键机制","slug":"_6-5-3-关键机制","link":"#_6-5-3-关键机制","children":[]}]}],"readingTime":{"minutes":3.05,"words":916},"filePathRelative":"JVM/2.内存结构/2.6直接内存.md","excerpt":"\\n<h2>6.1 什么是直接内存？</h2>\\n<h3>6.1.1 直接内存的定义</h3>\\n<blockquote>\\n<p>直接内存（Direct Memory）是一种特殊的内存区域，常见于 Java NIO（New Input/Output）操作中，用作数据缓冲区。</p>\\n</blockquote>\\n<figure><figcaption>不使用直接内存</figcaption></figure>\\n<figure><figcaption>使用直接内存</figcaption></figure>\\n<h3>6.1.2 直接内存的特点</h3>\\n<ul>\\n<li>\\n<p>性能优势：直接内存不需要在 Java 堆和操作系统内存之间频繁复制数据，读写性能高。</p>\\n</li>\\n<li>\\n<p>管理方式：直接内存由操作系统分配和回收，不受 JVM 垃圾回收（GC）管理。</p>\\n</li>\\n<li>\\n<p>使用代价：分配和回收的成本较高，需要谨慎管理，否则容易导致内存泄漏。</p>\\n</li>\\n</ul>"}')}}]);