"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[18993],{66262:(t,e)=>{e.A=(t,e)=>{const n=t.__vccOpts||t;for(const[t,s]of e)n[t]=s;return n}},14750:(t,e,n)=>{n.r(e),n.d(e,{comp:()=>l,data:()=>i});var s=n(20641);const a={},l=(0,n(66262).A)(a,[["render",function(t,e){return(0,s.uX)(),(0,s.CE)("div",null,e[0]||(e[0]=[(0,s.Fv)('<h1 id="📝-java-面试答题卡-completablefuture使用详解" tabindex="-1"><a class="header-anchor" href="#📝-java-面试答题卡-completablefuture使用详解"><span>📝 Java 面试答题卡：CompletableFuture使用详解</span></a></h1><h3 id="✅-1-简介" tabindex="-1"><a class="header-anchor" href="#✅-1-简介"><span><strong>✅ 1. 简介</strong></span></a></h3><ul><li>CompletableFuture 是 Java 8 引入的异步编程 API，属于 java.util.concurrent 包。</li><li>支持非阻塞、链式编程风格。</li><li>是 Future 的增强版，支持回调、组合多个任务结果、异常处理等。</li></ul><h3 id="✅-2-常用方法分类总结" tabindex="-1"><a class="header-anchor" href="#✅-2-常用方法分类总结"><span><strong>✅ 2. 常用方法分类总结</strong></span></a></h3><table><thead><tr><th><strong>类型</strong></th><th><strong>方法</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>创建异步任务</td><td>supplyAsync() / runAsync()</td><td>异步获取值 / 异步执行无返回任务</td></tr><tr><td>任务串联</td><td>thenApply() / thenAccept()</td><td>接收上一步结果并继续处理</td></tr><tr><td>组合任务</td><td>thenCombine() / allOf() / anyOf()</td><td>多个任务并发执行与组合</td></tr><tr><td>异常处理</td><td>exceptionally() / handle()</td><td>捕获并处理异常</td></tr><tr><td>阻塞获取结果</td><td>get() / join()</td><td>获取最终结果（同步）</td></tr></tbody></table><h3 id="✅-3-快速示例" tabindex="-1"><a class="header-anchor" href="#✅-3-快速示例"><span><strong>✅ 3. 快速示例</strong></span></a></h3><h4 id="🔹-3-1-创建异步任务" tabindex="-1"><a class="header-anchor" href="#🔹-3-1-创建异步任务"><span><strong>🔹 3.1 创建异步任务</strong></span></a></h4><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; {</span></span>\n<span class="line"><span>    // 模拟耗时任务</span></span>\n<span class="line"><span>    sleep(1000);</span></span>\n<span class="line"><span>    return &quot;Hello&quot;;</span></span>\n<span class="line"><span>});</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="🔹-3-2-thenapply-串行转换" tabindex="-1"><a class="header-anchor" href="#🔹-3-2-thenapply-串行转换"><span><strong>🔹 3.2 thenApply：串行转换</strong></span></a></h4><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>future.thenApply(result -&gt; result + &quot; World&quot;)</span></span>\n<span class="line"><span>      .thenAccept(System.out::println);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="🔹-3-3-thencombine-合并两个任务结果" tabindex="-1"><a class="header-anchor" href="#🔹-3-3-thencombine-合并两个任务结果"><span><strong>🔹 3.3 thenCombine：合并两个任务结果</strong></span></a></h4><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>CompletableFuture&lt;String&gt; f1 = CompletableFuture.supplyAsync(() -&gt; &quot;A&quot;);</span></span>\n<span class="line"><span>CompletableFuture&lt;String&gt; f2 = CompletableFuture.supplyAsync(() -&gt; &quot;B&quot;);</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>f1.thenCombine(f2, (a, b) -&gt; a + b)</span></span>\n<span class="line"><span>  .thenAccept(System.out::println); // 输出 AB</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="🔹-3-4-allof-等待多个任务全部完成" tabindex="-1"><a class="header-anchor" href="#🔹-3-4-allof-等待多个任务全部完成"><span><strong>🔹 3.4 allOf：等待多个任务全部完成</strong></span></a></h4><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>CompletableFuture&lt;Void&gt; all = CompletableFuture.allOf(f1, f2);</span></span>\n<span class="line"><span>all.join(); // 阻塞直到所有任务完成</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="🔹-3-5-exceptionally-处理异常" tabindex="-1"><a class="header-anchor" href="#🔹-3-5-exceptionally-处理异常"><span><strong>🔹 3.5 exceptionally：处理异常</strong></span></a></h4><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>CompletableFuture&lt;String&gt; failFuture = CompletableFuture.supplyAsync(() -&gt; {</span></span>\n<span class="line"><span>    if (true) throw new RuntimeException(&quot;出错了&quot;);</span></span>\n<span class="line"><span>    return &quot;OK&quot;;</span></span>\n<span class="line"><span>});</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>failFuture</span></span>\n<span class="line"><span>    .exceptionally(e -&gt; &quot;默认值&quot;)</span></span>\n<span class="line"><span>    .thenAccept(System.out::println); // 输出：默认值</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="✅-4-使用场景总结" tabindex="-1"><a class="header-anchor" href="#✅-4-使用场景总结"><span><strong>✅ 4. 使用场景总结</strong></span></a></h3><table><thead><tr><th><strong>场景</strong></th><th><strong>解决方案</strong></th></tr></thead><tbody><tr><td>异步执行后台任务</td><td>supplyAsync()</td></tr><tr><td>多个任务并发执行 + 等待全部完成</td><td>allOf()</td></tr><tr><td>多个任务取一个最快返回结果</td><td>anyOf()</td></tr><tr><td>异步回调处理 / 串联结果</td><td>thenApply() / thenAccept()</td></tr><tr><td>异常恢复机制</td><td>exceptionally() / handle()</td></tr></tbody></table><h3 id="✅-5-阻塞-vs-非阻塞方法区别" tabindex="-1"><a class="header-anchor" href="#✅-5-阻塞-vs-非阻塞方法区别"><span><strong>✅ 5. 阻塞 vs 非阻塞方法区别</strong></span></a></h3><table><thead><tr><th><strong>方法</strong></th><th><strong>类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>get()</td><td>阻塞</td><td>会抛异常</td></tr><tr><td>join()</td><td>阻塞</td><td>不抛检查异常（推荐）</td></tr></tbody></table><h3 id="✅-6-推荐写法-链式、非阻塞" tabindex="-1"><a class="header-anchor" href="#✅-6-推荐写法-链式、非阻塞"><span><strong>✅ 6. 推荐写法（链式、非阻塞）</strong></span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>CompletableFuture.supplyAsync(() -&gt; &quot;Step 1&quot;)</span></span>\n<span class="line"><span>    .thenApply(s -&gt; s + &quot; + Step 2&quot;)</span></span>\n<span class="line"><span>    .thenAccept(System.out::println);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="✅-7-和-future-的区别-重点" tabindex="-1"><a class="header-anchor" href="#✅-7-和-future-的区别-重点"><span><strong>✅ 7. 和 Future 的区别（重点）</strong></span></a></h3><table><thead><tr><th><strong>特性</strong></th><th>Future</th><th>CompletableFuture</th></tr></thead><tbody><tr><td>异步</td><td>有限支持</td><td>完全支持</td></tr><tr><td>阻塞</td><td>只能 get()</td><td>可非阻塞、回调</td></tr><tr><td>串联任务</td><td>❌ 不支持</td><td>✅ thenApply() 等支持链式调用</td></tr><tr><td>异常处理</td><td>❌ 不方便</td><td>✅ 支持 exceptionally()</td></tr><tr><td>多任务组合</td><td>❌ 无法处理多个任务</td><td>✅ allOf()、anyOf() 等</td></tr></tbody></table><h3 id="🎯-总结一段话答法-面试回答模板" tabindex="-1"><a class="header-anchor" href="#🎯-总结一段话答法-面试回答模板"><span><strong>🎯 总结一段话答法（面试回答模板）</strong></span></a></h3><blockquote><p>Java 中的 CompletableFuture 是对 Future 的增强，支持异步执行、任务链式组合、回调处理与异常捕获等功能，适合在多线程并发任务处理、微服务调用聚合等场景中使用。它是 Java 8 函数式编程 + 异步模型结合的重要工具，尤其适合替代传统的 Future.get() 的阻塞调用。</p></blockquote>',26)]))}]]),i=JSON.parse('{"path":"/Interview/%E9%9D%A2%E8%AF%95%E7%AD%94%E9%A2%98%E5%8D%A1/Java/CompletableFuture%20%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3.html","title":"📝 Java 面试答题卡：CompletableFuture使用详解","lang":"zh-CN","frontmatter":{"gitInclude":[]},"headers":[{"level":3,"title":"✅ 1. 简介","slug":"✅-1-简介","link":"#✅-1-简介","children":[]},{"level":3,"title":"✅ 2. 常用方法分类总结","slug":"✅-2-常用方法分类总结","link":"#✅-2-常用方法分类总结","children":[]},{"level":3,"title":"✅ 3. 快速示例","slug":"✅-3-快速示例","link":"#✅-3-快速示例","children":[]},{"level":3,"title":"✅ 4. 使用场景总结","slug":"✅-4-使用场景总结","link":"#✅-4-使用场景总结","children":[]},{"level":3,"title":"✅ 5. 阻塞 vs 非阻塞方法区别","slug":"✅-5-阻塞-vs-非阻塞方法区别","link":"#✅-5-阻塞-vs-非阻塞方法区别","children":[]},{"level":3,"title":"✅ 6. 推荐写法（链式、非阻塞）","slug":"✅-6-推荐写法-链式、非阻塞","link":"#✅-6-推荐写法-链式、非阻塞","children":[]},{"level":3,"title":"✅ 7. 和 Future 的区别（重点）","slug":"✅-7-和-future-的区别-重点","link":"#✅-7-和-future-的区别-重点","children":[]},{"level":3,"title":"🎯 总结一段话答法（面试回答模板）","slug":"🎯-总结一段话答法-面试回答模板","link":"#🎯-总结一段话答法-面试回答模板","children":[]}],"readingTime":{"minutes":2.07,"words":622},"filePathRelative":"Interview/面试答题卡/Java/CompletableFuture 使用详解.md","excerpt":"\\n<h3><strong>✅ 1. 简介</strong></h3>\\n<ul>\\n<li>CompletableFuture 是 Java 8 引入的异步编程 API，属于 java.util.concurrent 包。</li>\\n<li>支持非阻塞、链式编程风格。</li>\\n<li>是 Future 的增强版，支持回调、组合多个任务结果、异常处理等。</li>\\n</ul>\\n<h3><strong>✅ 2. 常用方法分类总结</strong></h3>\\n<table>\\n<thead>\\n<tr>\\n<th><strong>类型</strong></th>\\n<th><strong>方法</strong></th>\\n<th><strong>描述</strong></th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>创建异步任务</td>\\n<td>supplyAsync() / runAsync()</td>\\n<td>异步获取值 / 异步执行无返回任务</td>\\n</tr>\\n<tr>\\n<td>任务串联</td>\\n<td>thenApply() / thenAccept()</td>\\n<td>接收上一步结果并继续处理</td>\\n</tr>\\n<tr>\\n<td>组合任务</td>\\n<td>thenCombine() / allOf() / anyOf()</td>\\n<td>多个任务并发执行与组合</td>\\n</tr>\\n<tr>\\n<td>异常处理</td>\\n<td>exceptionally() / handle()</td>\\n<td>捕获并处理异常</td>\\n</tr>\\n<tr>\\n<td>阻塞获取结果</td>\\n<td>get() / join()</td>\\n<td>获取最终结果（同步）</td>\\n</tr>\\n</tbody>\\n</table>"}')}}]);