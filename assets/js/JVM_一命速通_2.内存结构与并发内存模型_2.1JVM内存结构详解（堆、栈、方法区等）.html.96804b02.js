"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[47819],{66262:(i,s)=>{s.A=(i,s)=>{const a=i.__vccOpts||i;for(const[i,l]of s)a[i]=l;return a}},100:(i,s,a)=>{a.r(s),a.d(s,{comp:()=>e,data:()=>h});var l=a(20641);const t={},e=(0,a(66262).A)(t,[["render",function(i,s){const a=(0,l.g2)("RouteLink");return(0,l.uX)(),(0,l.CE)("div",null,[s[2]||(s[2]=(0,l.Lk)("h1",{id:"_2-1-《jvm-内存结构详解-堆、栈、方法区等-》",tabindex:"-1"},[(0,l.Lk)("a",{class:"header-anchor",href:"#_2-1-《jvm-内存结构详解-堆、栈、方法区等-》"},[(0,l.Lk)("span",null,"2.1 《JVM 内存结构详解（堆、栈、方法区等）》")])],-1)),s[3]||(s[3]=(0,l.Lk)("hr",null,null,-1)),s[4]||(s[4]=(0,l.Lk)("h2",{id:"🧠-jvm-内存结构分区概览",tabindex:"-1"},[(0,l.Lk)("a",{class:"header-anchor",href:"#🧠-jvm-内存结构分区概览"},[(0,l.Lk)("span",null,"🧠 JVM 内存结构分区概览")])],-1)),s[5]||(s[5]=(0,l.Lk)("p",null,"JVM 在运行时会将内存划分为若干个逻辑区域，每个区域负责不同的功能，统一称为“运行时数据区”。理解这些区域是掌握 GC、线程隔离、性能调优的基础。",-1)),s[6]||(s[6]=(0,l.Lk)("hr",null,null,-1)),(0,l.Q3)(" more "),s[7]||(s[7]=(0,l.Fv)('<h2 id="📦-jvm-内存结构组成-java-8" tabindex="-1"><a class="header-anchor" href="#📦-jvm-内存结构组成-java-8"><span>📦 JVM 内存结构组成（Java 8+）</span></a></h2><table><thead><tr><th>区域</th><th>线程共享</th><th>说明</th></tr></thead><tbody><tr><td>程序计数器</td><td>否</td><td>当前线程正在执行的字节码行号指示器</td></tr><tr><td>Java 虚拟机栈</td><td>否</td><td>方法调用的栈帧、局部变量表、操作数栈等</td></tr><tr><td>本地方法栈</td><td>否</td><td>执行 native 方法所使用的栈</td></tr><tr><td>堆（Heap）</td><td>是</td><td>存放对象实例，GC 的主要区域</td></tr><tr><td>方法区（元空间 Metaspace）</td><td>是</td><td>存放类元信息、静态变量、常量池</td></tr></tbody></table><hr><h3 id="🔹-1-程序计数器" tabindex="-1"><a class="header-anchor" href="#🔹-1-程序计数器"><span>🔹 1. 程序计数器</span></a></h3><ul><li>每个线程独立拥有，线程私有</li><li>用于记录当前线程执行的 JVM 指令地址</li><li>不会发生内存溢出（OutOfMemoryError）</li></ul><hr><h3 id="🔹-2-java-虚拟机栈" tabindex="-1"><a class="header-anchor" href="#🔹-2-java-虚拟机栈"><span>🔹 2. Java 虚拟机栈</span></a></h3><ul><li>每个线程私有，生命周期与线程一致</li><li>每个方法调用都会创建一个栈帧（Stack Frame）</li><li>栈帧包括：局部变量表、操作数栈、方法返回地址等</li></ul><p>📌 报错案例：</p><ul><li><code>StackOverflowError</code>：方法递归太深</li><li><code>OutOfMemoryError</code>：栈内存过小或线程数太多</li></ul><hr><h3 id="🔹-3-本地方法栈" tabindex="-1"><a class="header-anchor" href="#🔹-3-本地方法栈"><span>🔹 3. 本地方法栈</span></a></h3><ul><li>与虚拟机栈类似，但用于执行 native 方法</li><li>使用的是 JVM 所依赖的 C 库函数栈结构</li><li>同样会抛出 <code>StackOverflowError</code>、<code>OutOfMemoryError</code></li></ul><hr><h3 id="🔹-4-堆-heap" tabindex="-1"><a class="header-anchor" href="#🔹-4-堆-heap"><span>🔹 4. 堆（Heap）</span></a></h3><ul><li>所有线程共享</li><li>JVM 中最大的一块内存区域</li><li>用于存放对象实例、数组、常量池运行时引用</li></ul><p>堆通常分为两个逻辑分区：</p><ul><li>年轻代（Young Generation） <ul><li>Eden（伊甸园）</li><li>Survivor（幸存区）</li></ul></li><li>老年代（Old Generation）</li></ul><p>📌 报错案例：</p><ul><li><code>OutOfMemoryError: Java heap space</code></li></ul><hr><h3 id="🔹-5-方法区-元空间" tabindex="-1"><a class="header-anchor" href="#🔹-5-方法区-元空间"><span>🔹 5. 方法区（元空间）</span></a></h3><ul><li>所有线程共享</li><li>存放类的结构信息（元数据）、常量、静态变量等</li><li>Java 8 后移除永久代（PermGen），改为使用元空间（Metaspace）</li><li>元空间存储在本地内存（native memory）中</li></ul><p>📌 报错案例：</p><ul><li><code>OutOfMemoryError: Metaspace</code></li></ul><hr><h2 id="🔎-对比-jvm-栈-vs-堆" tabindex="-1"><a class="header-anchor" href="#🔎-对比-jvm-栈-vs-堆"><span>🔎 对比：JVM 栈 vs 堆</span></a></h2><table><thead><tr><th>对比项</th><th>栈</th><th>堆</th></tr></thead><tbody><tr><td>管理者</td><td>JVM 自动创建/销毁</td><td>JVM 统一管理，GC 回收</td></tr><tr><td>生命周期</td><td>与线程绑定</td><td>与对象引用计数有关</td></tr><tr><td>存储内容</td><td>方法调用、局部变量</td><td>对象实例与数组</td></tr><tr><td>内存大小</td><td>通常较小</td><td>通常较大</td></tr><tr><td>常见异常</td><td>StackOverflowError</td><td>OutOfMemoryError</td></tr></tbody></table><hr><h2 id="✅-示例分析" tabindex="-1"><a class="header-anchor" href="#✅-示例分析"><span>✅ 示例分析</span></a></h2><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> MemoryTest</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    static</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> String</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> staticStr </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;JVM&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 方法区</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> main</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[] </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">args</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> a</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;            </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 栈（局部变量）</span></span>\n<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        String</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> s</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> String</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;Heap&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">); </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 堆</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(staticStr </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> s);</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="📌-面试重点问题" tabindex="-1"><a class="header-anchor" href="#📌-面试重点问题"><span>📌 面试重点问题</span></a></h2><ol><li>JVM 内存结构有哪些区域？哪些是线程共享的？</li><li>JVM 为什么要将堆划分为新生代和老年代？</li><li>PermGen 和 Metaspace 有什么区别？</li><li>栈溢出和堆溢出有什么区别？</li></ol><hr><h2 id="📝-小结" tabindex="-1"><a class="header-anchor" href="#📝-小结"><span>📝 小结</span></a></h2><ul><li>JVM 内存结构清晰划分了多种逻辑区域</li><li>理解这些区域有助于深入掌握 GC 机制与性能调优</li><li>掌握各区域的作用与异常类型，是 Java 面试高频考点</li></ul><hr>',38)),(0,l.Lk)("p",null,[s[1]||(s[1]=(0,l.eW)("👉 下一篇推荐阅读：")),(0,l.bF)(a,{to:"/JVM/%E4%B8%80%E5%91%BD%E9%80%9F%E9%80%9A/2.%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E4%B8%8E%E5%B9%B6%E5%8F%91%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/2.2Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%88JMM%EF%BC%89%E4%B8%8Ehappens-before%20%E5%8E%9F%E5%88%99.html"},{default:(0,l.k6)((()=>s[0]||(s[0]=[(0,l.eW)("2.2 Java 内存模型 JMM 与 happens-before 原则")]))),_:1})])])}]]),h=JSON.parse('{"path":"/JVM/%E4%B8%80%E5%91%BD%E9%80%9F%E9%80%9A/2.%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E4%B8%8E%E5%B9%B6%E5%8F%91%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/2.1JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3%EF%BC%88%E5%A0%86%E3%80%81%E6%A0%88%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA%E7%AD%89%EF%BC%89.html","title":"2.1 JVM 内存结构详解（堆、栈、方法区等）","lang":"zh-CN","frontmatter":{"title":"2.1 JVM 内存结构详解（堆、栈、方法区等）","icon":"fa-solid fa-memory","date":"2025-07-10T00:00:00.000Z","author":"JeanHu","category":["JVM"],"tag":["JVM","内存结构","堆","栈","方法区"],"summary":"本文详细介绍 JVM 内存结构，包括堆、栈、方法区、程序计数器等组成部分，解析各区域的作用与管理机制，帮助读者全面掌握 JVM 内存模型。","gitInclude":[]},"headers":[{"level":2,"title":"🧠 JVM 内存结构分区概览","slug":"🧠-jvm-内存结构分区概览","link":"#🧠-jvm-内存结构分区概览","children":[]},{"level":2,"title":"📦 JVM 内存结构组成（Java 8+）","slug":"📦-jvm-内存结构组成-java-8","link":"#📦-jvm-内存结构组成-java-8","children":[{"level":3,"title":"🔹 1. 程序计数器","slug":"🔹-1-程序计数器","link":"#🔹-1-程序计数器","children":[]},{"level":3,"title":"🔹 2. Java 虚拟机栈","slug":"🔹-2-java-虚拟机栈","link":"#🔹-2-java-虚拟机栈","children":[]},{"level":3,"title":"🔹 3. 本地方法栈","slug":"🔹-3-本地方法栈","link":"#🔹-3-本地方法栈","children":[]},{"level":3,"title":"🔹 4. 堆（Heap）","slug":"🔹-4-堆-heap","link":"#🔹-4-堆-heap","children":[]},{"level":3,"title":"🔹 5. 方法区（元空间）","slug":"🔹-5-方法区-元空间","link":"#🔹-5-方法区-元空间","children":[]}]},{"level":2,"title":"🔎 对比：JVM 栈 vs 堆","slug":"🔎-对比-jvm-栈-vs-堆","link":"#🔎-对比-jvm-栈-vs-堆","children":[]},{"level":2,"title":"✅ 示例分析","slug":"✅-示例分析","link":"#✅-示例分析","children":[]},{"level":2,"title":"📌 面试重点问题","slug":"📌-面试重点问题","link":"#📌-面试重点问题","children":[]},{"level":2,"title":"📝 小结","slug":"📝-小结","link":"#📝-小结","children":[]}],"readingTime":{"minutes":2.95,"words":886},"filePathRelative":"JVM/一命速通/2.内存结构与并发内存模型/2.1JVM内存结构详解（堆、栈、方法区等）.md","localizedDate":"2025年7月10日","excerpt":"\\n<hr>\\n<h2>🧠 JVM 内存结构分区概览</h2>\\n<p>JVM 在运行时会将内存划分为若干个逻辑区域，每个区域负责不同的功能，统一称为“运行时数据区”。理解这些区域是掌握 GC、线程隔离、性能调优的基础。</p>\\n<hr>\\n"}')}}]);