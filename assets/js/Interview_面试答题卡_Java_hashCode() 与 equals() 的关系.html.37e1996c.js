"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[82942],{66262:(s,n)=>{n.A=(s,n)=>{const a=s.__vccOpts||s;for(const[s,e]of n)a[s]=e;return a}},25436:(s,n,a)=>{a.r(n),a.d(n,{comp:()=>i,data:()=>t});var e=a(20641);const l={},i=(0,a(66262).A)(l,[["render",function(s,n){return(0,e.uX)(),(0,e.CE)("div",null,n[0]||(n[0]=[(0,e.Fv)('<h1 id="☕-java面试答题卡-hashcode-与-equals-的关系" tabindex="-1"><a class="header-anchor" href="#☕-java面试答题卡-hashcode-与-equals-的关系"><span>☕ Java面试答题卡：hashCode() 与 equals() 的关系？</span></a></h1><h2 id="❓面试题目" tabindex="-1"><a class="header-anchor" href="#❓面试题目"><span>❓面试题目</span></a></h2><blockquote><p><strong>在 Java 中，hashCode() 方法与 equals() 方法有什么关系？为什么必须同时重写？</strong></p></blockquote><h3 id="✅-答题要点" tabindex="-1"><a class="header-anchor" href="#✅-答题要点"><span><strong>✅ 答题要点</strong></span></a></h3><table><thead><tr><th><strong>关键点</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>逻辑含义</td><td>equals() 用来判断<strong>两个对象的“逻辑相等”</strong>；hashCode() 用来计算<strong>对象在散列表中的桶位置</strong>。</td></tr><tr><td>合同（Contract）</td><td><strong>若 a.equals(b) 为 true，则 a.hashCode() == b.hashCode() 必须成立</strong>。反之不要求：false 的对象可以具有相同的哈希值（允许碰撞）。</td></tr><tr><td>适用场景</td><td>所有基于哈希结构的容器（HashMap、HashSet、Hashtable、ConcurrentHashMap 等）都会<strong>先比 hashCode，再根据 equals 判定真正相等</strong>。</td></tr><tr><td>同步重写</td><td>只重写其一会破坏合同，引发集合语义错误或数据丢失。</td></tr></tbody></table><h3 id="_1️⃣-合同-contract-细节" tabindex="-1"><a class="header-anchor" href="#_1️⃣-合同-contract-细节"><span><strong>1️⃣ 合同（contract）细节</strong></span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>1. 对称性：x.equals(y) ⇔ y.equals(x)</span></span>\n<span class="line"><span>2. 传递性：x=y 且 y=z ⇒ x=z</span></span>\n<span class="line"><span>3. 自反性：x.equals(x) 必须为 true</span></span>\n<span class="line"><span>4. 一致性：多次比较结果一致</span></span>\n<span class="line"><span>5. 与 hashCode 约定：</span></span>\n<span class="line"><span>   - 若 x.equals(y) 为 true ⇒ x.hashCode() == y.hashCode()</span></span>\n<span class="line"><span>   - 若 x.equals(y) 为 false ⇒ 不做强制要求</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2️⃣-违反合同的后果示例" tabindex="-1"><a class="header-anchor" href="#_2️⃣-违反合同的后果示例"><span><strong>2️⃣ 违反合同的后果示例</strong></span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>class BadPoint {</span></span>\n<span class="line"><span>    int x, y;</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    // 仅重写 equals，忘记重写 hashCode</span></span>\n<span class="line"><span>    @Override</span></span>\n<span class="line"><span>    public boolean equals(Object obj) {</span></span>\n<span class="line"><span>        if (this == obj) return true;</span></span>\n<span class="line"><span>        if (obj instanceof BadPoint p) {</span></span>\n<span class="line"><span>            return x == p.x &amp;&amp; y == p.y;</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span>        return false;</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>}</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>BadPoint p1 = new BadPoint(1, 2);</span></span>\n<span class="line"><span>BadPoint p2 = new BadPoint(1, 2);</span></span>\n<span class="line"><span>Set&lt;BadPoint&gt; set = new HashSet&lt;&gt;();</span></span>\n<span class="line"><span>set.add(p1);</span></span>\n<span class="line"><span>set.add(p2);           // 逻辑上相等，却被当成不同元素存两份</span></span>\n<span class="line"><span>System.out.println(set.size()); // 2（错误）</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>原因</strong>：p1 与 p2 的 hashCode() 不一致，各落入不同桶，equals() 来不及判重。</p><h3 id="_3️⃣-正确的同步重写示例" tabindex="-1"><a class="header-anchor" href="#_3️⃣-正确的同步重写示例"><span><strong>3️⃣ 正确的同步重写示例</strong></span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>class Point {</span></span>\n<span class="line"><span>    int x, y;</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    @Override</span></span>\n<span class="line"><span>    public boolean equals(Object obj) {</span></span>\n<span class="line"><span>        if (this == obj) return true;</span></span>\n<span class="line"><span>        if (obj instanceof Point p) {</span></span>\n<span class="line"><span>            return x == p.x &amp;&amp; y == p.y;</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span>        return false;</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    @Override</span></span>\n<span class="line"><span>    public int hashCode() {</span></span>\n<span class="line"><span>        return Objects.hash(x, y); // JDK 提供的简洁工具</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><table><thead><tr><th><strong>步骤</strong></th><th><strong>容器内部逻辑</strong></th></tr></thead><tbody><tr><td>① 计算 hashCode()</td><td>找到桶（数组索引）</td></tr><tr><td>② 桶内链表 / 红黑树</td><td>再用 equals() 精确比较</td></tr></tbody></table><h3 id="_4️⃣-实战建议" tabindex="-1"><a class="header-anchor" href="#_4️⃣-实战建议"><span><strong>4️⃣ 实战建议</strong></span></a></h3><ol><li><strong>全部或全不</strong><ul><li>若类打算放进哈希容器 → 同时重写 equals &amp; hashCode。</li><li>若保持继承自 Object 的行为 → 两者都别动。</li></ul></li><li><strong>使用 IDE / Lombok</strong><ul><li>大部分 IDE 能自动生成；@EqualsAndHashCode 可减少手写错误。</li></ul></li><li><strong>避免可变键</strong><ul><li>作为 HashMap 键的对象字段应尽量不可变；修改后散列位置会失效。</li></ul></li><li><strong>重写 toString()</strong>（加分） <ul><li>方便调试，配合 equals/hashCode 更完整。</li></ul></li></ol><h3 id="☑️-记忆口诀" tabindex="-1"><a class="header-anchor" href="#☑️-记忆口诀"><span><strong>☑️ 记忆口诀</strong></span></a></h3><blockquote><p>“<strong>相等必同码，不同可撞码</strong>；重写要成对，哈希先分家，equals 再相认。”</p></blockquote>',17)]))}]]),t=JSON.parse('{"path":"/Interview/%E9%9D%A2%E8%AF%95%E7%AD%94%E9%A2%98%E5%8D%A1/Java/hashCode()%20%E4%B8%8E%20equals()%20%E7%9A%84%E5%85%B3%E7%B3%BB.html","title":"☕ Java面试答题卡：hashCode() 与 equals() 的关系？","lang":"zh-CN","frontmatter":{"gitInclude":[]},"headers":[{"level":2,"title":"❓面试题目","slug":"❓面试题目","link":"#❓面试题目","children":[{"level":3,"title":"✅ 答题要点","slug":"✅-答题要点","link":"#✅-答题要点","children":[]},{"level":3,"title":"1️⃣ 合同（contract）细节","slug":"_1️⃣-合同-contract-细节","link":"#_1️⃣-合同-contract-细节","children":[]},{"level":3,"title":"2️⃣ 违反合同的后果示例","slug":"_2️⃣-违反合同的后果示例","link":"#_2️⃣-违反合同的后果示例","children":[]},{"level":3,"title":"3️⃣ 正确的同步重写示例","slug":"_3️⃣-正确的同步重写示例","link":"#_3️⃣-正确的同步重写示例","children":[]},{"level":3,"title":"4️⃣ 实战建议","slug":"_4️⃣-实战建议","link":"#_4️⃣-实战建议","children":[]},{"level":3,"title":"☑️ 记忆口诀","slug":"☑️-记忆口诀","link":"#☑️-记忆口诀","children":[]}]}],"readingTime":{"minutes":1.98,"words":595},"filePathRelative":"Interview/面试答题卡/Java/hashCode() 与 equals() 的关系.md","excerpt":"\\n<h2>❓面试题目</h2>\\n<blockquote>\\n<p><strong>在 Java 中，hashCode() 方法与 equals() 方法有什么关系？为什么必须同时重写？</strong></p>\\n</blockquote>\\n<h3><strong>✅ 答题要点</strong></h3>\\n<table>\\n<thead>\\n<tr>\\n<th><strong>关键点</strong></th>\\n<th><strong>说明</strong></th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>逻辑含义</td>\\n<td>equals() 用来判断<strong>两个对象的“逻辑相等”</strong>；hashCode() 用来计算<strong>对象在散列表中的桶位置</strong>。</td>\\n</tr>\\n<tr>\\n<td>合同（Contract）</td>\\n<td><strong>若 a.equals(b) 为 true，则 a.hashCode() == b.hashCode() 必须成立</strong>。反之不要求：false 的对象可以具有相同的哈希值（允许碰撞）。</td>\\n</tr>\\n<tr>\\n<td>适用场景</td>\\n<td>所有基于哈希结构的容器（HashMap、HashSet、Hashtable、ConcurrentHashMap 等）都会<strong>先比 hashCode，再根据 equals 判定真正相等</strong>。</td>\\n</tr>\\n<tr>\\n<td>同步重写</td>\\n<td>只重写其一会破坏合同，引发集合语义错误或数据丢失。</td>\\n</tr>\\n</tbody>\\n</table>"}')}}]);