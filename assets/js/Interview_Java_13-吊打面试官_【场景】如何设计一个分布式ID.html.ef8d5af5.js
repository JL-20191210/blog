"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[18678],{66262:(l,i)=>{i.A=(l,i)=>{const e=l.__vccOpts||l;for(const[l,n]of i)e[l]=n;return e}},97466:(l,i,e)=>{e.r(i),e.d(i,{comp:()=>I,data:()=>o});var n=e(20641);const a=e.p+"assets/img/640-176347422629232.b235e891.webp",D={},I=(0,e(66262).A)(D,[["render",function(l,i){return(0,n.uX)(),(0,n.CE)("div",null,i[0]||(i[0]=[(0,n.Fv)('<h1 id="如何设计一个分布式id" tabindex="-1"><a class="header-anchor" href="#如何设计一个分布式id"><span>如何设计一个分布式ID</span></a></h1><p>分布式系统中设计分布式 ID 对于确保订单、用户或记录等实体的唯一性至关重要。</p><figure><img src="'+a+'" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><h2 id="_01-分布式-id-的设计需求" tabindex="-1"><a class="header-anchor" href="#_01-分布式-id-的设计需求"><span><strong>01 分布式 ID 的设计需求</strong></span></a></h2><ul><li>唯一性：ID 必须在所有服务或系统中全局唯一。</li><li>可扩展性：系统应能够在高负载下以高吞吐量生成 ID。</li><li>排序性：在某些用例中，ID 需要是有序或大致按时间排序的（例如用于排序）。</li><li>避免碰撞：两个 ID 相同的概率应当极小。</li><li>去中心化：ID 的生成应不依赖单一的生成器，避免单点故障。</li><li>可用性：即使在网络分区时，ID 生成系统也应能正常工作。</li><li>紧凑性：ID 的格式应在存储时高效，特别是在数据库或日志中。</li><li>透明性：有时 ID 需要嵌入元数据（如时间戳或机器 ID ）以便调试或追踪。</li></ul><h2 id="_02-常见的分布式-id-解决方案" tabindex="-1"><a class="header-anchor" href="#_02-常见的分布式-id-解决方案"><span><strong>02 常见的分布式 ID 解决方案</strong></span></a></h2><ol><li>UUID（通用唯一标识符）</li></ol><ul><li>版本1：基于时间戳，包含时间戳和节点特定的信息（如 MAC 地址）。</li><li>版本4：随机生成，提供高度的唯一性。</li><li>优点：简单，广泛应用于多种编程语言中。</li><li>缺点：无序，较大（128位），不能轻易按生成时间排序。</li><li>适用场景：适用于排序要求不高的分布式系统，如对象存储或用户 ID。</li></ul><ol><li>Snowflake 算法（Twitter）</li></ol><p>一个 64 位的 ID，包含以下部分：</p><ul><li>41 位用于时间戳（从某个自定义的纪元开始的毫秒数）。</li><li>10 位用于机器 ID（数据中心或节点 ID）。</li><li>12 位用于序列号（确保同一毫秒内生成的多个 ID 是唯一的）。</li><li>优点：时间排序，具有良好的扩展性，支持高吞吐量（每个节点每毫秒最多生成 4096 个 ID）。</li><li>缺点：需要节点间时间同步。</li><li>适用场景：常用于分布式系统，如微服务或订单管理系统。</li></ul><ol><li>数据库序列</li></ol><p>数据库系统通常提供自增 ID 生成（例如 MySQL 的 AUTO_INCREMENT 或 PostgreSQL 的 SERIAL）。</p><ul><li>优点：简单且可靠，适用于小型集中式系统。</li><li>缺点：无法很好地扩展到分布式系统，会引入单点故障。</li><li>适用场景：适用于无需高扩展性的简单应用。</li></ul><ol><li>KSUID（K-可排序的唯一标识符）</li></ol><p>128 位 ID，嵌入时间戳和随机部分。</p><ul><li>优点：ID 按生成时间可排序（字典序），比 UUID 更小。</li><li>缺点：稍微比 UUID 复杂，空间效率不如 Snowflake。</li><li>适用场景：适用于需要字典序排序和较长生命周期的场景，如日志聚合系统。</li></ul><ol><li>Redis / MongoDB 的序列生成器</li></ol><p>像 Redis 或 MongoDB 这样的系统可以通过原子操作充当集中式的 ID 生成器。</p><ul><li>优点：提供集中控制，并且具有高吞吐量。</li><li>缺点：存在单点故障，依赖 Redis/MongoDB 的可用性。</li><li>适用场景：适用于分布式系统，中央节点可以在没有高可用性要求的情况下生成 ID。</li></ul><h2 id="_03-选择解决方案的考虑因素" tabindex="-1"><a class="header-anchor" href="#_03-选择解决方案的考虑因素"><span><strong>03 选择解决方案的考虑因素</strong></span></a></h2><ul><li>吞吐量需求：如果系统需要每秒生成数百万个 ID，Snowflake 或 Redis-based 方案比 UUID 更合适。</li><li>有序还是随机：如果 ID 需要按时间排序，可以考虑 Snowflake、KSUID。</li><li>存储限制：与 KSUID 相比，Snowflake ID 更小，如果存储大小至关重要，可以选择更紧凑的格式。</li><li>元数据：如果需要在ID中包含元数据，Snowflake ID 或自定义哈希方案可以编码时间戳或机器 ID 等信息。</li></ul><p>每种解决方案适合不同的用例，具体选择取决于扩展性、排序和存储大小等因素。Snowflake 和 UUID 是现代分布式系统中最常采用的方案。</p>',23)]))}]]),o=JSON.parse('{"path":"/Interview/Java/13-%E5%90%8A%E6%89%93%E9%9D%A2%E8%AF%95%E5%AE%98/%E3%80%90%E5%9C%BA%E6%99%AF%E3%80%91%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E5%88%86%E5%B8%83%E5%BC%8FID.html","title":"如何设计一个分布式ID","lang":"zh-CN","frontmatter":{"gitInclude":[]},"headers":[{"level":2,"title":"01 分布式 ID 的设计需求","slug":"_01-分布式-id-的设计需求","link":"#_01-分布式-id-的设计需求","children":[]},{"level":2,"title":"02 常见的分布式 ID 解决方案","slug":"_02-常见的分布式-id-解决方案","link":"#_02-常见的分布式-id-解决方案","children":[]},{"level":2,"title":"03 选择解决方案的考虑因素","slug":"_03-选择解决方案的考虑因素","link":"#_03-选择解决方案的考虑因素","children":[]}],"readingTime":{"minutes":3.27,"words":980},"filePathRelative":"Interview/Java/13-吊打面试官/【场景】如何设计一个分布式ID.md","excerpt":"\\n<p>分布式系统中设计分布式 ID 对于确保订单、用户或记录等实体的唯一性至关重要。</p>\\n<figure><figcaption>图片</figcaption></figure>\\n<h2><strong>01 分布式 ID 的设计需求</strong></h2>\\n<ul>\\n<li>唯一性：ID 必须在所有服务或系统中全局唯一。</li>\\n<li>可扩展性：系统应能够在高负载下以高吞吐量生成 ID。</li>\\n<li>排序性：在某些用例中，ID 需要是有序或大致按时间排序的（例如用于排序）。</li>\\n<li>避免碰撞：两个 ID 相同的概率应当极小。</li>\\n<li>去中心化：ID 的生成应不依赖单一的生成器，避免单点故障。</li>\\n<li>可用性：即使在网络分区时，ID 生成系统也应能正常工作。</li>\\n<li>紧凑性：ID 的格式应在存储时高效，特别是在数据库或日志中。</li>\\n<li>透明性：有时 ID 需要嵌入元数据（如时间戳或机器 ID ）以便调试或追踪。</li>\\n</ul>"}')}}]);