"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[73952],{66262:(l,r)=>{r.A=(l,r)=>{const e=l.__vccOpts||l;for(const[l,o]of r)e[l]=o;return e}},33178:(l,r,e)=>{e.r(r),e.d(r,{comp:()=>n,data:()=>t});var o=e(20641);const a={},n=(0,e(66262).A)(a,[["render",function(l,r){return(0,o.uX)(),(0,o.CE)("div",null,[r[0]||(r[0]=(0,o.Lk)("h1",{id:"gc类型",tabindex:"-1"},[(0,o.Lk)("a",{class:"header-anchor",href:"#gc类型"},[(0,o.Lk)("span",null,"GC类型")])],-1)),r[1]||(r[1]=(0,o.Lk)("blockquote",null,[(0,o.Lk)("p",null,"在Java虚拟机（JVM）中，垃圾回收（GC）器负责自动管理内存，通过回收不再使用的对象来释放内存空间。JVM 提供了多种垃圾回收器，每种回收器适用于不同的应用场景，它们各自有不同的优点和缺点。以下是JVM中常见的垃圾回收器：")],-1)),(0,o.Q3)(" more "),r[2]||(r[2]=(0,o.Fv)('<h3 id="_1-serial-garbage-collector-串行垃圾回收器" tabindex="-1"><a class="header-anchor" href="#_1-serial-garbage-collector-串行垃圾回收器"><span>1. <strong>Serial Garbage Collector（串行垃圾回收器）</strong></span></a></h3><ul><li><strong>特点</strong>：Serial GC是最基本的垃圾回收器，它使用单线程进行垃圾回收。适合单核或低内存环境。</li><li><strong>工作方式</strong>：在回收过程中，所有的GC工作（包括标记、清理、压缩等）都在一个线程中执行，这会导致应用的停顿时间（Stop-the-World事件）较长。</li><li><strong>适用场景</strong>：适用于单核处理器或内存较小的系统，或者应用负载较低的场景。</li><li><strong>JVM参数</strong>：<code>-XX:+UseSerialGC</code></li></ul><h3 id="_2-parallel-garbage-collector-并行垃圾回收器" tabindex="-1"><a class="header-anchor" href="#_2-parallel-garbage-collector-并行垃圾回收器"><span>2. <strong>Parallel Garbage Collector（并行垃圾回收器）</strong></span></a></h3><ul><li><strong>特点</strong>：Parallel GC（又称吞吐量优先的垃圾回收器）使用多个线程并行进行垃圾回收，适合多核CPU和负载较高的应用。</li><li><strong>工作方式</strong>：与Serial GC不同，Parallel GC在垃圾回收的过程中使用多个线程并行处理各个阶段（如标记、清理、压缩）。因此，它能显著减少GC停顿时间，并提高吞吐量（吞吐量是指应用执行时间与总时间的比例）。</li><li><strong>适用场景</strong>：适合高吞吐量应用，尤其是多核处理器和负载较高的环境。</li><li><strong>JVM参数</strong>：<code>-XX:+UseParallelGC</code></li></ul><h3 id="_3-concurrent-mark-sweep-garbage-collector-cms-垃圾回收器" tabindex="-1"><a class="header-anchor" href="#_3-concurrent-mark-sweep-garbage-collector-cms-垃圾回收器"><span>3. <strong>Concurrent Mark-Sweep Garbage Collector（CMS，垃圾回收器）</strong></span></a></h3><ul><li><p><strong>特点</strong>：CMS回收器的主要目标是最小化GC停顿时间，适合低延迟要求的应用。</p></li><li><p><strong>工作方式</strong>：</p><ul><li><strong>初始标记</strong>：从根对象开始标记活动对象。</li><li><strong>并发标记</strong>：标记所有可达的对象。与应用线程并行进行，不会暂停应用。</li><li><strong>重新标记</strong>：修正并发标记期间的变更。</li><li><strong>并发清理</strong>：在应用线程运行时，进行垃圾对象的回收。</li></ul><p>CMS回收器的关键优势是大部分标记和清理工作是并发进行的，能够减少应用的停顿时间。</p></li><li><p><strong>缺点</strong>：CMS在长时间运行后可能会出现“碎片”问题（老年代空间不足）。CMS也被新的垃圾回收器所替代。</p></li><li><p><strong>适用场景</strong>：适用于低延迟、高并发的应用，特别是需要较小停顿时间的服务。</p></li><li><p><strong>JVM参数</strong>：<code>-XX:+UseConcMarkSweepGC</code></p></li></ul><h3 id="_4-g1-garbage-collector-g1垃圾回收器" tabindex="-1"><a class="header-anchor" href="#_4-g1-garbage-collector-g1垃圾回收器"><span>4. <strong>G1 Garbage Collector（G1垃圾回收器）</strong></span></a></h3><ul><li><p><strong>特点</strong>：G1 GC 是一种面向服务端应用的垃圾回收器，旨在提供可预测的停顿时间和高吞吐量。G1适合大型堆内存、低延迟的需求。</p></li><li><p><strong>工作方式</strong>：G1将堆划分为多个区域（Region），它会根据当前内存的使用情况来选择需要回收的区域。G1 GC 通过“并行”和“并发”操作来进行标记、清理和压缩，并且能通过预测来控制每次垃圾回收的停顿时间。</p><ul><li><strong>初始标记</strong>：标记根对象。</li><li><strong>并发标记</strong>：标记所有活跃的对象。</li><li><strong>最终标记</strong>：修正标记过程中的变动。</li><li><strong>垃圾回收</strong>：清理和压缩堆中的垃圾。</li></ul></li><li><p><strong>优点</strong>：具有较小的停顿时间，能够较好地平衡吞吐量和响应时间。适合大型应用，尤其是对停顿时间有要求的应用。</p></li><li><p><strong>缺点</strong>：G1的吞吐量稍低于Parallel GC，但相对来说具有更好的停顿控制能力。</p></li><li><p><strong>适用场景</strong>：大堆内存的应用，高并发且对延迟有要求的系统（如Web应用、在线交易等）。</p></li><li><p><strong>JVM参数</strong>：<code>-XX:+UseG1GC</code></p></li></ul><h3 id="_5-z-garbage-collector-zgc-z垃圾回收器" tabindex="-1"><a class="header-anchor" href="#_5-z-garbage-collector-zgc-z垃圾回收器"><span>5. <strong>Z Garbage Collector（ZGC，Z垃圾回收器）</strong></span></a></h3><ul><li><p><strong>特点</strong>：ZGC 是一种低延迟、高吞吐量的垃圾回收器，它设计时注重延迟的控制，可以在大规模内存（多TB）环境下运行，并且在回收时停顿时间非常短，通常可以控制在几毫秒以内。</p></li><li><p><strong>工作方式</strong>：ZGC的关键特性之一是它采用了“分区回收”和“并发回收”方式，能够实现低延迟的垃圾回收，减少了长时间的Stop-the-World停顿。它采用了类似分代的内存管理方式，并利用了<code>LoadBarrier</code>技术来避免大量的内存访问阻塞。</p></li><li><p><strong>优点</strong>：非常低的停顿时间，适合大内存、大堆的应用。</p></li><li><p><strong>缺点</strong>：相对于其他GC，ZGC的内存使用较高，但在大内存环境下，其性能表现是最优的。</p></li><li><p><strong>适用场景</strong>：大内存、大规模系统，要求极低延迟和高吞吐量的应用，如大数据处理、机器学习等。</p></li><li><p><strong>JVM参数</strong>：<code>-XX:+UseZGC</code></p></li></ul><h3 id="_6-shenandoah-garbage-collector-shenandoah垃圾回收器" tabindex="-1"><a class="header-anchor" href="#_6-shenandoah-garbage-collector-shenandoah垃圾回收器"><span>6. <strong>Shenandoah Garbage Collector（Shenandoah垃圾回收器）</strong></span></a></h3><ul><li><strong>特点</strong>：Shenandoah GC 主要用于低延迟的场景，设计目标是最大限度地减少停顿时间，尤其是大堆内存的应用。</li><li><strong>工作方式</strong>：Shenandoah GC 通过并行化几乎所有的垃圾回收阶段（包括标记、清理等）来减少停顿时间。它通过一个并发标记过程在应用运行期间进行垃圾回收，大大减少了应用的停顿时间。</li><li><strong>优点</strong>：与ZGC类似，Shenandoah GC 也是为了低延迟而设计的，能够在低停顿的情况下进行垃圾回收。</li><li><strong>缺点</strong>：相对来说，它的吞吐量可能不如Parallel GC，但它是低延迟应用的理想选择。</li><li><strong>适用场景</strong>：需要低停顿时间的应用，尤其是大内存和对延迟敏感的应用。</li><li><strong>JVM参数</strong>：<code>-XX:+UseShenandoahGC</code></li></ul><hr><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h3><p>JVM中的垃圾回收器根据应用场景、性能需求和系统资源的不同，可以选择不同的回收器。主要回收器包括：</p><ul><li><strong>Serial GC</strong>：适用于小型、单核系统。</li><li><strong>Parallel GC</strong>：适用于高吞吐量需求的多核系统。</li><li><strong>CMS GC</strong>：适用于低延迟、高并发的场景。</li><li><strong>G1 GC</strong>：适用于大型堆内存，要求较小停顿时间的场景。</li><li><strong>ZGC和Shenandoah GC</strong>：适用于需要超低停顿时间的大内存应用。</li></ul><p>选择合适的垃圾回收器可以有效地提升应用的性能和稳定性。</p>',17))])}]]),t=JSON.parse('{"path":"/JVM/GC%E7%B1%BB%E5%9E%8B.html","title":"GC类型","lang":"zh-CN","frontmatter":{"icon":"fa-solid fa-microchip","date":"2024-12-17T00:00:00.000Z","category":["JVM"],"tag":["总结"],"gitInclude":[]},"headers":[{"level":3,"title":"1. Serial Garbage Collector（串行垃圾回收器）","slug":"_1-serial-garbage-collector-串行垃圾回收器","link":"#_1-serial-garbage-collector-串行垃圾回收器","children":[]},{"level":3,"title":"2. Parallel Garbage Collector（并行垃圾回收器）","slug":"_2-parallel-garbage-collector-并行垃圾回收器","link":"#_2-parallel-garbage-collector-并行垃圾回收器","children":[]},{"level":3,"title":"3. Concurrent Mark-Sweep Garbage Collector（CMS，垃圾回收器）","slug":"_3-concurrent-mark-sweep-garbage-collector-cms-垃圾回收器","link":"#_3-concurrent-mark-sweep-garbage-collector-cms-垃圾回收器","children":[]},{"level":3,"title":"4. G1 Garbage Collector（G1垃圾回收器）","slug":"_4-g1-garbage-collector-g1垃圾回收器","link":"#_4-g1-garbage-collector-g1垃圾回收器","children":[]},{"level":3,"title":"5. Z Garbage Collector（ZGC，Z垃圾回收器）","slug":"_5-z-garbage-collector-zgc-z垃圾回收器","link":"#_5-z-garbage-collector-zgc-z垃圾回收器","children":[]},{"level":3,"title":"6. Shenandoah Garbage Collector（Shenandoah垃圾回收器）","slug":"_6-shenandoah-garbage-collector-shenandoah垃圾回收器","link":"#_6-shenandoah-garbage-collector-shenandoah垃圾回收器","children":[]},{"level":3,"title":"总结","slug":"总结","link":"#总结","children":[]}],"readingTime":{"minutes":5.3,"words":1591},"filePathRelative":"JVM/GC类型.md","localizedDate":"2024年12月17日","excerpt":"\\n<blockquote>\\n<p>在Java虚拟机（JVM）中，垃圾回收（GC）器负责自动管理内存，通过回收不再使用的对象来释放内存空间。JVM 提供了多种垃圾回收器，每种回收器适用于不同的应用场景，它们各自有不同的优点和缺点。以下是JVM中常见的垃圾回收器：</p>\\n</blockquote>\\n"}')}}]);