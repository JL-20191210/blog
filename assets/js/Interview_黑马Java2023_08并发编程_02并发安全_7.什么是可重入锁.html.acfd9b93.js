"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[1921],{66262:(i,s)=>{s.A=(i,s)=>{const a=i.__vccOpts||i;for(const[i,n]of s)a[i]=n;return a}},92589:(i,s,a)=>{a.r(s),a.d(s,{comp:()=>e,data:()=>t});var n=a(20641);const l={},e=(0,a(66262).A)(l,[["render",function(i,s){return(0,n.uX)(),(0,n.CE)("div",null,s[0]||(s[0]=[(0,n.Fv)('<h1 id="_7-什么是可重入锁" tabindex="-1"><a class="header-anchor" href="#_7-什么是可重入锁"><span>7.什么是可重入锁？</span></a></h1><div class="hint-container important"><p class="hint-container-title">重要</p><p><strong>可重入锁（Reentrant Lock）</strong> 是一种允许同一个线程多次获取锁的锁机制，也就是说，当一个线程已经持有某个锁时，它可以再次获得该锁，而不会发生死锁。</p></div><h3 id="详细解释" tabindex="-1"><a class="header-anchor" href="#详细解释"><span>详细解释：</span></a></h3><ol><li><p><strong>可重入性</strong>：可重入锁的最关键特性是，如果一个线程已经获得了锁，它可以在同一线程内再次获取该锁。例如，线程可以进入一个已经同步的代码块或方法，继续执行其他同步代码，而不需要等待锁的释放。</p></li><li><p><strong>避免死锁</strong>：可重入锁防止了一个线程因无法再次获取锁而陷入死锁。没有可重入锁时，如果一个线程试图进入自己已经持有的锁所保护的代码块，将会造成死锁。可重入锁通过允许线程重新获得锁来避免这个问题。</p></li><li><p><strong>工作原理</strong>：每个锁都有一个计数器，表示锁被获得的次数。当一个线程第一次请求该锁时，计数器被设为1。如果同一个线程再次请求该锁，计数器的值会递增。每次释放锁时，计数器会递减，直到计数器为0，表示锁被完全释放。</p></li></ol><h3 id="示例-java中的-reentrantlock-和-synchronized" tabindex="-1"><a class="header-anchor" href="#示例-java中的-reentrantlock-和-synchronized"><span>示例（Java中的 <code>ReentrantLock</code> 和 <code>synchronized</code>）：</span></a></h3><h4 id="_1-java中的-reentrantlock-示例" tabindex="-1"><a class="header-anchor" href="#_1-java中的-reentrantlock-示例"><span>1. <strong>Java中的 <code>ReentrantLock</code> 示例</strong>：</span></a></h4><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">import</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> java.util.concurrent.locks.ReentrantLock</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> ReentrantLockExample</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> final</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> ReentrantLock</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> lock </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> ReentrantLock</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> method1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        lock</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">lock</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();  </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 获取锁</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        try</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">            // 执行一些操作</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">            method2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();  </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 同一个线程可以再次获取锁</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        } </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">finally</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">            lock</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">unlock</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();  </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 释放锁</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        }</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> method2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        lock</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">lock</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();  </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 同一个线程可以再次获取锁</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        try</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">            // 执行一些操作</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        } </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">finally</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">            lock</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">unlock</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();  </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 释放锁</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        }</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，<code>method1()</code> 调用 <code>method2()</code>，由于 <code>ReentrantLock</code> 是可重入的，同一个线程可以在 <code>method1()</code> 中获取锁后继续进入 <code>method2()</code> 并成功获取锁。</p><h4 id="_2-java中的-synchronized-示例" tabindex="-1"><a class="header-anchor" href="#_2-java中的-synchronized-示例"><span>2. <strong>Java中的 <code>synchronized</code> 示例</strong>：</span></a></h4><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> SynchronizedExample</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> synchronized</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> method1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 获取锁</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">        method2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();  </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 由于synchronized是可重入的，同一线程可以再次进入同步方法</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> synchronized</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> method2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 获取锁</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，<code>method1()</code> 获取了锁后，调用了 <code>method2()</code>，由于 <code>synchronized</code> 也是可重入锁，所以线程不需要等待自己释放锁，而是可以直接进入 <code>method2()</code>。</p><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结：</span></a></h3><p>可重入锁允许同一个线程多次获得锁，避免了死锁的发生。<code>ReentrantLock</code> 是显式的可重入锁，需要开发者手动控制锁的获取和释放，而 <code>synchronized</code> 关键字实现的是隐式的可重入锁，JVM 自动管理。</p>',13)]))}]]),t=JSON.parse('{"path":"/Interview/%E9%BB%91%E9%A9%ACJava2023/08%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/02%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8/7.%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81.html","title":"7.什么是可重入锁？","lang":"zh-CN","frontmatter":{"gitInclude":[]},"headers":[{"level":3,"title":"详细解释：","slug":"详细解释","link":"#详细解释","children":[]},{"level":3,"title":"示例（Java中的 ReentrantLock 和 synchronized）：","slug":"示例-java中的-reentrantlock-和-synchronized","link":"#示例-java中的-reentrantlock-和-synchronized","children":[]},{"level":3,"title":"总结：","slug":"总结","link":"#总结","children":[]}],"readingTime":{"minutes":2.15,"words":644},"filePathRelative":"Interview/黑马Java2023/08并发编程/02并发安全/7.什么是可重入锁.md","excerpt":"\\n<div class=\\"hint-container important\\">\\n<p class=\\"hint-container-title\\">重要</p>\\n<p><strong>可重入锁（Reentrant Lock）</strong> 是一种允许同一个线程多次获取锁的锁机制，也就是说，当一个线程已经持有某个锁时，它可以再次获得该锁，而不会发生死锁。</p>\\n</div>\\n<h3>详细解释：</h3>\\n<ol>\\n<li>\\n<p><strong>可重入性</strong>：可重入锁的最关键特性是，如果一个线程已经获得了锁，它可以在同一线程内再次获取该锁。例如，线程可以进入一个已经同步的代码块或方法，继续执行其他同步代码，而不需要等待锁的释放。</p>\\n</li>\\n<li>\\n<p><strong>避免死锁</strong>：可重入锁防止了一个线程因无法再次获取锁而陷入死锁。没有可重入锁时，如果一个线程试图进入自己已经持有的锁所保护的代码块，将会造成死锁。可重入锁通过允许线程重新获得锁来避免这个问题。</p>\\n</li>\\n<li>\\n<p><strong>工作原理</strong>：每个锁都有一个计数器，表示锁被获得的次数。当一个线程第一次请求该锁时，计数器被设为1。如果同一个线程再次请求该锁，计数器的值会递增。每次释放锁时，计数器会递减，直到计数器为0，表示锁被完全释放。</p>\\n</li>\\n</ol>"}')}}]);