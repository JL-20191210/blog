"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[64038],{66262:(l,i)=>{i.A=(l,i)=>{const n=l.__vccOpts||l;for(const[l,t]of i)n[l]=t;return n}},53202:(l,i,n)=>{n.r(i),n.d(i,{comp:()=>o,data:()=>s});var t=n(20641);const r={},o=(0,n(66262).A)(r,[["render",function(l,i){return(0,t.uX)(),(0,t.CE)("div",null,i[0]||(i[0]=[(0,t.Fv)('<h1 id="项目问题2-0" tabindex="-1"><a class="header-anchor" href="#项目问题2-0"><span>项目问题2.0</span></a></h1><h3 id="_1-为什么项目中使用rabbitmq" tabindex="-1"><a class="header-anchor" href="#_1-为什么项目中使用rabbitmq"><span>1.为什么项目中使用RabbitMQ？</span></a></h3><p><strong>第一，系统之间的解耦。</strong> 我们的系统是典型的微服务架构，比如侦查需求统筹系统（01）要向卫星公司 IO 系统（02）发送任务请求。 如果用同步调用（比如 Feign），那一旦对方服务不可用，整个链路就会被阻塞。 RabbitMQ 作为中间层，可以让消息先入队，即使卫星公司系统暂时不可用，消息也不会丢失，等对方恢复后自动消费，实现了系统之间的松耦合。<strong>第二，异步处理，提升系统响应速度。</strong> 像需求提报这种操作，涉及到多级节点（局基地、科处、哨位）的状态同步，如果全部走同步调用，会导致接口响应时间长。</p><p>我们把部分非关键流程（比如日志记录、状态广播、通知）放到 MQ 异步执行，让主业务线程更快返回，提高了整体吞吐量。</p><p><strong>第三，削峰填谷，提升系统稳定性。</strong> 在一些高峰期，比如战区集中提报任务或卫星回传数据时，会有瞬时流量高峰。 我们通过 MQ 缓冲消息流，消费者端可以按自身处理能力消费，从而防止数据库或下游服务被压垮。</p><h3 id="_2-为什么选-rabbitmq-而不是-kafka" tabindex="-1"><a class="header-anchor" href="#_2-为什么选-rabbitmq-而不是-kafka"><span>2.为什么选 RabbitMQ 而不是 Kafka？</span></a></h3><p>我们的系统属于<strong>政务/军工类分布式系统</strong>，消息量没有互联网业务那么大，但<strong>每一条消息都必须可靠送达</strong>。 RabbitMQ 在这方面做得更好，支持：</p><ul><li>消息确认机制（ACK/NACK）</li><li>持久化队列（Durable）</li><li>死信队列（DLX）</li><li>延迟队列</li></ul><p>这些机制让消息可靠性可以做到“几乎不丢”，非常符合我们这种对一致性和可靠性要求极高的场景。</p><p>Kafka 更偏向<strong>日志流式处理</strong>，追求的是高吞吐和顺序消费，但对实时事务一致性保障较弱，不太适合我们这种强事务系统。</p><h3 id="_3-你们在可靠性这方面是怎么设计的" tabindex="-1"><a class="header-anchor" href="#_3-你们在可靠性这方面是怎么设计的"><span>3.你们在可靠性这方面是怎么设计的？</span></a></h3><p><strong>🧩 1️⃣ 消息可靠投递（生产端可靠性）</strong></p><p>在生产端，我们严格防止“消息丢失”。 设计上做了三层保障：</p><ol><li><strong>本地事务 + 消息表机制</strong><ul><li>在业务服务中，数据库操作和消息发送放在同一个本地事务里。</li><li>比如需求提报时，先写业务表，同时往消息表插入一条“待发送”记录。</li><li>事务提交后，再由定时任务扫描消息表异步发送 MQ，确保即使系统重启或 MQ 暂时不可用，消息也不会丢失。</li></ul></li><li><strong>Confirm 确认机制</strong><ul><li>开启 RabbitMQ 的 <code>publisher-confirm</code> 模式。</li><li>生产者发送消息后会等待 Broker 返回 ack，只有收到确认才更新消息表状态为“已发送”。</li></ul></li><li><strong>Mandatory 与 Return 回调</strong><ul><li>开启 <code>mandatory</code> 参数，如果消息未能路由到任何队列，会触发回调并记录日志或重新投递。</li></ul></li></ol><p><strong>⚙️ 2️⃣ 消费端幂等性保证（防止重复消费）</strong></p><p>RabbitMQ 在网络抖动或重试时可能造成重复消息，因此我们在消费端做了<strong>幂等控制</strong>：</p><ul><li>每条消息有唯一业务 ID（例如需求 ID + 消息类型），</li><li>消费时先查幂等表或 Redis，看该消息是否已处理；</li><li>已处理则直接丢弃，否则执行并标记完成。</li></ul><p>这样即使消息被重复投递，也不会产生业务副作用。</p><p><strong>🔁 3️⃣ 失败重试与延迟队列机制</strong></p><p>对于消费失败的消息，我们设计了两级重试机制：</p><ol><li><strong>业务内重试</strong>：消费失败时先手动 NACK 并重新入队（设置最大重试次数）。</li><li><strong>延迟队列重试</strong>： <ul><li>超过重试次数后，消息进入延迟队列（例如延迟 5 秒、30 秒、5 分钟等）；</li><li>定时重试，直到消费成功或进入死信队列（DLX）待人工干预。</li></ul></li></ol><p>这种方式既能保证消息不丢失，也避免了频繁重试导致队列堆积。 <strong>💾 4️⃣ 持久化与镜像队列（Broker 可靠性）</strong></p><p>RabbitMQ 层面我们开启了持久化配置：</p><ul><li>队列设置为 <code>durable=true</code>；</li><li>消息属性设置为 <code>deliveryMode=2</code>（持久化消息）。</li></ul><p>同时在部署上启用了 <strong>镜像队列（HA 队列）</strong>：</p><ul><li>每条消息会在多个节点间复制；</li><li>即使某个节点宕机，其他节点也能无缝接管，不会丢失消息。</li></ul><h3 id="_4-那如果数据库事务回滚了-但-mq-消息已经发出去了-你怎么处理" tabindex="-1"><a class="header-anchor" href="#_4-那如果数据库事务回滚了-但-mq-消息已经发出去了-你怎么处理"><span>4.那如果数据库事务回滚了，但 MQ 消息已经发出去了，你怎么处理？</span></a></h3><h4 id="_1️⃣-核心思路" tabindex="-1"><a class="header-anchor" href="#_1️⃣-核心思路"><span><strong>1️⃣ 核心思路</strong></span></a></h4><ul><li><strong>不直接在数据库事务里发送 MQ 消息</strong></li><li><strong>先把消息写入本地消息表</strong>（与业务表同一事务）</li><li><strong>事务提交成功后，再异步发送 MQ</strong></li><li><strong>发送失败可重试</strong> → 保证最终一致性</li></ul><p><strong>2️⃣ 流程步骤</strong></p><ol><li><strong>开启本地或 Seata 全局事务</strong>（根据是否跨库）</li><li><strong>写业务数据 + 写本地消息表</strong>（消息状态 = <code>PENDING</code>）</li><li><strong>提交事务</strong><ul><li>如果事务回滚 → 消息表未写入 → 消息不会发送</li></ul></li><li><strong>异步定时任务扫描消息表</strong><ul><li>发现 <code>PENDING</code> 消息 → 发送 MQ</li><li>MQ confirm 成功 → 更新消息状态为 <code>SENT</code></li><li>发送失败 → 重试（下次扫描再发送）</li></ul></li><li><strong>幂等控制</strong><ul><li>下游消费系统根据消息 ID 做幂等判断，避免重复消费</li></ul></li></ol><h3 id="_5-遇到的难题-怎么解决的" tabindex="-1"><a class="header-anchor" href="#_5-遇到的难题-怎么解决的"><span>5.遇到的难题，怎么解决的？</span></a></h3><h3 id="_1️⃣-分布式事务一致性问题" tabindex="-1"><a class="header-anchor" href="#_1️⃣-分布式事务一致性问题"><span><strong>1️⃣ 分布式事务一致性问题</strong></span></a></h3><p><strong>难题：</strong></p><ul><li>需求提报涉及跨服务数据库更新（需求表、状态表），</li><li>同时要发送 MQ 消息通知下游系统，</li><li>数据库回滚但消息已发出会导致不一致。</li></ul><p><strong>解决思路：</strong></p><ol><li>核心业务数据使用 <strong>Seata 全局事务</strong>，保证跨服务/跨库操作原子性；</li><li>MQ 消息采用 <strong>本地消息表 + 定时任务异步发送</strong>，事务回滚时消息不会发送；</li><li>异步发送加<strong>幂等控制 + 重试机制</strong>，确保最终一致性。</li></ol><blockquote><p>核心思路：强一致性保证核心业务 + 最终一致性保证消息可靠投递。</p></blockquote><h3 id="_2️⃣-高并发报表生成性能问题" tabindex="-1"><a class="header-anchor" href="#_2️⃣-高并发报表生成性能问题"><span><strong>2️⃣ 高并发报表生成性能问题</strong></span></a></h3><p><strong>难题：</strong></p><ul><li>全国需求报表生成量大，原本生成时间分钟级，影响业务效率。</li></ul><p><strong>解决思路：</strong></p><ol><li>使用 <strong>EasyExcel</strong> 高性能生成 Excel；</li><li><strong>SQL 索引优化 + Redis 缓存</strong>，减少数据库扫描量；</li><li>异步化生成报表 + 流量削峰，性能从分钟级提升到秒级。</li></ol><blockquote><p>核心思路：结合缓存和异步处理，提高高并发场景下的吞吐量和响应速度。、</p></blockquote><h3 id="_3️⃣-分布式节点状态同步问题" tabindex="-1"><a class="header-anchor" href="#_3️⃣-分布式节点状态同步问题"><span><strong>3️⃣ 分布式节点状态同步问题</strong></span></a></h3><p><strong>难题：</strong></p><ul><li>系统是三级树形节点（局基地、科处、哨位），</li><li>需求状态要同步到下级节点，网络延迟或节点宕机可能导致状态不一致。</li></ul><p><strong>解决思路：</strong></p><ol><li><strong>RabbitMQ 异步消息队列</strong>实现状态广播，解耦节点间通信；</li><li>消息加 <strong>幂等控制</strong>，避免重复消费导致错误；</li><li>关键节点状态变更增加<strong>重试和补偿机制</strong>，确保最终一致。</li></ol><blockquote><p>核心思路：异步 + 幂等 + 补偿，保证分布式状态一致性。</p></blockquote><h3 id="_4️⃣-微服务高可用和负载均衡问题" tabindex="-1"><a class="header-anchor" href="#_4️⃣-微服务高可用和负载均衡问题"><span><strong>4️⃣ 微服务高可用和负载均衡问题</strong></span></a></h3><p><strong>难题：</strong></p><ul><li>微服务多副本部署，需要保证服务注册发现、配置统一、调用高可用。</li></ul><p><strong>解决思路：</strong></p><ol><li>使用 <strong>Nacos</strong> 做服务注册发现 + 配置中心；</li><li>同步调用使用 <strong>OpenFeign</strong>，异步调用用 <strong>MQ</strong>；</li><li>Docker 多副本部署，保证负载均衡和高可用。</li></ol><blockquote><p>核心思路：服务注册 + 异步解耦 + 多副本部署，确保系统稳定性。</p></blockquote>',56)]))}]]),s=JSON.parse('{"path":"/Interview/Java/00-%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E9%A1%B9%E7%9B%AE%E9%97%AE%E9%A2%982.0.html","title":"项目问题2.0","lang":"zh-CN","frontmatter":{"gitInclude":[]},"headers":[{"level":3,"title":"1.为什么项目中使用RabbitMQ？","slug":"_1-为什么项目中使用rabbitmq","link":"#_1-为什么项目中使用rabbitmq","children":[]},{"level":3,"title":"2.为什么选 RabbitMQ 而不是 Kafka？","slug":"_2-为什么选-rabbitmq-而不是-kafka","link":"#_2-为什么选-rabbitmq-而不是-kafka","children":[]},{"level":3,"title":"3.你们在可靠性这方面是怎么设计的？","slug":"_3-你们在可靠性这方面是怎么设计的","link":"#_3-你们在可靠性这方面是怎么设计的","children":[]},{"level":3,"title":"4.那如果数据库事务回滚了，但 MQ 消息已经发出去了，你怎么处理？","slug":"_4-那如果数据库事务回滚了-但-mq-消息已经发出去了-你怎么处理","link":"#_4-那如果数据库事务回滚了-但-mq-消息已经发出去了-你怎么处理","children":[]},{"level":3,"title":"5.遇到的难题，怎么解决的？","slug":"_5-遇到的难题-怎么解决的","link":"#_5-遇到的难题-怎么解决的","children":[]},{"level":3,"title":"1️⃣ 分布式事务一致性问题","slug":"_1️⃣-分布式事务一致性问题","link":"#_1️⃣-分布式事务一致性问题","children":[]},{"level":3,"title":"2️⃣ 高并发报表生成性能问题","slug":"_2️⃣-高并发报表生成性能问题","link":"#_2️⃣-高并发报表生成性能问题","children":[]},{"level":3,"title":"3️⃣ 分布式节点状态同步问题","slug":"_3️⃣-分布式节点状态同步问题","link":"#_3️⃣-分布式节点状态同步问题","children":[]},{"level":3,"title":"4️⃣ 微服务高可用和负载均衡问题","slug":"_4️⃣-微服务高可用和负载均衡问题","link":"#_4️⃣-微服务高可用和负载均衡问题","children":[]}],"readingTime":{"minutes":6.42,"words":1927},"filePathRelative":"Interview/Java/00-项目相关/项目问题2.0.md","excerpt":"\\n<h3>1.为什么项目中使用RabbitMQ？</h3>\\n<p><strong>第一，系统之间的解耦。</strong>\\n我们的系统是典型的微服务架构，比如侦查需求统筹系统（01）要向卫星公司 IO 系统（02）发送任务请求。\\n如果用同步调用（比如 Feign），那一旦对方服务不可用，整个链路就会被阻塞。\\nRabbitMQ 作为中间层，可以让消息先入队，即使卫星公司系统暂时不可用，消息也不会丢失，等对方恢复后自动消费，实现了系统之间的松耦合。<strong>第二，异步处理，提升系统响应速度。</strong>\\n像需求提报这种操作，涉及到多级节点（局基地、科处、哨位）的状态同步，如果全部走同步调用，会导致接口响应时间长。</p>"}')}}]);