"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[90590],{66262:(e,a)=>{a.A=(e,a)=>{const i=e.__vccOpts||e;for(const[e,l]of a)i[e]=l;return i}},65222:(e,a,i)=>{i.r(a),i.d(a,{comp:()=>h,data:()=>s});var l=i(20641);const t={},h=(0,i(66262).A)(t,[["render",function(e,a){const i=(0,l.g2)("RouteLink");return(0,l.uX)(),(0,l.CE)("div",null,[a[2]||(a[2]=(0,l.Lk)("h1",{id:"🧪-4-2-如何分析-java-堆转储文件-hprof",tabindex:"-1"},[(0,l.Lk)("a",{class:"header-anchor",href:"#🧪-4-2-如何分析-java-堆转储文件-hprof"},[(0,l.Lk)("span",null,"🧪 4.2 如何分析 Java 堆转储文件（hprof）")])],-1)),a[3]||(a[3]=(0,l.Lk)("p",null,[(0,l.eW)("在面对 OOM、内存泄漏、对象激增等问题时，分析堆转储（heap dump）文件是最直接有效的方式之一。本节介绍如何生成、加载与分析 "),(0,l.Lk)("code",null,".hprof"),(0,l.eW)(" 文件。")],-1)),a[4]||(a[4]=(0,l.Lk)("hr",null,null,-1)),(0,l.Q3)(" more "),a[5]||(a[5]=(0,l.Fv)('<h2 id="📦-什么是-heap-dump" tabindex="-1"><a class="header-anchor" href="#📦-什么是-heap-dump"><span>📦 什么是 Heap Dump？</span></a></h2><p>Heap Dump 是 JVM 在某一时间点内存快照，记录了所有对象实例及其引用关系。通过分析可识别：</p><ul><li>内存泄漏来源</li><li>对象保留链（GC Root → ... → 对象）</li><li>谁持有了最多内存</li><li>哪些类实例增长异常</li></ul><hr><h2 id="🛠️-如何生成-heap-dump-文件" tabindex="-1"><a class="header-anchor" href="#🛠️-如何生成-heap-dump-文件"><span>🛠️ 如何生成 Heap Dump 文件？</span></a></h2><h3 id="✅-自动生成-推荐" tabindex="-1"><a class="header-anchor" href="#✅-自动生成-推荐"><span>✅ 自动生成（推荐）</span></a></h3><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">-XX:+HeapDumpOnOutOfMemoryError</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">-XX:HeapDumpPath</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">=/path/to/dump.hprof</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="✅-手动生成" tabindex="-1"><a class="header-anchor" href="#✅-手动生成"><span>✅ 手动生成</span></a></h3><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">jmap</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -dump:format=b,file=heap.hprof</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">pi</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">d&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="✅-jdk-其他工具" tabindex="-1"><a class="header-anchor" href="#✅-jdk-其他工具"><span>✅ JDK 其他工具</span></a></h3><ul><li><code>jcmd &lt;pid&gt; GC.heap_dump /path/to/heap.hprof</code></li><li>JVisualVM 图形界面：右键 → Dump Heap</li></ul><hr><h2 id="🔍-常见分析工具" tabindex="-1"><a class="header-anchor" href="#🔍-常见分析工具"><span>🔍 常见分析工具</span></a></h2><table><thead><tr><th>工具</th><th>功能说明</th></tr></thead><tbody><tr><td><strong>Eclipse MAT</strong></td><td>最主流的堆分析工具，支持 dominator tree、泄漏报告</td></tr><tr><td>VisualVM</td><td>简洁直观，适合轻量分析</td></tr><tr><td>GCeasy.io</td><td>在线上传分析，生成结构化图表和报告</td></tr><tr><td>IBM HeapAnalyzer</td><td>老牌工具，界面老旧但有用</td></tr></tbody></table><hr><h2 id="🧭-eclipse-mat-分析步骤" tabindex="-1"><a class="header-anchor" href="#🧭-eclipse-mat-分析步骤"><span>🧭 Eclipse MAT 分析步骤</span></a></h2><h3 id="_1-打开-hprof-文件" tabindex="-1"><a class="header-anchor" href="#_1-打开-hprof-文件"><span>1. 打开 <code>.hprof</code> 文件</span></a></h3><ul><li>可配置最大内存：<code>eclipse.ini</code> 中添加 <code>-Xmx4g</code></li></ul><h3 id="_2-查找内存占用最大的对象" tabindex="-1"><a class="header-anchor" href="#_2-查找内存占用最大的对象"><span>2. 查找内存占用最大的对象</span></a></h3><ul><li><code>Histogram</code> 查看按类分组的对象数量与占用内存</li></ul><h3 id="_3-查找泄漏疑点" tabindex="-1"><a class="header-anchor" href="#_3-查找泄漏疑点"><span>3. 查找泄漏疑点</span></a></h3><ul><li><code>Leak Suspects Report</code> 自动分析潜在内存泄漏点</li></ul><h3 id="_4-查看保留路径-retained-set" tabindex="-1"><a class="header-anchor" href="#_4-查看保留路径-retained-set"><span>4. 查看保留路径（Retained Set）</span></a></h3><ul><li><code>Dominator Tree</code>：看是哪个 GC Root 阻止对象回收</li></ul><h3 id="_5-分析静态字段、线程局部变量" tabindex="-1"><a class="header-anchor" href="#_5-分析静态字段、线程局部变量"><span>5. 分析静态字段、线程局部变量</span></a></h3><ul><li>查看是否存在 <code>static</code>、<code>ThreadLocalMap</code> 占用过大</li></ul><hr><h2 id="📌-案例关键术语解释" tabindex="-1"><a class="header-anchor" href="#📌-案例关键术语解释"><span>📌 案例关键术语解释</span></a></h2><table><thead><tr><th>概念</th><th>含义说明</th></tr></thead><tbody><tr><td>Shallow Size</td><td>对象本身占用内存大小，不含引用对象</td></tr><tr><td>Retained Size</td><td>回收该对象后，可释放的总内存大小</td></tr><tr><td>Dominator Tree</td><td>主导引用链，找出最“霸占”内存的对象</td></tr><tr><td>GC Roots</td><td>垃圾回收起点对象集</td></tr></tbody></table><hr><h2 id="📝-小结" tabindex="-1"><a class="header-anchor" href="#📝-小结"><span>📝 小结</span></a></h2><ul><li>HeapDump 是分析 OOM、内存泄漏等问题的核心利器</li><li>建议生产环境开启 <code>HeapDumpOnOutOfMemoryError</code></li><li>Eclipse MAT 提供丰富的分析视角与图形工具</li><li>关注 Retained Size、Dominator Tree 和 GC Roots</li></ul><hr>',33)),(0,l.Lk)("p",null,[a[1]||(a[1]=(0,l.eW)("👉 下一篇推荐：")),(0,l.bF)(i,{to:"/JVM/%E4%B8%80%E5%91%BD%E9%80%9F%E9%80%9A/4.%20JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E4%B8%8E%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7/4.3%E5%B8%B8%E8%A7%81%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%AE%9A%E4%BD%8D%E6%8A%80%E5%B7%A7.html"},{default:(0,l.k6)((()=>a[0]||(a[0]=[(0,l.eW)("4.3 常见内存泄漏模式与定位技巧")]))),_:1})])])}]]),s=JSON.parse('{"path":"/JVM/%E4%B8%80%E5%91%BD%E9%80%9F%E9%80%9A/4.%20JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E4%B8%8E%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7/4.2%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90%20Java%20%E5%A0%86%E8%BD%AC%E5%82%A8%E6%96%87%E4%BB%B6%EF%BC%88hprof%EF%BC%89.html","title":"4.2 如何分析 Java 堆转储文件（hprof）","lang":"zh-CN","frontmatter":{"title":"4.2 如何分析 Java 堆转储文件（hprof）","icon":"fa-solid fa-dumpster-fire","date":"2025-07-10T00:00:00.000Z","author":"JeanHu","category":["JVM"],"tag":["JVM","hprof","堆分析","内存排查","MAT"],"summary":"本文讲解如何生成与分析 Java 堆转储文件（hprof），涵盖工具选择、分析流程、内存泄漏识别技巧以及常见问题排查实战，帮助开发者掌握内存问题定位的核心能力。","gitInclude":[]},"headers":[{"level":2,"title":"📦 什么是 Heap Dump？","slug":"📦-什么是-heap-dump","link":"#📦-什么是-heap-dump","children":[]},{"level":2,"title":"🛠️ 如何生成 Heap Dump 文件？","slug":"🛠️-如何生成-heap-dump-文件","link":"#🛠️-如何生成-heap-dump-文件","children":[{"level":3,"title":"✅ 自动生成（推荐）","slug":"✅-自动生成-推荐","link":"#✅-自动生成-推荐","children":[]},{"level":3,"title":"✅ 手动生成","slug":"✅-手动生成","link":"#✅-手动生成","children":[]},{"level":3,"title":"✅ JDK 其他工具","slug":"✅-jdk-其他工具","link":"#✅-jdk-其他工具","children":[]}]},{"level":2,"title":"🔍 常见分析工具","slug":"🔍-常见分析工具","link":"#🔍-常见分析工具","children":[]},{"level":2,"title":"🧭 Eclipse MAT 分析步骤","slug":"🧭-eclipse-mat-分析步骤","link":"#🧭-eclipse-mat-分析步骤","children":[{"level":3,"title":"1. 打开 .hprof 文件","slug":"_1-打开-hprof-文件","link":"#_1-打开-hprof-文件","children":[]},{"level":3,"title":"2. 查找内存占用最大的对象","slug":"_2-查找内存占用最大的对象","link":"#_2-查找内存占用最大的对象","children":[]},{"level":3,"title":"3. 查找泄漏疑点","slug":"_3-查找泄漏疑点","link":"#_3-查找泄漏疑点","children":[]},{"level":3,"title":"4. 查看保留路径（Retained Set）","slug":"_4-查看保留路径-retained-set","link":"#_4-查看保留路径-retained-set","children":[]},{"level":3,"title":"5. 分析静态字段、线程局部变量","slug":"_5-分析静态字段、线程局部变量","link":"#_5-分析静态字段、线程局部变量","children":[]}]},{"level":2,"title":"📌 案例关键术语解释","slug":"📌-案例关键术语解释","link":"#📌-案例关键术语解释","children":[]},{"level":2,"title":"📝 小结","slug":"📝-小结","link":"#📝-小结","children":[]}],"readingTime":{"minutes":2.17,"words":650},"filePathRelative":"JVM/一命速通/4. JVM性能调优与监控工具/4.2如何分析 Java 堆转储文件（hprof）.md","localizedDate":"2025年7月10日","excerpt":"\\n<p>在面对 OOM、内存泄漏、对象激增等问题时，分析堆转储（heap dump）文件是最直接有效的方式之一。本节介绍如何生成、加载与分析 <code>.hprof</code> 文件。</p>\\n<hr>\\n"}')}}]);