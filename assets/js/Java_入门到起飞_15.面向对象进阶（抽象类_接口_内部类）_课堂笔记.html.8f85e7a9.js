"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[6683],{66262:(l,i)=>{i.A=(l,i)=>{const a=l.__vccOpts||l;for(const[l,e]of i)a[l]=e;return a}},39938:(l,i,a)=>{a.r(i),a.d(i,{comp:()=>s,data:()=>t});var e=a(20641);const n={},s=(0,a(66262).A)(n,[["render",function(l,i){return(0,e.uX)(),(0,e.CE)("div",null,i[0]||(i[0]=[(0,e.Fv)('<h1 id="课堂笔记" tabindex="-1"><a class="header-anchor" href="#课堂笔记"><span>课堂笔记</span></a></h1><h2 id="_1-抽象类的作用是什么样的" tabindex="-1"><a class="header-anchor" href="#_1-抽象类的作用是什么样的"><span>1.抽象类的作用是什么样的？</span></a></h2><ul><li>抽取共性时，无法确定方法体，就把方法定义为抽象的。</li><li>强制让子类按照某种格式重写。</li><li>抽象方法所在的类，必须是抽象类。</li></ul><hr><h2 id="_2-抽象类和抽象方法的格式" tabindex="-1"><a class="header-anchor" href="#_2-抽象类和抽象方法的格式"><span>2.抽象类和抽象方法的格式？</span></a></h2><ul><li><code>public abstract 返回值类型 方法名（参数列表);</code></li><li>``public abstract class 类名{}`</li></ul><hr><h2 id="_3-继承抽象类有哪些要注意" tabindex="-1"><a class="header-anchor" href="#_3-继承抽象类有哪些要注意"><span>3.继承抽象类有哪些要注意？</span></a></h2><ul><li>要么重写抽象类中的所有抽象方法</li><li>要么是抽象类</li></ul><hr><h2 id="_4-接口和类之间的关系" tabindex="-1"><a class="header-anchor" href="#_4-接口和类之间的关系"><span>4.接口和类之间的关系</span></a></h2><ul><li><p>类和类的关系 继承关系，只能单继承，不能多继承，但是可以多层继承</p></li><li><p>类和接口的关系 实现关系，可以单实现，也可以多实现，还可以在继承一个类的同时实玑多个接口</p></li><li><p>接口和接口的关系 继承关系，可以单继承，也可以多继承</p><blockquote><p>亲爹（继承）只有一个。义父（接口）可以有多个</p></blockquote></li></ul><hr><h3 id="_5-默认方法" tabindex="-1"><a class="header-anchor" href="#_5-默认方法"><span>5.默认方法</span></a></h3><p><strong>格式</strong>：</p><p><code>public default返回值类型 方法名（参数列表）{}</code></p><p><strong>接口中默认方法的注意事项：</strong></p><ol><li><p>默认方法不是抽象方法，所以不强制被重写。但是如果被重写，重写的时候去掉defau1t关键字</p></li><li><p>pub1ic可以省略，default不能省略</p></li><li><p>如果实现了多个接口，多个接口中存在相同名字的默认方法，子类就必须对该方法进行重写</p></li></ol><hr><h3 id="_6-静态方法" tabindex="-1"><a class="header-anchor" href="#_6-静态方法"><span>6.静态方法</span></a></h3><p><strong>格式：</strong><code>public static返回值类型方法名（参数列表）{}</code><strong>范例：</strong><code>public static void show(){}</code></p><p>接口中静态方法的<strong>注意事项</strong>： 静态方法只能通过接口名调用，不能通过实现类名或者对象名调用 public可以省略，static不能省略</p><hr><h3 id="_7-java接口在不同jdk版本中的发展历程" tabindex="-1"><a class="header-anchor" href="#_7-java接口在不同jdk版本中的发展历程"><span>7.Java接口在不同JDK版本中的发展历程</span></a></h3><ol><li>JDK7以前：接口中只能定义抽象方法。</li><li>JDK8:接口中可以定义有方法体的方法。（默认、静态）</li><li>JDK9:接口中可以定义私有方法。</li><li>私有方法分为两种：普通的私有方法，静态的私有方法</li></ol><hr><h3 id="_8-使用适配器模式" tabindex="-1"><a class="header-anchor" href="#_8-使用适配器模式"><span>8.使用适配器模式</span></a></h3><ol><li>当一个接口中<code>抽象方法过多</code>，但是我只要使用其中一部分的 时候，就可以适配器设计模式</li><li>书写步骤： <ul><li>编写中间类XXXAdapter,实现对应的接口</li><li>对接口中的抽象方法进行<code>空实现</code></li><li>让真正的实现类继承中间类，并重写需要用的方法</li><li>为避免其他类创建适配器类的对象，中间的适配器类 用abstracti进行修饰</li></ul></li></ol><hr>',29)]))}]]),t=JSON.parse('{"path":"/Java/%E5%85%A5%E9%97%A8%E5%88%B0%E8%B5%B7%E9%A3%9E/15.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6%EF%BC%88%E6%8A%BD%E8%B1%A1%E7%B1%BB_%E6%8E%A5%E5%8F%A3_%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%89/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0.html","title":"课堂笔记","lang":"zh-CN","frontmatter":{"gitInclude":[]},"headers":[{"level":2,"title":"1.抽象类的作用是什么样的？","slug":"_1-抽象类的作用是什么样的","link":"#_1-抽象类的作用是什么样的","children":[]},{"level":2,"title":"2.抽象类和抽象方法的格式？","slug":"_2-抽象类和抽象方法的格式","link":"#_2-抽象类和抽象方法的格式","children":[]},{"level":2,"title":"3.继承抽象类有哪些要注意？","slug":"_3-继承抽象类有哪些要注意","link":"#_3-继承抽象类有哪些要注意","children":[]},{"level":2,"title":"4.接口和类之间的关系","slug":"_4-接口和类之间的关系","link":"#_4-接口和类之间的关系","children":[{"level":3,"title":"5.默认方法","slug":"_5-默认方法","link":"#_5-默认方法","children":[]},{"level":3,"title":"6.静态方法","slug":"_6-静态方法","link":"#_6-静态方法","children":[]},{"level":3,"title":"7.Java接口在不同JDK版本中的发展历程","slug":"_7-java接口在不同jdk版本中的发展历程","link":"#_7-java接口在不同jdk版本中的发展历程","children":[]},{"level":3,"title":"8.使用适配器模式","slug":"_8-使用适配器模式","link":"#_8-使用适配器模式","children":[]}]}],"readingTime":{"minutes":2.19,"words":657},"filePathRelative":"Java/入门到起飞/15.面向对象进阶（抽象类&接口&内部类）/课堂笔记.md","excerpt":"\\n<h2>1.抽象类的作用是什么样的？</h2>\\n<ul>\\n<li>抽取共性时，无法确定方法体，就把方法定义为抽象的。</li>\\n<li>强制让子类按照某种格式重写。</li>\\n<li>抽象方法所在的类，必须是抽象类。</li>\\n</ul>\\n<hr>\\n<h2>2.抽象类和抽象方法的格式？</h2>\\n<ul>\\n<li><code>public abstract 返回值类型 方法名（参数列表);</code></li>\\n<li>``public abstract class 类名{}`</li>\\n</ul>\\n<hr>\\n<h2>3.继承抽象类有哪些要注意？</h2>\\n<ul>\\n<li>要么重写抽象类中的所有抽象方法</li>\\n<li>要么是抽象类</li>\\n</ul>"}')}}]);