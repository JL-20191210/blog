"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[33526],{66262:(l,i)=>{i.A=(l,i)=>{const n=l.__vccOpts||l;for(const[l,r]of i)n[l]=r;return n}},96959:(l,i,n)=>{n.r(i),n.d(i,{comp:()=>s,data:()=>t});var r=n(20641);const a={},s=(0,n(66262).A)(a,[["render",function(l,i){const n=(0,r.g2)("Badge");return(0,r.uX)(),(0,r.CE)("div",null,[i[0]||(i[0]=(0,r.Fv)('<h1 id="四种分布式事务模式" tabindex="-1"><a class="header-anchor" href="#四种分布式事务模式"><span>四种分布式事务模式</span></a></h1><h2 id="_1-xa-模式" tabindex="-1"><a class="header-anchor" href="#_1-xa-模式"><span>1. XA 模式</span></a></h2><h3 id="_1-1-概念" tabindex="-1"><a class="header-anchor" href="#_1-1-概念"><span>1.1 概念</span></a></h3><p><strong>XA（eXtended Architecture）</strong> 是一种分布式事务协议，通常用于支持跨多个资源管理器（如数据库、消息队列等）的事务。</p><ul><li><strong>特点</strong>: <ul><li>使用两阶段提交协议（2PC）来保证事务的一致性。</li><li>保证所有参与的资源管理器在同一个事务中要么都成功提交，要么都回滚。</li><li>对于涉及多个资源管理器的事务，XA 协议能够提供强一致性。</li></ul></li></ul><blockquote><p>XA模式下RM由数据库提供</p></blockquote><h3 id="_1-2-两阶段提交" tabindex="-1"><a class="header-anchor" href="#_1-2-两阶段提交"><span>1.2 两阶段提交</span></a></h3><h4 id="第一阶段-准备阶段-prepare-phase" tabindex="-1"><a class="header-anchor" href="#第一阶段-准备阶段-prepare-phase"><span><strong>第一阶段：准备阶段（Prepare Phase）</strong></span></a></h4><ol><li><p><strong>事务发起者（TM）</strong></p><ul><li>启动全局事务。</li><li>向**事务协调者（TC）**注册全局事务，并获得全局事务ID（XID）。</li><li>调用本地资源管理器（RM）执行本地事务。</li></ul></li><li><p><strong>资源管理器（RM）</strong></p><ul><li>执行本地事务的操作（如数据库操作）。</li><li>在**事务协调者（TC）**发出准备请求时，执行本地事务的预处理，并确保没有问题可以提交。</li><li>返回准备状态：如果本地事务准备好，可以提交，RM会返回&quot;准备好&quot;（prepared）状态；如果出现问题，RM会返回&quot;回滚&quot;（rollback）状态。</li></ul></li><li><p><strong>事务协调者（TC）</strong></p><ul><li>收到**事务发起者（TM）**的准备请求后，协调所有参与的RM。</li><li>向所有RM发送准备请求，并等待它们的响应（准备好或回滚）。</li><li>根据所有RM的响应，判断是否继续进入提交阶段。</li></ul></li></ol><h4 id="第二阶段-提交-回滚阶段-commit-rollback-phase" tabindex="-1"><a class="header-anchor" href="#第二阶段-提交-回滚阶段-commit-rollback-phase"><span><strong>第二阶段：提交/回滚阶段（Commit/Rollback Phase）</strong></span></a></h4><ol><li><p><strong>事务发起者（TM）</strong></p><ul><li>根据第一阶段**事务协调者（TC）**的协调结果： <ul><li>如果所有RM返回“准备好”，TM向TC请求提交全局事务。</li><li>如果任何RM返回“回滚”，TM向TC请求回滚全局事务。</li></ul></li></ul></li><li><p><strong>资源管理器（RM）</strong></p><ul><li>根据**事务协调者（TC）**的指令： <ul><li>如果TC发送提交请求，RM执行本地事务提交。</li><li>如果TC发送回滚请求，RM执行本地事务回滚。</li></ul></li></ul></li><li><p><strong>事务协调者（TC）</strong></p><ul><li>根据所有RM的准备状态决定是否提交或回滚全局事务： <ul><li>如果所有RM都返回“准备好”，TC向所有RM发送提交请求，完成全局事务提交。</li><li>如果有任何RM返回“回滚”，TC向所有RM发送回滚请求，完成全局事务回滚。</li></ul></li></ul></li></ol><h4 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结：</span></a></h4>',12)),(0,r.bF)(n,{text:"important",type:"important"}),i[1]||(i[1]=(0,r.Fv)(' <ul><li><strong>第一阶段（准备阶段）</strong>：TM启动全局事务并请求RM执行本地事务；RM进行本地操作并报告准备状态；TC协调所有RM并判断是否进入提交阶段。</li><li><strong>第二阶段（提交/回滚阶段）</strong>：TM根据TC的判断请求提交或回滚全局事务；RM根据TC的指令执行本地事务提交或回滚；TC最终决定全局事务是否提交或回滚。</li></ul><h3 id="_1-3缺点" tabindex="-1"><a class="header-anchor" href="#_1-3缺点"><span>1.3<strong>缺点</strong>:</span></a></h3><ul><li><code>需要锁定数据库资源，等待二阶段结束后才会释放(资源锁定周期过长)</code>。性能开销较大，尤其是在高并发场景下。</li><li>复杂度高，易出现长时间锁定和死锁问题。</li><li>XA模式是建立在数据库的事务管理功能之上的，没有事务管理功能的数据库无法使用XA模式。</li></ul><h2 id="_2-at-模式" tabindex="-1"><a class="header-anchor" href="#_2-at-模式"><span>2. AT 模式</span></a></h2><h3 id="_2-1-概念" tabindex="-1"><a class="header-anchor" href="#_2-1-概念"><span>2.1 概念</span></a></h3><p><strong>AT（Auto Transaction）</strong> 模式是基于事务代理的模式，立即执行并保存修改前后快照信息。RM由seata框架管理。<code>缺弥补了XA模型中资源锁定周期过长的缺陷</code>。</p><ul><li>AT模式的优点： <ul><li>一阶段完成直接提交事务，释放数据库资源，性能比较好</li><li>利用全局锁实现读写隔离</li><li>没有代码侵入（不用自己写代码），框架自动完成回滚和提交</li></ul></li></ul><h3 id="_2-2两阶段提交" tabindex="-1"><a class="header-anchor" href="#_2-2两阶段提交"><span>2.2两阶段提交</span></a></h3><h4 id="阶段一-事务执行阶段" tabindex="-1"><a class="header-anchor" href="#阶段一-事务执行阶段"><span>阶段一：事务执行阶段</span></a></h4><ul><li><p><strong>TM（事务管理器）</strong>：</p><ul><li>启动全局事务，并管理事务的生命周期。</li><li>负责协调并通知 <strong>TC</strong> 和 <strong>RM</strong> 开始事务。</li><li>在执行过程中，<strong>TM</strong> 会记录每个操作，确保系统能够在需要时进行回滚或补偿。</li></ul></li><li><p><strong>TC（事务协调者）</strong>：</p><ul><li>负责管理和控制全局事务的执行进度。</li><li><strong>TC</strong> 会与多个 <strong>RM</strong> 进行交互，确保所有资源管理器按照约定执行事务。</li><li><strong>TC</strong> 会等待所有 <strong>RM</strong> 的反馈，确认是否可以提交事务。</li></ul></li><li><p><strong>RM（资源管理器）</strong>：</p><ul><li>负责本地事务的执行，执行资源管理的操作（如数据库操作）。</li><li><strong>RM</strong> 会记录操作日志，确保如果事务需要回滚时能够通过 <strong>Undo Log</strong> 进行恢复。</li><li>资源管理器不向 <strong>TC</strong> 发送 Prepare 消息，而是直接执行操作并准备好相关补偿策略。</li></ul></li></ul><h4 id="阶段二-提交或回滚阶段" tabindex="-1"><a class="header-anchor" href="#阶段二-提交或回滚阶段"><span>阶段二：提交或回滚阶段</span></a></h4><ul><li><p><strong>TM（事务管理器）</strong>：</p><ul><li>监控事务的整体进度，协调全局事务的提交或回滚。</li><li><strong>TM</strong> 会根据 <strong>TC</strong> 的决策通知相关操作，如是否提交或回滚。</li></ul></li><li><p><strong>TC（事务协调者）</strong>：</p><ul><li>根据所有 <strong>RM</strong> 的反馈决定是否提交或回滚全局事务。</li><li>如果所有 <strong>RM</strong> 都成功执行，<strong>TC</strong> 会发出提交指令。</li><li>如果任一 <strong>RM</strong> 失败或全局事务选择回滚，<strong>TC</strong> 会发出回滚指令。</li><li>负责协调全局事务的最终结果，确保系统的一致性。</li></ul></li><li><p><strong>RM（资源管理器）</strong>：</p><ul><li>根据 <strong>TC</strong> 的指令执行提交或回滚操作。</li><li>提交时，<strong>RM</strong> 会正式确认本地事务的执行结果。</li><li>回滚时，<strong>RM</strong> 会使用 <strong>Undo Log</strong> 或补偿操作来撤销本地事务，恢复到事务开始之前的状态。</li></ul></li></ul>',13)),(0,r.bF)(n,{text:"important",type:"important"}),i[2]||(i[2]=(0,r.Fv)(' <h4 id="总结-1" tabindex="-1"><a class="header-anchor" href="#总结-1"><span>总结</span></a></h4><ol><li><strong>执行阶段</strong>：事务开始执行并记录日志，资源管理器执行操作。</li><li><strong>提交/回滚阶段</strong>：协调者根据资源管理器的反馈来决定全局事务是否提交或回滚，资源管理器根据指令提交或撤销操作。</li></ol><h3 id="_2-3-简述at模式与xa模式最大的区别是什么" tabindex="-1"><a class="header-anchor" href="#_2-3-简述at模式与xa模式最大的区别是什么"><span>2.3 简述AT模式与XA模式最大的区别是什么？</span></a></h3><ul><li><p>XA模式一阶段不提交事务，锁定资源；AT模式一阶段直接提交，不锁定资源。</p></li><li><p>XA模式依赖数据库机制实现回滚；AT模式利用数据快照实现数据回滚。</p></li><li><p>XA模式强一致；AT模式最终一致</p></li></ul><h3 id="_2-4缺点" tabindex="-1"><a class="header-anchor" href="#_2-4缺点"><span>2.4缺点</span></a></h3><ul><li>两阶段之间属于软状态，属于最终一致</li><li>框架的快照功能会影响性能，但比XA模式要好很多</li></ul><h2 id="_3-tcc-模式" tabindex="-1"><a class="header-anchor" href="#_3-tcc-模式"><span>3.TCC 模式</span></a></h2><p><strong>TCC（Try-Confirm-Cancel）</strong> 是一种分布式事务的补偿性事务模型，它通过将事务分为三个阶段来保证一致性</p><blockquote><p>类似银行卡的预授权功能。</p></blockquote><h3 id="_3-1三个阶段" tabindex="-1"><a class="header-anchor" href="#_3-1三个阶段"><span>3.1三个阶段</span></a></h3><h4 id="_1-try-阶段" tabindex="-1"><a class="header-anchor" href="#_1-try-阶段"><span>1. <strong>Try 阶段</strong></span></a></h4><ul><li><p><strong>事务发起方（RM）</strong>：</p><ul><li>在 Try 阶段，发起方执行业务操作的预留（预占资源）工作，并保证该操作可以被确认或取消。此阶段的核心是资源预留（例如：库存扣减，但不实际减少）。</li><li>在 Try 阶段，发起方会向事务协调者（TC）报告预留的操作结果。</li></ul></li><li><p><strong>事务协调方（TC）</strong>：</p><ul><li>事务协调方接收来自发起方的 Try 请求，并记录该请求的结果。TC 不做实际的业务操作，只是协调各个发起方的事务状态。</li></ul></li><li><p><strong>事务管理者（TM）</strong>：</p><ul><li>事务管理者负责发起整个分布式事务，并向事务协调方发出事务请求。TM 会跟踪事务的生命周期，协调各个参与者的工作。</li></ul></li></ul><h4 id="_2-confirm-阶段" tabindex="-1"><a class="header-anchor" href="#_2-confirm-阶段"><span>2. <strong>Confirm 阶段</strong></span></a></h4><ul><li><p><strong>事务发起方（RM）</strong>：</p><ul><li>在 Confirm 阶段，发起方会正式提交之前预留的操作，通常是实际的业务执行（例如：实际减库存，确认操作）。</li><li>确认时，发起方将提交事务并向事务协调方报告确认结果。</li></ul></li><li><p><strong>事务协调方（TC）</strong>：</p><ul><li>事务协调方负责判断所有参与者的事务状态。如果所有参与者都报告了成功的 Try 阶段，并且在 Confirm 阶段也成功提交，则事务协调方会最终提交事务。</li></ul></li><li><p><strong>事务管理者（TM）</strong>：</p><ul><li>事务管理者协调整个事务的最终状态，在确认阶段，TM 会收到所有参与者的确认请求并最终决定事务是否提交。</li></ul></li></ul><h4 id="_3-cancel-阶段" tabindex="-1"><a class="header-anchor" href="#_3-cancel-阶段"><span>3. <strong>Cancel 阶段</strong></span></a></h4><ul><li><p><strong>事务发起方（RM）</strong>：</p><ul><li>如果在 Try 阶段成功预留了资源，但事务在后续步骤中失败或被要求取消，发起方将执行回滚操作，撤销之前的预留资源。</li><li>例如：库存恢复、订单撤销等。</li></ul></li><li><p><strong>事务协调方（TC）</strong>：</p><ul><li>事务协调方根据事务的最终状态决定是否触发 Cancel 阶段。如果事务的某个参与者报告失败或不满足条件，TC 会触发 Cancel 阶段来回滚事务。</li></ul></li><li><p><strong>事务管理者（TM）</strong>：</p><ul><li>事务管理者会在事务失败时指引进入 Cancel 阶段，确保参与者回滚已做的操作。</li></ul></li></ul><h4 id="总结-2" tabindex="-1"><a class="header-anchor" href="#总结-2"><span>总结</span></a></h4><ul><li><strong>Try 阶段</strong>：预留资源，确保操作可回滚或确认；</li><li><strong>Confirm 阶段</strong>：确认资源并提交操作；</li><li><strong>Cancel 阶段</strong>：回滚操作，撤销所有预留资源。</li></ul><h3 id="_3-2空回滚" tabindex="-1"><a class="header-anchor" href="#_3-2空回滚"><span>3.2空回滚</span></a></h3><p>某一个RM在一阶段阻塞导致全局事务在二阶段超时触发cancel，此RM未执行完try去执行cancel，此时的cancel没东西做回滚就是空回滚。</p><h3 id="_3-3事务悬挂" tabindex="-1"><a class="header-anchor" href="#_3-3事务悬挂"><span>3.3事务悬挂</span></a></h3><p>一个已经空回滚的事务，阻塞的try突然畅通，但是无法再有下一步操作，导致事务无法正常结束</p><h2 id="_4-sega-模式" tabindex="-1"><a class="header-anchor" href="#_4-sega-模式"><span>4.SEGA 模式</span></a></h2><p><strong>SEGA（SAGA）</strong> 是一种分布式事务的模式，采用了一系列本地事务和补偿事务来保证最终一致性。SAGA 模式将一个大事务拆分成多个小的本地事务，每个小事务独立执行。如果某个事务失败，就通过执行补偿事务来回滚前面的操作。</p><ul><li><strong>特点</strong>: <ul><li>每个子事务独立执行，可以在分布式环境下实现高可用性。</li><li>通过补偿机制确保最终一致性，适用于长事务。</li><li>支持多种实现方式，例如补偿型 SAGA 和基于消息的 SAGA。</li></ul></li><li><strong>缺点</strong>: <ul><li>较复杂的补偿逻辑实现，可能导致业务逻辑不易维护。</li><li>需要保证每个子事务和补偿事务的幂等性。</li></ul></li></ul><h2 id="总结-3" tabindex="-1"><a class="header-anchor" href="#总结-3"><span>总结：</span></a></h2><ul><li><strong>XA</strong>：保证强一致性的分布式事务，适用于需要多资源管理器协调的场景，但性能开销较大。</li><li><strong>AT</strong>：轻量级自动事务管理，简化开发，但不适合复杂事务。</li><li><strong>TCC</strong>：精细化的三阶段事务模式，通过补偿机制保证一致性，适用于业务逻辑清晰的场景。</li><li><strong>SAGA</strong>：通过一系列本地事务和补偿事务来保证最终一致性，适用于长事务和高可用场景。</li></ul><blockquote><p>XA模式下RM准备好了报告TC后，TC批准再干，不让干不干。</p><p>AT模式下RM记小本本上直接干，TC说干的不行再看小本本干回去，干的好就保留。</p><p>TCC模式下RM先从一堆苹果中护下几个，TC说可以拿了就拿走，不可以拿就放回去。类似银行卡的预授权。</p></blockquote>',29))])}]]),t=JSON.parse('{"path":"/SpringCloud/%E9%AB%98%E7%BA%A7/Seata/%E5%9B%9B%E7%A7%8D%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%A8%A1%E5%BC%8F.html","title":"四种分布式事务模式","lang":"zh-CN","frontmatter":{"icon":"fa-solid fa-web-awesome","date":"2025-02-25T00:00:00.000Z","category":["SpringCloud高级篇"],"tag":["Seata","分布式事务","微服务"],"gitInclude":[]},"headers":[{"level":2,"title":"1. XA 模式","slug":"_1-xa-模式","link":"#_1-xa-模式","children":[{"level":3,"title":"1.1 概念","slug":"_1-1-概念","link":"#_1-1-概念","children":[]},{"level":3,"title":"1.2 两阶段提交","slug":"_1-2-两阶段提交","link":"#_1-2-两阶段提交","children":[]},{"level":3,"title":"1.3缺点:","slug":"_1-3缺点","link":"#_1-3缺点","children":[]}]},{"level":2,"title":"2. AT 模式","slug":"_2-at-模式","link":"#_2-at-模式","children":[{"level":3,"title":"2.1 概念","slug":"_2-1-概念","link":"#_2-1-概念","children":[]},{"level":3,"title":"2.2两阶段提交","slug":"_2-2两阶段提交","link":"#_2-2两阶段提交","children":[]},{"level":3,"title":"2.3 简述AT模式与XA模式最大的区别是什么？","slug":"_2-3-简述at模式与xa模式最大的区别是什么","link":"#_2-3-简述at模式与xa模式最大的区别是什么","children":[]},{"level":3,"title":"2.4缺点","slug":"_2-4缺点","link":"#_2-4缺点","children":[]}]},{"level":2,"title":"3.TCC 模式","slug":"_3-tcc-模式","link":"#_3-tcc-模式","children":[{"level":3,"title":"3.1三个阶段","slug":"_3-1三个阶段","link":"#_3-1三个阶段","children":[]},{"level":3,"title":"3.2空回滚","slug":"_3-2空回滚","link":"#_3-2空回滚","children":[]},{"level":3,"title":"3.3事务悬挂","slug":"_3-3事务悬挂","link":"#_3-3事务悬挂","children":[]}]},{"level":2,"title":"4.SEGA 模式","slug":"_4-sega-模式","link":"#_4-sega-模式","children":[]},{"level":2,"title":"总结：","slug":"总结-3","link":"#总结-3","children":[]}],"readingTime":{"minutes":9.53,"words":2859},"filePathRelative":"SpringCloud/高级/Seata/四种分布式事务模式.md","localizedDate":"2025年2月25日","excerpt":"\\n<h2>1. XA 模式</h2>\\n<h3>1.1 概念</h3>\\n<p><strong>XA（eXtended Architecture）</strong> 是一种分布式事务协议，通常用于支持跨多个资源管理器（如数据库、消息队列等）的事务。</p>\\n<ul>\\n<li><strong>特点</strong>:\\n<ul>\\n<li>使用两阶段提交协议（2PC）来保证事务的一致性。</li>\\n<li>保证所有参与的资源管理器在同一个事务中要么都成功提交，要么都回滚。</li>\\n<li>对于涉及多个资源管理器的事务，XA 协议能够提供强一致性。</li>\\n</ul>\\n</li>\\n</ul>\\n<blockquote>\\n<p>XA模式下RM由数据库提供</p>\\n</blockquote>"}')}}]);