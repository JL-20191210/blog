"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[76164],{66262:(i,s)=>{s.A=(i,s)=>{const a=i.__vccOpts||i;for(const[i,n]of s)a[i]=n;return a}},22132:(i,s,a)=>{a.r(s),a.d(s,{comp:()=>l,data:()=>t});var n=a(20641);const e=a.p+"assets/img/image-20250903214741304.c2fe3d20.png",h={},l=(0,a(66262).A)(h,[["render",function(i,s){return(0,n.uX)(),(0,n.CE)("div",null,s[0]||(s[0]=[(0,n.Fv)('<h1 id="java" tabindex="-1"><a class="header-anchor" href="#java"><span>Java</span></a></h1><h2 id="java集合" tabindex="-1"><a class="header-anchor" href="#java集合"><span>Java集合</span></a></h2><ol><li><p>线程安全的集合有哪些？</p><figure><img src="'+e+'" alt="image-20250903214741304" tabindex="0" loading="lazy"><figcaption>image-20250903214741304</figcaption></figure></li></ol><h2 id="多线程" tabindex="-1"><a class="header-anchor" href="#多线程"><span>多线程</span></a></h2><h4 id="_1-守护线程了解吗" tabindex="-1"><a class="header-anchor" href="#_1-守护线程了解吗"><span>1.守护线程了解吗？</span></a></h4><p>守护线程是一种特殊的线程，它的作用是为其他线程提供服务。</p><p>Java 中的线程分为两类，一种是守护线程，另外一种是用户线程。</p><p>JVM 启动时会调用 main 方法，main 方法所在的线程就是一个用户线程。在 JVM 内部，同时还启动了很多守护线程，比如垃圾回收线程。</p><h4 id="_2-守护线程和用户线程有什么区别呢" tabindex="-1"><a class="header-anchor" href="#_2-守护线程和用户线程有什么区别呢"><span>2. 守护线程和用户线程有什么区别呢？</span></a></h4><p>区别之一是当最后一个非守护线程束时， JVM 会正常退出，不管当前是否存在守护线程，也就是说守护线程是否结束并不影响 JVM 退出。</p><p>换而言之，只要有一个用户线程还没结束，正常情况下 JVM 就不会退出。</p><h3 id="_26-synchronized-用过吗" tabindex="-1"><a class="header-anchor" href="#_26-synchronized-用过吗"><span>26.synchronized 用过吗？</span></a></h3><p>用过，频率还很高。</p><p>synchronized 在 JDK 1.6 之后，进行了锁优化，增加了偏向锁、轻量级锁，大大提升了 synchronized 的性能。</p><h4 id="synchronized-上锁的对象是什么" tabindex="-1"><a class="header-anchor" href="#synchronized-上锁的对象是什么"><span>synchronized 上锁的对象是什么？</span></a></h4><p>synchronized 用在普通方法上时，上锁的是执行这个方法的对象。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> synchronized</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> increment</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">() {</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">    this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">count</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">++;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>synchronized 用在静态方法上时，上锁的是这个类的 Class 对象。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> synchronized</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> increment</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">() {</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    count</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">++;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>synchronized 用在代码块上时，上锁的是括号中指定的对象，比如说当前对象 this。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> increment</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">() {</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    synchronized</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">this</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">count</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">++;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',21)]))}]]),t=JSON.parse('{"path":"/Interview/Java/%E7%83%AD%E7%82%B9%E9%9D%A2%E8%AF%95%E9%A2%98/%E7%83%AD%E7%82%B9%E9%9D%A2%E8%AF%95%E9%A2%98.html","title":"Java","lang":"zh-CN","frontmatter":{"gitInclude":[]},"headers":[{"level":2,"title":"Java集合","slug":"java集合","link":"#java集合","children":[]},{"level":2,"title":"多线程","slug":"多线程","link":"#多线程","children":[{"level":3,"title":"26.synchronized 用过吗？","slug":"_26-synchronized-用过吗","link":"#_26-synchronized-用过吗","children":[]}]}],"readingTime":{"minutes":1.23,"words":370},"filePathRelative":"Interview/Java/热点面试题/热点面试题.md","excerpt":"\\n<h2>Java集合</h2>\\n<ol>\\n<li>\\n<p>线程安全的集合有哪些？</p>\\n<figure><figcaption>image-20250903214741304</figcaption></figure>\\n</li>\\n</ol>\\n<h2>多线程</h2>\\n<h4>1.守护线程了解吗？</h4>\\n<p>守护线程是一种特殊的线程，它的作用是为其他线程提供服务。</p>\\n<p>Java 中的线程分为两类，一种是守护线程，另外一种是用户线程。</p>\\n<p>JVM 启动时会调用 main 方法，main 方法所在的线程就是一个用户线程。在 JVM 内部，同时还启动了很多守护线程，比如垃圾回收线程。</p>"}')}}]);