"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[97276],{66262:(i,s)=>{s.A=(i,s)=>{const a=i.__vccOpts||i;for(const[i,l]of s)a[i]=l;return a}},73639:(i,s,a)=>{a.r(s),a.d(s,{comp:()=>t,data:()=>e});var l=a(20641);const n={},t=(0,a(66262).A)(n,[["render",function(i,s){return(0,l.uX)(),(0,l.CE)("div",null,s[0]||(s[0]=[(0,l.Fv)('<hr><p>title: JVM 系列博客文档结构与索引 date: 2025-07-04 categories:</p><ul><li>JVM</li><li>博客专栏</li><li>学习路线</li></ul><hr><h1 id="📚-jvm-系列博客文档结构与索引" tabindex="-1"><a class="header-anchor" href="#📚-jvm-系列博客文档结构与索引"><span>📚 JVM 系列博客文档结构与索引</span></a></h1><p>本系列系统性地整理了 JVM 的底层原理、运行机制、性能调优等关键主题，适用于 Java 中高级开发者进阶学习、技术博客写作或备战面试使用。</p><hr><h2 id="📁-1-jvm-架构与类加载" tabindex="-1"><a class="header-anchor" href="#📁-1-jvm-架构与类加载"><span>📁 1. JVM 架构与类加载</span></a></h2><h3 id="_1-3-《类的初始化与加载的触发条件》" tabindex="-1"><a class="header-anchor" href="#_1-3-《类的初始化与加载的触发条件》"><span>1.3 《类的初始化与加载的触发条件》</span></a></h3><hr><h3 id="🚀-初始化是类加载生命周期的最后一步" tabindex="-1"><a class="header-anchor" href="#🚀-初始化是类加载生命周期的最后一步"><span>🚀 初始化是类加载生命周期的最后一步</span></a></h3><p>类的初始化阶段，是 JVM 将类的静态变量赋予初始值并执行 <code>&lt;clinit&gt;</code> 静态代码块的过程。它确保类在使用前是安全可用的。</p><hr><h3 id="⚙️-初始化执行内容" tabindex="-1"><a class="header-anchor" href="#⚙️-初始化执行内容"><span>⚙️ 初始化执行内容</span></a></h3><ul><li>为 <code>static</code> 静态变量赋初值（非默认值）</li><li>执行类中静态初始化块 <code>static {}</code></li></ul><h4 id="示例" tabindex="-1"><a class="header-anchor" href="#示例"><span>示例：</span></a></h4><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> InitDemo</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> a </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> init</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    static</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> {</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;静态代码块执行&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> init</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;静态变量赋值执行&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 10</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>静态变量赋值执行</span></span>\n<span class="line"><span>静态代码块执行</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><hr><h3 id="🔍-哪些操作会触发类的初始化" tabindex="-1"><a class="header-anchor" href="#🔍-哪些操作会触发类的初始化"><span>🔍 哪些操作会触发类的初始化？</span></a></h3><table><thead><tr><th>触发方式</th><th>示例</th><th>是否触发初始化</th></tr></thead><tbody><tr><td>new 对象</td><td><code>new A()</code></td><td>✅ 是</td></tr><tr><td>访问静态变量（非 final）</td><td><code>A.value</code></td><td>✅ 是</td></tr><tr><td>调用静态方法</td><td><code>A.method()</code></td><td>✅ 是</td></tr><tr><td>反射调用类</td><td><code>Class.forName(&quot;A&quot;)</code></td><td>✅ 是</td></tr><tr><td>主类启动</td><td><code>public static void main()</code></td><td>✅ 是</td></tr></tbody></table><hr><h3 id="🔍-哪些操作不会触发初始化" tabindex="-1"><a class="header-anchor" href="#🔍-哪些操作不会触发初始化"><span>🔍 哪些操作<strong>不会</strong>触发初始化？</span></a></h3><table><thead><tr><th>场景</th><th>示例</th><th>初始化？</th></tr></thead><tbody><tr><td>访问常量（final static）</td><td><code>System.out.println(A.CONST)</code></td><td>❌ 否</td></tr><tr><td>使用数组定义</td><td><code>A[] array = new A[10]</code></td><td>❌ 否</td></tr><tr><td>ClassLoader.loadClass()</td><td><code>loadClass(&quot;A&quot;)</code></td><td>❌ 否</td></tr></tbody></table><p>📌 JVM 会对 final 常量做 <strong>编译期内联优化</strong>，因此不触发初始化。</p><hr><h3 id="🔁-初始化与父类的关系" tabindex="-1"><a class="header-anchor" href="#🔁-初始化与父类的关系"><span>🔁 初始化与父类的关系</span></a></h3><p>当子类初始化时，<strong>会先初始化父类</strong>。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Parent</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    static</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> {</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;父类初始化&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Child</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> extends</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Parent</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    static</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> {</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;子类初始化&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行：<code>new Child()</code>，输出：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>父类初始化</span></span>\n<span class="line"><span>子类初始化</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><hr><h3 id="✅-小测试示例" tabindex="-1"><a class="header-anchor" href="#✅-小测试示例"><span>✅ 小测试示例</span></a></h3><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> ConstTest</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> final</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> CONST </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 123</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    static</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> {</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;ConstTest 初始化&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> TestInit</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> main</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[] </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">args</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">ConstTest</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">CONST</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">); </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// ❌ 不触发</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出：<code>123</code></p><p><strong>类未初始化。</strong> JVM 直接把 <code>CONST</code> 编译成常量放入调用类的常量池中。</p><hr><h3 id="📌-面试必问点" tabindex="-1"><a class="header-anchor" href="#📌-面试必问点"><span>📌 面试必问点</span></a></h3><ol><li>类的初始化阶段做了哪些操作？</li><li>哪些行为会触发类初始化，哪些不会？</li><li><code>Class.forName()</code> 和 <code>ClassLoader.loadClass()</code> 区别？</li><li>子类初始化前是否一定会初始化父类？为什么？</li></ol><hr><h3 id="📝-小结" tabindex="-1"><a class="header-anchor" href="#📝-小结"><span>📝 小结</span></a></h3><ul><li>类的初始化是 JVM 类生命周期中唯一可控阶段</li><li>初始化只会执行一次，静态代码块与静态变量的顺序由源代码决定</li><li>掌握初始化机制有助于优化启动性能与避免意外行为</li></ul><hr><p>👉 下一篇推荐阅读：<a href="https://chatgpt.com/c/6865ecec-fbc4-800b-952b-a391340aecbc#" target="_blank" rel="noopener noreferrer">2.1 JVM 内存结构详解（堆、栈、方法区等）</a></p><hr><h2 id="📁-2-内存结构与并发内存模型" tabindex="-1"><a class="header-anchor" href="#📁-2-内存结构与并发内存模型"><span>📁 2. 内存结构与并发内存模型</span></a></h2><h3 id="_2-1-《jvm-内存结构详解-堆、栈、方法区等-》" tabindex="-1"><a class="header-anchor" href="#_2-1-《jvm-内存结构详解-堆、栈、方法区等-》"><span>2.1 《JVM 内存结构详解（堆、栈、方法区等）》</span></a></h3><hr><h3 id="🧠-jvm-内存结构分区概览" tabindex="-1"><a class="header-anchor" href="#🧠-jvm-内存结构分区概览"><span>🧠 JVM 内存结构分区概览</span></a></h3><p>JVM 在运行时会将内存划分为若干个逻辑区域，每个区域负责不同的功能，统一称为“运行时数据区”。理解这些区域是掌握 GC、线程隔离、性能调优的基础。</p><hr><h3 id="📦-jvm-内存结构组成-java-8" tabindex="-1"><a class="header-anchor" href="#📦-jvm-内存结构组成-java-8"><span>📦 JVM 内存结构组成（Java 8+）</span></a></h3><table><thead><tr><th>区域</th><th>线程共享</th><th>说明</th></tr></thead><tbody><tr><td>程序计数器</td><td>否</td><td>当前线程正在执行的字节码行号指示器</td></tr><tr><td>Java 虚拟机栈</td><td>否</td><td>方法调用的栈帧、局部变量表、操作数栈等</td></tr><tr><td>本地方法栈</td><td>否</td><td>执行 native 方法所使用的栈</td></tr><tr><td>堆（Heap）</td><td>是</td><td>存放对象实例，GC 的主要区域</td></tr><tr><td>方法区（元空间 Metaspace）</td><td>是</td><td>存放类元信息、静态变量、常量池</td></tr></tbody></table><hr><h3 id="🔹-1-程序计数器" tabindex="-1"><a class="header-anchor" href="#🔹-1-程序计数器"><span>🔹 1. 程序计数器</span></a></h3><ul><li>每个线程独立拥有，线程私有</li><li>用于记录当前线程执行的 JVM 指令地址</li><li>不会发生内存溢出（OutOfMemoryError）</li></ul><hr><h3 id="🔹-2-java-虚拟机栈" tabindex="-1"><a class="header-anchor" href="#🔹-2-java-虚拟机栈"><span>🔹 2. Java 虚拟机栈</span></a></h3><ul><li>每个线程私有，生命周期与线程一致</li><li>每个方法调用都会创建一个栈帧（Stack Frame）</li><li>栈帧包括：局部变量表、操作数栈、方法返回地址等</li></ul><p>📌 报错案例：</p><ul><li><code>StackOverflowError</code>：方法递归太深</li><li><code>OutOfMemoryError</code>：栈内存过小或线程数太多</li></ul><hr><h3 id="🔹-3-本地方法栈" tabindex="-1"><a class="header-anchor" href="#🔹-3-本地方法栈"><span>🔹 3. 本地方法栈</span></a></h3><ul><li>与虚拟机栈类似，但用于执行 native 方法</li><li>使用的是 JVM 所依赖的 C 库函数栈结构</li><li>同样会抛出 <code>StackOverflowError</code>、<code>OutOfMemoryError</code></li></ul><hr><h3 id="🔹-4-堆-heap" tabindex="-1"><a class="header-anchor" href="#🔹-4-堆-heap"><span>🔹 4. 堆（Heap）</span></a></h3><ul><li>所有线程共享</li><li>JVM 中最大的一块内存区域</li><li>用于存放对象实例、数组、常量池运行时引用</li></ul><p>堆通常分为两个逻辑分区：</p><ul><li>年轻代（Young Generation） <ul><li>Eden（伊甸园）</li><li>Survivor（幸存区）</li></ul></li><li>老年代（Old Generation）</li></ul><p>📌 报错案例：</p><ul><li><code>OutOfMemoryError: Java heap space</code></li></ul><hr><h3 id="🔹-5-方法区-元空间" tabindex="-1"><a class="header-anchor" href="#🔹-5-方法区-元空间"><span>🔹 5. 方法区（元空间）</span></a></h3><ul><li>所有线程共享</li><li>存放类的结构信息（元数据）、常量、静态变量等</li><li>Java 8 后移除永久代（PermGen），改为使用元空间（Metaspace）</li><li>元空间存储在本地内存（native memory）中</li></ul><p>📌 报错案例：</p><ul><li><code>OutOfMemoryError: Metaspace</code></li></ul><hr><h3 id="🔎-对比-jvm-栈-vs-堆" tabindex="-1"><a class="header-anchor" href="#🔎-对比-jvm-栈-vs-堆"><span>🔎 对比：JVM 栈 vs 堆</span></a></h3><table><thead><tr><th>对比项</th><th>栈</th><th>堆</th></tr></thead><tbody><tr><td>管理者</td><td>JVM 自动创建/销毁</td><td>JVM 统一管理，GC 回收</td></tr><tr><td>生命周期</td><td>与线程绑定</td><td>与对象引用计数有关</td></tr><tr><td>存储内容</td><td>方法调用、局部变量</td><td>对象实例与数组</td></tr><tr><td>内存大小</td><td>通常较小</td><td>通常较大</td></tr><tr><td>常见异常</td><td>StackOverflowError</td><td>OutOfMemoryError</td></tr></tbody></table><hr><h3 id="✅-示例分析" tabindex="-1"><a class="header-anchor" href="#✅-示例分析"><span>✅ 示例分析</span></a></h3><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> MemoryTest</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    static</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> String</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> staticStr </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;JVM&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 方法区</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> main</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[] </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">args</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> a</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;            </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 栈（局部变量）</span></span>\n<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        String</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> s</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> String</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;Heap&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">); </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 堆</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(staticStr </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> s);</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h3 id="📌-面试重点问题" tabindex="-1"><a class="header-anchor" href="#📌-面试重点问题"><span>📌 面试重点问题</span></a></h3><ol><li>JVM 内存结构有哪些区域？哪些是线程共享的？</li><li>JVM 为什么要将堆划分为新生代和老年代？</li><li>PermGen 和 Metaspace 有什么区别？</li><li>栈溢出和堆溢出有什么区别？</li></ol><hr><h3 id="📝-小结-1" tabindex="-1"><a class="header-anchor" href="#📝-小结-1"><span>📝 小结</span></a></h3><ul><li>JVM 内存结构清晰划分了多种逻辑区域</li><li>理解这些区域有助于深入掌握 GC 机制与性能调优</li><li>掌握各区域的作用与异常类型，是 Java 面试高频考点</li></ul><hr><p>👉 下一篇推荐阅读：<a href="https://chatgpt.com/c/6865ecec-fbc4-800b-952b-a391340aecbc#" target="_blank" rel="noopener noreferrer">2.2 Java 内存模型 JMM 与 happens-before 原则</a></p><hr><h2 id="📁-3-gc-垃圾回收机制" tabindex="-1"><a class="header-anchor" href="#📁-3-gc-垃圾回收机制"><span>📁 3. GC 垃圾回收机制</span></a></h2><ul><li></li></ul><hr><h2 id="📁-4-jvm-性能调优与监控工具" tabindex="-1"><a class="header-anchor" href="#📁-4-jvm-性能调优与监控工具"><span>📁 4. JVM 性能调优与监控工具</span></a></h2><ul><li></li></ul><hr><h2 id="📁-5-面试题、总结与一图流" tabindex="-1"><a class="header-anchor" href="#📁-5-面试题、总结与一图流"><span>📁 5. 面试题、总结与一图流</span></a></h2><ul><li></li></ul><hr><h2 id="📌-写作建议" tabindex="-1"><a class="header-anchor" href="#📌-写作建议"><span>📌 写作建议</span></a></h2><ul><li>每篇博客包含：概念解释 + 图示结构 + 示例代码 + 经典问题 + 实战技巧</li><li>支持 Markdown / Obsidian / GitBook 导出</li><li>推荐添加分类标签：JVM、调优、GC、内存模型、性能、面试</li></ul><hr><p>下一步建议：</p><ul><li>选择任意一篇开始生成内容（如 <code>1.2 类加载机制详解</code>）</li><li>或我每次帮你输出 1 篇内容逐步丰富知识库</li></ul>',106)]))}]]),e=JSON.parse('{"path":"/JVM/%E4%B8%93%E6%A0%8F%E5%90%88%E9%9B%86/JVM%20%E7%B3%BB%E5%88%97%E5%8D%9A%E5%AE%A2.html","title":"📚 JVM 系列博客文档结构与索引","lang":"zh-CN","frontmatter":{"gitInclude":[]},"headers":[{"level":2,"title":"📁 1. JVM 架构与类加载","slug":"📁-1-jvm-架构与类加载","link":"#📁-1-jvm-架构与类加载","children":[{"level":3,"title":"1.3 《类的初始化与加载的触发条件》","slug":"_1-3-《类的初始化与加载的触发条件》","link":"#_1-3-《类的初始化与加载的触发条件》","children":[]},{"level":3,"title":"🚀 初始化是类加载生命周期的最后一步","slug":"🚀-初始化是类加载生命周期的最后一步","link":"#🚀-初始化是类加载生命周期的最后一步","children":[]},{"level":3,"title":"⚙️ 初始化执行内容","slug":"⚙️-初始化执行内容","link":"#⚙️-初始化执行内容","children":[]},{"level":3,"title":"🔍 哪些操作会触发类的初始化？","slug":"🔍-哪些操作会触发类的初始化","link":"#🔍-哪些操作会触发类的初始化","children":[]},{"level":3,"title":"🔍 哪些操作不会触发初始化？","slug":"🔍-哪些操作不会触发初始化","link":"#🔍-哪些操作不会触发初始化","children":[]},{"level":3,"title":"🔁 初始化与父类的关系","slug":"🔁-初始化与父类的关系","link":"#🔁-初始化与父类的关系","children":[]},{"level":3,"title":"✅ 小测试示例","slug":"✅-小测试示例","link":"#✅-小测试示例","children":[]},{"level":3,"title":"📌 面试必问点","slug":"📌-面试必问点","link":"#📌-面试必问点","children":[]},{"level":3,"title":"📝 小结","slug":"📝-小结","link":"#📝-小结","children":[]}]},{"level":2,"title":"📁 2. 内存结构与并发内存模型","slug":"📁-2-内存结构与并发内存模型","link":"#📁-2-内存结构与并发内存模型","children":[{"level":3,"title":"2.1 《JVM 内存结构详解（堆、栈、方法区等）》","slug":"_2-1-《jvm-内存结构详解-堆、栈、方法区等-》","link":"#_2-1-《jvm-内存结构详解-堆、栈、方法区等-》","children":[]},{"level":3,"title":"🧠 JVM 内存结构分区概览","slug":"🧠-jvm-内存结构分区概览","link":"#🧠-jvm-内存结构分区概览","children":[]},{"level":3,"title":"📦 JVM 内存结构组成（Java 8+）","slug":"📦-jvm-内存结构组成-java-8","link":"#📦-jvm-内存结构组成-java-8","children":[]},{"level":3,"title":"🔹 1. 程序计数器","slug":"🔹-1-程序计数器","link":"#🔹-1-程序计数器","children":[]},{"level":3,"title":"🔹 2. Java 虚拟机栈","slug":"🔹-2-java-虚拟机栈","link":"#🔹-2-java-虚拟机栈","children":[]},{"level":3,"title":"🔹 3. 本地方法栈","slug":"🔹-3-本地方法栈","link":"#🔹-3-本地方法栈","children":[]},{"level":3,"title":"🔹 4. 堆（Heap）","slug":"🔹-4-堆-heap","link":"#🔹-4-堆-heap","children":[]},{"level":3,"title":"🔹 5. 方法区（元空间）","slug":"🔹-5-方法区-元空间","link":"#🔹-5-方法区-元空间","children":[]},{"level":3,"title":"🔎 对比：JVM 栈 vs 堆","slug":"🔎-对比-jvm-栈-vs-堆","link":"#🔎-对比-jvm-栈-vs-堆","children":[]},{"level":3,"title":"✅ 示例分析","slug":"✅-示例分析","link":"#✅-示例分析","children":[]},{"level":3,"title":"📌 面试重点问题","slug":"📌-面试重点问题","link":"#📌-面试重点问题","children":[]},{"level":3,"title":"📝 小结","slug":"📝-小结-1","link":"#📝-小结-1","children":[]}]},{"level":2,"title":"📁 3. GC 垃圾回收机制","slug":"📁-3-gc-垃圾回收机制","link":"#📁-3-gc-垃圾回收机制","children":[]},{"level":2,"title":"📁 4. JVM 性能调优与监控工具","slug":"📁-4-jvm-性能调优与监控工具","link":"#📁-4-jvm-性能调优与监控工具","children":[]},{"level":2,"title":"📁 5. 面试题、总结与一图流","slug":"📁-5-面试题、总结与一图流","link":"#📁-5-面试题、总结与一图流","children":[]},{"level":2,"title":"📌 写作建议","slug":"📌-写作建议","link":"#📌-写作建议","children":[]}],"readingTime":{"minutes":5.35,"words":1604},"filePathRelative":"JVM/专栏合集/JVM 系列博客.md","excerpt":"<hr>\\n<p>title: JVM 系列博客文档结构与索引\\ndate: 2025-07-04\\ncategories:</p>\\n<ul>\\n<li>JVM</li>\\n<li>博客专栏</li>\\n<li>学习路线</li>\\n</ul>\\n<hr>\\n<h1>📚 JVM 系列博客文档结构与索引</h1>\\n<p>本系列系统性地整理了 JVM 的底层原理、运行机制、性能调优等关键主题，适用于 Java 中高级开发者进阶学习、技术博客写作或备战面试使用。</p>\\n<hr>\\n<h2>📁 1. JVM 架构与类加载</h2>\\n<h3>1.3 《类的初始化与加载的触发条件》</h3>\\n<hr>\\n<h3>🚀 初始化是类加载生命周期的最后一步</h3>"}')}}]);