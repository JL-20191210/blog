"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[57045],{66262:(t,d)=>{d.A=(t,d)=>{const n=t.__vccOpts||t;for(const[t,e]of d)n[t]=e;return n}},1502:(t,d,n)=>{n.r(d),n.d(d,{comp:()=>i,data:()=>r});var e=n(20641);const a={},i=(0,n(66262).A)(a,[["render",function(t,d){return(0,e.uX)(),(0,e.CE)("div",null,d[0]||(d[0]=[(0,e.Fv)('<h1 id="🔍-3-2-cms、g1、zgc、shenandoah-对比详解" tabindex="-1"><a class="header-anchor" href="#🔍-3-2-cms、g1、zgc、shenandoah-对比详解"><span>🔍 3.2 CMS、G1、ZGC、Shenandoah 对比详解</span></a></h1><p>本篇将深入比较四大现代垃圾回收器：<strong>CMS、G1、ZGC、Shenandoah</strong>，它们是 Java 在不同版本中主推的低延迟或并发收集器，适用于不同规模与场景的后端系统。</p><hr><h2 id="🚀-概览对比表" tabindex="-1"><a class="header-anchor" href="#🚀-概览对比表"><span>🚀 概览对比表</span></a></h2><table><thead><tr><th>特性</th><th>CMS</th><th>G1</th><th>ZGC</th><th>Shenandoah</th></tr></thead><tbody><tr><td>引入版本</td><td>JDK 5</td><td>JDK 7u4</td><td>JDK 11（生产）</td><td>JDK 12（实验）</td></tr><tr><td>收集目标</td><td>低停顿</td><td>停顿+吞吐均衡</td><td>极低停顿</td><td>极低停顿</td></tr><tr><td>并发标记</td><td>✅</td><td>✅</td><td>✅</td><td>✅</td></tr><tr><td>并发整理</td><td>❌（Stop-the-world）</td><td>✅</td><td>✅</td><td>✅</td></tr><tr><td>区域模型</td><td>分代</td><td>Region</td><td>Region（无分代）</td><td>Region（无分代）</td></tr><tr><td>最大堆支持</td><td>TB 级</td><td>TB 级</td><td>最大 16TB</td><td>最大 16TB</td></tr><tr><td>延迟控制能力</td><td>一般</td><td>中等</td><td>精细</td><td>精细</td></tr><tr><td>增量式并发回收</td><td>❌</td><td>✅</td><td>✅</td><td>✅</td></tr><tr><td>适合场景</td><td>老系统、过渡阶段</td><td>大多数中大型系统</td><td>极致延迟敏感系统</td><td>大型数据密集系统</td></tr></tbody></table><hr><h2 id="🧠-cms-concurrent-mark-sweep" tabindex="-1"><a class="header-anchor" href="#🧠-cms-concurrent-mark-sweep"><span>🧠 CMS（Concurrent Mark Sweep）</span></a></h2><ul><li><strong>特点</strong>：采用标记-清除算法，目标是降低老年代 GC 停顿</li><li><strong>分代类型</strong>：是（新生代使用复制，老年代使用标记清除）</li><li><strong>缺点</strong>： <ul><li>会产生空间碎片</li><li>CMS Initial Mark 和 Remark 阶段仍需停顿</li><li>已被 G1 在 JDK 9 后标记为 deprecated</li></ul></li></ul><p>📌 启用参数：</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">-XX:+UseConcMarkSweepGC</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><hr><h2 id="🌳-g1-garbage-first" tabindex="-1"><a class="header-anchor" href="#🌳-g1-garbage-first"><span>🌳 G1（Garbage First）</span></a></h2><ul><li><strong>特点</strong>：将堆划分为多个 Region，优先回收垃圾最多的 Region</li><li><strong>回收策略</strong>：并发标记 + 并发整理，平衡吞吐与延迟</li><li><strong>优势</strong>： <ul><li>没有明显的“新生代/老年代”边界</li><li>可通过参数设置最大停顿时间</li><li>更适用于大堆内存</li></ul></li></ul><p>📌 启用参数：</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">-XX:+UseG1GC</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">-XX:MaxGCPauseMillis</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">=200</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="⚡-zgc-z-garbage-collector" tabindex="-1"><a class="header-anchor" href="#⚡-zgc-z-garbage-collector"><span>⚡ ZGC（Z Garbage Collector）</span></a></h2><ul><li><strong>特点</strong>：低于 10ms 的停顿，支持超大内存（最高 16TB）</li><li><strong>核心机制</strong>：染色指针 + 并发阶段 + 内存重映射</li><li><strong>优势</strong>： <ul><li>停顿极短，与堆大小几乎无关</li><li>并发标记、并发移动对象，适合大型服务与游戏后端</li></ul></li></ul><p>📌 启用参数（JDK 17+）：</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">-XX:+UseZGC</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><hr><h2 id="🌊-shenandoah" tabindex="-1"><a class="header-anchor" href="#🌊-shenandoah"><span>🌊 Shenandoah</span></a></h2><ul><li><strong>特点</strong>：红帽贡献，强调低延迟，与 ZGC 类似但设计不同</li><li><strong>实现机制</strong>：并发标记 + 并发压缩（移动对象）</li><li><strong>亮点</strong>： <ul><li>几乎所有阶段都可并发执行</li><li>不依赖染色指针，兼容性更好</li></ul></li></ul><p>📌 启用参数（JDK 17+）：</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">-XX:+UseShenandoahGC</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><hr><h2 id="🔍-回收过程阶段对比" tabindex="-1"><a class="header-anchor" href="#🔍-回收过程阶段对比"><span>🔍 回收过程阶段对比</span></a></h2><table><thead><tr><th>阶段</th><th>CMS</th><th>G1</th><th>ZGC</th><th>Shenandoah</th></tr></thead><tbody><tr><td>初始标记</td><td>停顿</td><td>停顿</td><td>停顿</td><td>停顿</td></tr><tr><td>并发标记</td><td>✅</td><td>✅</td><td>✅</td><td>✅</td></tr><tr><td>最终标记</td><td>停顿</td><td>停顿</td><td>停顿</td><td>停顿</td></tr><tr><td>并发清理/整理</td><td>❌</td><td>✅</td><td>✅</td><td>✅</td></tr></tbody></table><hr><h2 id="📝-小结" tabindex="-1"><a class="header-anchor" href="#📝-小结"><span>📝 小结</span></a></h2><ul><li>CMS 已逐步退出主流，推荐使用 G1、ZGC、Shenandoah 替代</li><li>G1 是当前通用默认收集器，适用于大部分应用</li><li>ZGC 和 Shenandoah 更适合延迟敏感或内存超大场景</li><li>选择收集器需根据业务对响应时间、吞吐量的要求权衡</li></ul><hr><p>👉 下一篇推荐：<a href="https://chatgpt.com/c/6865ecec-fbc4-800b-952b-a391340aecbc#" target="_blank" rel="noopener noreferrer">3.3 GC 日志参数详解与案例分析</a></p>',33)]))}]]),r=JSON.parse('{"path":"/JVM/%E4%B8%93%E6%A0%8F%E5%90%88%E9%9B%86/3.GC%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/3.2%20CMS%E3%80%81G1%E3%80%81ZGC%E3%80%81Shenandoah%20%E5%AF%B9%E6%AF%94.html","title":"3.2 CMS、G1、ZGC、Shenandoah 对比详解","lang":"zh-CN","frontmatter":{"title":"3.2 CMS、G1、ZGC、Shenandoah 对比详解","icon":"fa-solid fa-broom-ball","date":"2025-07-10T00:00:00.000Z","author":"JeanHu","category":["JVM"],"tag":["JVM","GC","CMS","G1","ZGC","Shenandoah"],"summary":"本文全面对比了 Java 中几种主流垃圾回收器（CMS、G1、ZGC、Shenandoah）的原理、特点、适用场景与性能差异，帮助读者在实际项目中合理选型。","gitInclude":[]},"headers":[{"level":2,"title":"🚀 概览对比表","slug":"🚀-概览对比表","link":"#🚀-概览对比表","children":[]},{"level":2,"title":"🧠 CMS（Concurrent Mark Sweep）","slug":"🧠-cms-concurrent-mark-sweep","link":"#🧠-cms-concurrent-mark-sweep","children":[]},{"level":2,"title":"🌳 G1（Garbage First）","slug":"🌳-g1-garbage-first","link":"#🌳-g1-garbage-first","children":[]},{"level":2,"title":"⚡ ZGC（Z Garbage Collector）","slug":"⚡-zgc-z-garbage-collector","link":"#⚡-zgc-z-garbage-collector","children":[]},{"level":2,"title":"🌊 Shenandoah","slug":"🌊-shenandoah","link":"#🌊-shenandoah","children":[]},{"level":2,"title":"🔍 回收过程阶段对比","slug":"🔍-回收过程阶段对比","link":"#🔍-回收过程阶段对比","children":[]},{"level":2,"title":"📝 小结","slug":"📝-小结","link":"#📝-小结","children":[]}],"readingTime":{"minutes":2.57,"words":771},"filePathRelative":"JVM/专栏合集/3.GC 垃圾回收机制/3.2 CMS、G1、ZGC、Shenandoah 对比.md","localizedDate":"2025年7月10日","excerpt":"\\n<p>本篇将深入比较四大现代垃圾回收器：<strong>CMS、G1、ZGC、Shenandoah</strong>，它们是 Java 在不同版本中主推的低延迟或并发收集器，适用于不同规模与场景的后端系统。</p>\\n<hr>\\n<h2>🚀 概览对比表</h2>\\n<table>\\n<thead>\\n<tr>\\n<th>特性</th>\\n<th>CMS</th>\\n<th>G1</th>\\n<th>ZGC</th>\\n<th>Shenandoah</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>引入版本</td>\\n<td>JDK 5</td>\\n<td>JDK 7u4</td>\\n<td>JDK 11（生产）</td>\\n<td>JDK 12（实验）</td>\\n</tr>\\n<tr>\\n<td>收集目标</td>\\n<td>低停顿</td>\\n<td>停顿+吞吐均衡</td>\\n<td>极低停顿</td>\\n<td>极低停顿</td>\\n</tr>\\n<tr>\\n<td>并发标记</td>\\n<td>✅</td>\\n<td>✅</td>\\n<td>✅</td>\\n<td>✅</td>\\n</tr>\\n<tr>\\n<td>并发整理</td>\\n<td>❌（Stop-the-world）</td>\\n<td>✅</td>\\n<td>✅</td>\\n<td>✅</td>\\n</tr>\\n<tr>\\n<td>区域模型</td>\\n<td>分代</td>\\n<td>Region</td>\\n<td>Region（无分代）</td>\\n<td>Region（无分代）</td>\\n</tr>\\n<tr>\\n<td>最大堆支持</td>\\n<td>TB 级</td>\\n<td>TB 级</td>\\n<td>最大 16TB</td>\\n<td>最大 16TB</td>\\n</tr>\\n<tr>\\n<td>延迟控制能力</td>\\n<td>一般</td>\\n<td>中等</td>\\n<td>精细</td>\\n<td>精细</td>\\n</tr>\\n<tr>\\n<td>增量式并发回收</td>\\n<td>❌</td>\\n<td>✅</td>\\n<td>✅</td>\\n<td>✅</td>\\n</tr>\\n<tr>\\n<td>适合场景</td>\\n<td>老系统、过渡阶段</td>\\n<td>大多数中大型系统</td>\\n<td>极致延迟敏感系统</td>\\n<td>大型数据密集系统</td>\\n</tr>\\n</tbody>\\n</table>"}')}}]);