"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[14617],{66262:(i,s)=>{s.A=(i,s)=>{const a=i.__vccOpts||i;for(const[i,n]of s)a[i]=n;return a}},95681:(i,s,a)=>{a.r(s),a.d(s,{comp:()=>p,data:()=>r});var n=a(20641);const l=a.p+"assets/img/1713860588639-bb89fc8e-30b6-4d18-a329-f3fea52c729a-17485330387364.3296f137.png",t=a.p+"assets/img/image-20240725230247664.5d6f00fa.png",e=a.p+"assets/img/1715928000183-44fc6130-8abc-4f0b-8f6d-79de0ab09509.adc172ae.webp",h=a.p+"assets/img/数据类型-9526523.9eca7b6c.webp",k={},p=(0,a(66262).A)(k,[["render",function(i,s){return(0,n.uX)(),(0,n.CE)("div",null,s[0]||(s[0]=[(0,n.Fv)('<h1 id="java基础面试题" tabindex="-1"><a class="header-anchor" href="#java基础面试题"><span>Java基础面试题</span></a></h1><h2 id="概念" tabindex="-1"><a class="header-anchor" href="#概念"><span>概念</span></a></h2><h3 id="_1-说一下java的特点" tabindex="-1"><a class="header-anchor" href="#_1-说一下java的特点"><span>1.说一下Java的特点</span></a></h3><p>主要有以下的特点：</p><ul><li><strong>平台无关性</strong>：Java的“编写一次，运行无处不在&quot;哲学是其最大的特点之一。Java编译器将源代码编译成 字节码(bytecode)，该字节码可以在任何安装了Java虚拟机（JVM)的系统上运行。</li><li><strong>面向对象</strong>：Java是一门严格的面向对象编程语言，几乎一切都是对象。面向对象编程(OOP)特性使 得代码更易于维护和重用，包括类(class)、对象（object)、继承(inheritance)、多态 (polymorphism)、抽象（abstraction)和封装(encapsulation)。</li><li><strong>内存管理</strong>：Java有自己的垃圾回收机制，自动管理内存和回收不再使用的对象。这样，开发者不需要 手动管理内存，从而减少内存泄漏和其他内存相关的问题。</li></ul><h3 id="_2-java-的优势和劣势是什么" tabindex="-1"><a class="header-anchor" href="#_2-java-的优势和劣势是什么"><span>2.Java 的优势和劣势是什么？</span></a></h3><p>首先，Java的优势，我记得跨平台应该是一个大点，因为JVM的存在，一次编写到处运行。然后面向对象，这个可能也是优势，不过现在很多语言都支持面向对象，但是Java的设计从一开始就是OOP的。还有强大的生态系统，比如Spring框架，Hibernate，各种库和工具，社区支持大，企业应用广泛。另外，内存管理方面，自动垃圾回收制，减少了内存泄漏的问题，对开发者友好。还有多线程支持，内置的线程机制，方便并发编程。安全性方面，Java有安全模型，比如沙箱机制，适合网络环境。还有稳定性，企业级应用长期使用，版本更新也比较注重向后兼容。</p><p>劣势的话，性能可能是一个，虽然JVM优化了很多，但相比C++或者Rust这种原生编译语言，还是有一定开销。特别是启动时间，比如微服务场景下，可能不如GO之类的快。语法繁琐，比如样板代码多，之前没有lambda的时候更麻烦，现在有了但比起Python还是不够简洁。内存消耗，JVM本身占内存，对于资源有限的环境可能不太友好还有面向对象过于严格，有时候写简单程序反而麻烦，虽然Java8引入了函数式编程，但不如其他语言自然。还有开发效率，相比动态语言如Python，Java需要更多代码，编译过程也可能拖慢开发节奏。</p><h3 id="_3-java为什么是跨平台的" tabindex="-1"><a class="header-anchor" href="#_3-java为什么是跨平台的"><span>3.Java为什么是跨平台的？</span></a></h3><p>Java能支持跨平台，主要依赖于JVM关系比较大。</p><p>JVM也是一个软件，不同的平台有不同的版本。我们编写的Java源码，编译后会生成一种.class文件，称为字节码文件。Java虚拟机就是负责将字节码文件翻译成特定平台下的机器码然后运行。也就是说，只要在不同平台上安装对应的JVM，就可以运行字节码文件，运行我们编写的Java程序。</p><p>而这个过程中，我们编写的Java程序没有做任何改变，仅仅是通过JVM这一&quot;中间层”，就能在不同平台上运行，真正实现了&quot;一次编译，到处运行&quot;的目的。</p><p>JVM是一个&quot;桥梁&quot;，是一个&quot;中间件&quot;，是实现跨平台的关键，Java代码首先被编译成字节码文件，再由JVM将字节码文件翻译成机器语言，从而达到运行Java程序的目的。</p><p>编译的结果不是生成机器码，而是生成字节码，字节码不能直接运行，必须通过VM翻译成机器码才能运行。不同平台下编译生成的字节码是一样的，但是由JVM翻译成的机器码却不一样。</p><p>所以，运行Java程序必须有JVM的支持，因为编译的结果不是机器码，必须要经过JVM的再次翻译才能执行。即使你将Java程序打包成可执行文件（例如.exe），仍然需要VM的支持。</p><p>跨平台的是Java程序，不是JVM。JVM是用C/C++开发的，是编译后的机器码，不能跨平台，不同平台下需要安装不同版本的VM。</p><figure><img src="'+l+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h3 id="_4-jvm、jdk、jre三者关系" tabindex="-1"><a class="header-anchor" href="#_4-jvm、jdk、jre三者关系"><span>4. JVM、JDK、JRE三者关系？</span></a></h3><figure><img src="'+t+'" alt="image-20240725230247664" tabindex="0" loading="lazy"><figcaption>image-20240725230247664</figcaption></figure><p>它们之间的关系如下：</p><ul><li>JVM是Java虚拟机，是Java程序运行的环境。它负责将Java字节码（由Java编译器生成）解释或编译成 机器码，并执行程序。JVM提供了内存管理、垃圾回收、安全性等功能，使得Java程序具备跨平台性。</li><li>JRE是Java运行时环境，是Java程序运行所需的最小环境。它包含了JVM和一组Java类库，用于支持Java程序的执行。JRE不包含开发工具，只提供Java程序运行所需的运行环境。</li><li>JDK是Java开发工具包，是开发Java程序所需的工具集合。它包含了JVM、编译器(javac)、调试器（jdb)等开发工具，以及一系列的类库（如Java标准库和开发工具库）。JDK提供了开发、编译、调试和运行Java程序所需的全部工具和环境。</li></ul><h3 id="_5-为什么java解释和编译都有" tabindex="-1"><a class="header-anchor" href="#_5-为什么java解释和编译都有"><span>5. 为什么Java解释和编译都有？</span></a></h3><p>首先在Java经过编译之后生成字节码文件，接下来进入JVM中，就有两个步骤编译和解释。 如下图：</p><figure><img src="'+e+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>这段话的意思是，Java 语言在运行时既使用了编译的方式，也使用了解释的方式，具体解释如下：</p><p><strong>编译性</strong>：</p><ul><li>Java 程序源代码首先被<strong>编译</strong>成字节码（<code>.class</code> 文件）。字节码是一种平台无关的中间表示，意味着它可以在任何安装了 Java 虚拟机（JVM）的操作系统上运行，而不需要重新编译。</li><li><strong>JIT（即时编译器）</strong>：JIT 是 JVM 的一部分，它在程序运行时将字节码转化为机器码（即具体操作系统的本地代码）。JIT 会缓存这些机器码，避免每次执行时都重新编译，这样可以提高程序的执行效率。</li></ul><p><strong>解释性</strong>：</p><ul><li><strong>解释器</strong>：在程序执行的过程中，JVM 有一个解释器，它可以逐行读取字节码并直接执行，而不需要将字节码完全转化为机器码。解释器是较为“实时”的执行方式，但相对较慢。</li><li><strong>方法调用计数器</strong>：JVM 采用一种优化机制，当某个方法被调用的次数超过一定阈值时，JIT 编译器会将该方法的字节码编译为机器码，以提高后续的执行效率。如果调用次数较少，JVM 就继续使用解释器来执行，避免不必要的编译开销。</li></ul><p><strong>混合模式</strong>：</p><ul><li>Java 的执行模式是<strong>混合型的</strong>，既有<strong>编译</strong>也有<strong>解释</strong>： <ul><li>初始阶段，字节码通常是通过解释器执行的（即逐行解释执行）。</li><li>如果某个方法被频繁调用，JIT 编译器会将该方法编译成机器码，减少重复解释的开销。</li></ul></li></ul><h3 id="_6-jvm是什么" tabindex="-1"><a class="header-anchor" href="#_6-jvm是什么"><span>6.JVM是什么</span></a></h3><p>JVM是 Java 虚拟机，其主要任务是解释自己的指令集（即字节码），并将其映射到本地的 CPU 指令集和操作系统的系统调用上。</p><p>JVM 屏蔽了与操作系统平台相关的细节，使得 Java 程序只需生成在 Java 虚拟机上运行的字节码，便可以在多个平台上无修改地运行。这也是 Java 实现“编译一次，到处运行”的根本原因。</p><h3 id="_7-编译型语言和解释型语言的区别" tabindex="-1"><a class="header-anchor" href="#_7-编译型语言和解释型语言的区别"><span>7.<strong>编译型语言和解释型语言的区别？</strong></span></a></h3><ol><li><p><strong>编译型语言：</strong></p><ul><li><strong>定义</strong>：在程序执行之前，整个源代码会被编译成机器码或字节码，生成可执行文件。</li><li><strong>执行方式</strong>：程序执行时直接运行已编译的代码，执行速度较快。</li><li><strong>特点</strong>：编译后的程序与平台紧密相关，跨平台性较差。</li><li><strong>典型语言</strong>：C、C++。</li></ul></li><li><p><strong>解释型语言：</strong></p><ul><li><strong>定义</strong>：程序执行时，源代码被逐行解释并执行，不生成独立的可执行文件。</li><li><strong>执行方式</strong>：由解释器动态解释并执行代码，通常需要源代码和解释器一起运行。</li><li><strong>特点</strong>：具有较好的跨平台性，但执行速度相对较慢。</li><li><strong>典型语言</strong>：Python、JavaScript。</li></ul></li></ol><h3 id="_8-python和java的区别" tabindex="-1"><a class="header-anchor" href="#_8-python和java的区别"><span>8.<strong>Python和Java的区别：</strong></span></a></h3><ol><li><p><strong>Java：</strong></p><ul><li>Java 是一种编译型语言，意思是你写的代码会先通过编译器转换成字节码。</li><li>这些字节码不直接运行在操作系统上，而是通过 Java 虚拟机（JVM）来执行。</li><li>这样做的好处是，Java 代码可以在任何支持 JVM 的平台上运行，所以它的跨平台性很好。</li></ul></li><li><p><strong>Python：</strong></p><ul><li>Python 是解释型语言，也就是说，代码是直接由解释器逐行翻译并执行的。</li><li>这意味着每次运行 Python 程序时，解释器都在一边翻译，一边执行，所以执行速度相对较慢。</li><li>尽管如此，Python 也有很好的跨平台性，因为它的解释器可以在不同平台上运行。</li></ul></li></ol><h2 id="数据类型" tabindex="-1"><a class="header-anchor" href="#数据类型"><span>数据类型</span></a></h2><h3 id="_1-八种基本的数据类型" tabindex="-1"><a class="header-anchor" href="#_1-八种基本的数据类型"><span>1.八种基本的数据类型</span></a></h3><p>Java支持数据类型分为两类：<strong>基本数据类型</strong>和<strong>引用数据类型</strong>。</p><p>🔎基本数据类型共有8种，可以分为四类：</p><p>✅ <strong>数值型</strong>：<strong>整数类型</strong>：byte, short, int, long <strong>浮点数类型</strong>：float, double</p><p>✅ <strong>字符类型</strong>：char（注意 Java 用 Unicode 编码，支持国际化）</p><p>✅ <strong>布尔类型</strong>：boolean</p><figure><img src="'+h+'" alt="数据类型" tabindex="0" loading="lazy"><figcaption>数据类型</figcaption></figure><h3 id="_2-int和long是多少位-多少字节的" tabindex="-1"><a class="header-anchor" href="#_2-int和long是多少位-多少字节的"><span>2.int和long是多少位，多少字节的？</span></a></h3><p><strong>int</strong></p><ul><li><p><strong>字节数</strong>：4 个字节（32 bits）</p></li><li><p><strong>取值范围</strong>：</p><p>-2^{31} 到 2^{31} - 1</p></li></ul><p><strong>long</strong></p><ul><li><p><strong>字节数</strong>：8 个字节（64 bits）</p></li><li><p><strong>取值范围</strong>：</p><p>-2^{63} 到 2^{63} - 1</p></li></ul><h3 id="_3-long和int可以互转吗" tabindex="-1"><a class="header-anchor" href="#_3-long和int可以互转吗"><span>3. long和int可以互转吗？</span></a></h3><p>可以的，Java中的long 和int可以相互转换。由于long类型的范围比 int类型大，因此将 int 转换为long 是安全的将 long转换为int可能会导致数据丢失或溢出。将 int转换为long可以通过直接赋值或强制类型转换来实现。例如：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> intValue </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 10</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">longlongValue</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">intValue；</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">//自动转换，安全的</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>将long转换为int需要使用强制类型转换，但需要注意潜在的数据丢失或溢出问题。</p><figure><img src="/Users/felix/VsCodeProjects/my-docs/src/Interview/Java/Java基础面试篇/assets/image-20240726003850183.webp" alt="image-20240726003850183" tabindex="0" loading="lazy"><figcaption>image-20240726003850183</figcaption></figure><p>例如：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">long</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> longValue </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 100L</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> intValue </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)longValue</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">//强制类型转换，可能会有数据丢失或溢出</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>在将Long转换为int时，如果longValue的值超出了int类型的范围，转换结果将是截断后的低位部分。因此，在进行转换之前，建议先检查longValue的值是否在int类型的范围内，以避免数据丢失或溢出的问题。</p><h3 id="_4-数据类型转换方式你知道哪些" tabindex="-1"><a class="header-anchor" href="#_4-数据类型转换方式你知道哪些"><span>4.数据类型转换方式你知道哪些？</span></a></h3><ul><li>自动类型转换（隐式转换）：当目标类型的范围大于源类型时，Java会自动将源类型转换为目标类型，不需要显式的类型转换。例如，将int转换为Long、将float转换为double等。</li><li>强制类型转换（显式转换）：当目标类型的范围小于源类型时，需要使用强制类型转换将源类型转换为目标类型。这可能导致数据丢失或溢出。例如，将1ong转换为int、将double转换为int等。语法为：目标类型变量名=（目标类型）源类型。</li><li>字符串转换：Java提供了将字符串表示的数据转换为其他类型数据的方法。例如，将字符串转换为整型int，可以使用Integer.parseInt()方法；将字符串转换为浮点型double,可以使用 Double.parseDouble()方法等。</li><li>数值之间的转换：Java提供了一些数值类型之间的转换方法，如将整型转换为字符型、将字符型转换为整型等。这些转换方式可以通过类型的包装类来实现，例如Character类、Integer类等提供了相应的转换方法。</li></ul><h3 id="_5-类型互转会出现什么问题吗" tabindex="-1"><a class="header-anchor" href="#_5-类型互转会出现什么问题吗"><span>5.类型互转会出现什么问题吗？</span></a></h3><ul><li>数据丢失：当将一个范围较大的数据类型转换为一个范围较小的数据类型时，可能会发生数据丢失。例如，将一个long类型的值转换为int类型时，如果1ong值超出了int类型的范围，转换结果将是截断后的低位部分，高位部分的数据将丢失。</li><li>数据溢出：与数据丢失相反，当将一个范围较小的数据类型转换为一个范围较大的数据类型时，可能会发生数据溢出。例如，将一个int类型的值转换为long类型时，转换结果会填充额外的高位空间，但原始数据仍然保持不变。</li><li>精度损失：在进行浮点数类型的转换时，可能会发生精度损失。由于浮点数的表示方式不同，将一个单精度浮点数(float)转换为双精度浮点数(double)时，精度可能会损失。</li><li>类型不匹配导致的错误：在进行类型转换时，需要确保源类型和目标类型是兼容的。如果两者不兼容，会导致编译错误或运行时错误。</li></ul><h3 id="_6-为什么用bigdecimal不用double" tabindex="-1"><a class="header-anchor" href="#_6-为什么用bigdecimal不用double"><span>6.为什么用bigDecimal不用double?</span></a></h3><p>double会出现精度丢失的问题，double:执行的是二进制浮点运算，二进制有些情况下不能准确的表示一个小数，就像十进制不能准确的表示1/3(1/3=0.3333.)，也就是说二进制表示小数的时候只能够表示能够用 1/(2<sup>)的和的任意组合，但是0.1不能够精确表示，因为它不能够表示成为1/(2</sup>n)的和的形式。</p><h3 id="_7-装箱和拆箱是什么" tabindex="-1"><a class="header-anchor" href="#_7-装箱和拆箱是什么"><span>7.装箱和拆箱是什么？</span></a></h3><p>装箱(Boxing)和拆箱(Unboxing)是将基本数据类型和对应的包装类之间进行转换的过程。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Integer</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> i </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 10</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">//装箱 </span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> n </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> i</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">//拆箱</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>自动装箱主要发生在两种情况，一种是赋值时，另一种是在方法调用的时候。</p><p>赋值时</p><p>这是最常见的一种情况，在Jva1.5以前我们需要手动地进行转换才行，而现在所有的转换都是由编译器来完成。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">//before autoboxing </span></span>\n<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Integer</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> iobject </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> Integer</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">valueof</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">3</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> </span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> iPrimitive </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> iobject</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">intValue</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">//after java5 </span></span>\n<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Integer</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> iobject </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 3</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">//autobxing primitive to wrapper conversion </span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> iPrimitive </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> iobject</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">//unboxing object to primitive conversion</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>方法调用时</p><p>当我们在方法调用时，我们可以传入原始数据值或者对象，同样编译器会帮我们进行转换。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Integer</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> show</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Integer</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> iParam){</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">  System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;autoboxing example method invocation i:&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">iParam);</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> </span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  return</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> iParam</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">//autoboxing and unboxing in method invocation </span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">  show</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">3</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">//autoboxing </span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> result </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> show</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">3</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">//unboxing because return type of method is Integer</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>show方法接受<code>Integer</code>对象作为参数，当调用show(3)时，会将int值转换成对应的Integer对象，这就是所谓的自动装箱，show方法返回<code>Integer</code>对象，而<code>int result=show(3)</code>中result为int类型，所以这时候发生自动拆箱操作，将show方法的返回的Integer对象转换成int值。</p><p>自动装箱的弊端</p><p>自动装箱有一个问题，那就是在一个循环中进行自动装箱操作的情况，如下面的例子就会创建多余的对象，影响程序的性能。</p><p><code>Integer sum = 0;for(int i=1000;i&lt;5000;i++){sum+=i;}</code></p><p>上面的代码<code>sum+=i</code>可以看成<code>sum=sum+i,</code>但是+这个操作符不适用于Integer对象，首先sum进行自动拆箱操作，进行数值相加操作，最后发生自动装箱操作转换成<code>Integer</code>对象。其内部变化如下</p><p><code> int result = sum.intValue()+i;Integer sum = new Integer(result);</code></p><p>由于我们这里声明的sum为Integer类型，在上面的循环中会创建将近4000个无用的Integer对象，在这样庞大的循环中，会降低程序的性能并且加重了垃圾回收的工作量。因此在我们编程时，需要注意到这一点，正确地声明变量类型，避免因为自动装箱引起的性能问题。</p><h3 id="_8-java为什么要有integer" tabindex="-1"><a class="header-anchor" href="#_8-java为什么要有integer"><span>8.Java为什么要有Integer?</span></a></h3><p>Integeri对应是int类型的包装类，就是把int类型包装成Objecti对象，对象封装有很多好处，可以把属性也就是数据跟处理这些数据的方法结合在一起，比如Integer就有parselnt()等方法来专门处理int型相关的数据。</p><p>另一个非常重要的原因就是在Java中绝大部分方法或类都是用来处理类类型对象的，如ArrayList集合类就只能以类作为他的存储对象，而这时如果想把一个int型的数据存入list是不可能的，必须把它包装成类，也就是Integer才能被List所接受。所以Integer的存在是很必要的。</p><blockquote><p>泛型中的应用</p></blockquote><p>在Java中，泛型只能使用引用类型，而不能使用基本类型。因此，如果要在泛型中使用int类型，必须使用 Integer包装类。</p><p>例如，假设我们有一个列表，我们想要将其元素排序，并将排序结果存储在一个新的列表中。如果我们使用基本数据类型int,无法直接使用Collections.sort()方法。但是，如果我们使用Integer包装类，我们就可以轻松地使用Collections.sort()方法。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">java </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">List</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">Integer</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">list </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> ArrayList</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> </span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">list</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">add</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">3</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> </span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">list</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">add</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> </span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">list</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">add</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> </span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">Collections</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">sort</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(list);</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(list)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>转换中的应用</p></blockquote><p>Java集合中只能存储对象，而不能存储基本数据类型。因此，如果要将int类型的数据存储在集合中，必须使用Integer包装类。例如，假设我们有一个列表，我们想要计算列表中所有元素的和。如果我们使用基本数据类型int,我们需要使用一个循环来遍历列表，并将每个元素相加。但是，如果我们使用Integer包装类，我们可以直接使用stream()方法来计算所有元素的和。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">List</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">Integer</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">list </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> ArrayList</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> </span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">list</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">add</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">3</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> </span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">list</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">add</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> </span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">list</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">add</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> </span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> sum </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> list</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">stream</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">().</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">mapToInt</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(Integer</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">intValue).</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">sum</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> </span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(sum);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_9-integer相比int有什么优点" tabindex="-1"><a class="header-anchor" href="#_9-integer相比int有什么优点"><span>9.Integer相比int有什么优点？</span></a></h3><p>int是Java中的原始数据类型，而Integer是int的包装类。</p><blockquote><p>Integer和int的区别：</p></blockquote><ul><li>基本类型和引用类型：首先，int是一种基本数据类型，而Integer是一种引用类型。基本数据类型是 Java中最基本的数据类型，它们是预定义的，不需要实例化就可以使用。而引用类型则需要通过实例化对象来使用。这意味着，使用int来存储一个整数时，不需要任何额外的内存分配，而使用Integer时，必须为对象分配内存。在性能方面，基本数据类型的操作通常比相应的引用类型快。</li><li>自动装箱和拆箱：其次，Integer作为int的包装类，它可以实现自动装箱和拆箱。自动装箱是指将基本类型转化为相应的包装类类型，而自动拆箱则是将包装类类型转化为相应的基本类型。这使得Java程序员更加方便地进行数据类型转换。例如，当我们需要将int类型的值赋给Integer变量时，Java可以自动地将int类型转换为Integer类型。同样地，当我们需要将Integer类型的值赋给int变量时，Java可以自动地将Integer类型转换为int类型。</li><li>空指针异常：另外，int变量可以直接赋值为0，而Integer变量必须通过实例化对象来赋值。如果对一个未经初始化的Integer变量进行操作，就会出现空指针异常。这是因为它被赋予了null值，而null值是无法进行自动拆箱的。</li></ul><h3 id="_10-那为什么还要保留int类型" tabindex="-1"><a class="header-anchor" href="#_10-那为什么还要保留int类型"><span>10.那为什么还要保留int类型？</span></a></h3><p>包装类是引用类型，对象的引用和对象本身是分开存储的，而对于基本类型数据，变量对应的内存块直接存储数据本身。因此，基本类型数据在读写效率方面，要比包装类高效。除此之外，在64位JVM上，在开启引用压缩的情况下，一个Integer&gt;对象占用16个字节的内存空间，而一个int类型数据只占用4字节的内存空间，前者对空间的占用是后者的4倍。也就是说，不管是读写效率，还是存储效率，基本类型都比包装类高效。</p>',98)]))}]]),r=JSON.parse('{"path":"/Interview/Java/Java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E7%AF%87/1.Java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E7%AF%87.html","title":"Java基础面试题","lang":"zh-CN","frontmatter":{"gitInclude":[]},"headers":[{"level":2,"title":"概念","slug":"概念","link":"#概念","children":[{"level":3,"title":"1.说一下Java的特点","slug":"_1-说一下java的特点","link":"#_1-说一下java的特点","children":[]},{"level":3,"title":"2.Java 的优势和劣势是什么？","slug":"_2-java-的优势和劣势是什么","link":"#_2-java-的优势和劣势是什么","children":[]},{"level":3,"title":"3.Java为什么是跨平台的？","slug":"_3-java为什么是跨平台的","link":"#_3-java为什么是跨平台的","children":[]},{"level":3,"title":"4. JVM、JDK、JRE三者关系？","slug":"_4-jvm、jdk、jre三者关系","link":"#_4-jvm、jdk、jre三者关系","children":[]},{"level":3,"title":"5. 为什么Java解释和编译都有？","slug":"_5-为什么java解释和编译都有","link":"#_5-为什么java解释和编译都有","children":[]},{"level":3,"title":"6.JVM是什么","slug":"_6-jvm是什么","link":"#_6-jvm是什么","children":[]},{"level":3,"title":"7.编译型语言和解释型语言的区别？","slug":"_7-编译型语言和解释型语言的区别","link":"#_7-编译型语言和解释型语言的区别","children":[]},{"level":3,"title":"8.Python和Java的区别：","slug":"_8-python和java的区别","link":"#_8-python和java的区别","children":[]}]},{"level":2,"title":"数据类型","slug":"数据类型","link":"#数据类型","children":[{"level":3,"title":"1.八种基本的数据类型","slug":"_1-八种基本的数据类型","link":"#_1-八种基本的数据类型","children":[]},{"level":3,"title":"2.int和long是多少位，多少字节的？","slug":"_2-int和long是多少位-多少字节的","link":"#_2-int和long是多少位-多少字节的","children":[]},{"level":3,"title":"3. long和int可以互转吗？","slug":"_3-long和int可以互转吗","link":"#_3-long和int可以互转吗","children":[]},{"level":3,"title":"4.数据类型转换方式你知道哪些？","slug":"_4-数据类型转换方式你知道哪些","link":"#_4-数据类型转换方式你知道哪些","children":[]},{"level":3,"title":"5.类型互转会出现什么问题吗？","slug":"_5-类型互转会出现什么问题吗","link":"#_5-类型互转会出现什么问题吗","children":[]},{"level":3,"title":"6.为什么用bigDecimal不用double?","slug":"_6-为什么用bigdecimal不用double","link":"#_6-为什么用bigdecimal不用double","children":[]},{"level":3,"title":"7.装箱和拆箱是什么？","slug":"_7-装箱和拆箱是什么","link":"#_7-装箱和拆箱是什么","children":[]},{"level":3,"title":"8.Java为什么要有Integer?","slug":"_8-java为什么要有integer","link":"#_8-java为什么要有integer","children":[]},{"level":3,"title":"9.Integer相比int有什么优点？","slug":"_9-integer相比int有什么优点","link":"#_9-integer相比int有什么优点","children":[]},{"level":3,"title":"10.那为什么还要保留int类型？","slug":"_10-那为什么还要保留int类型","link":"#_10-那为什么还要保留int类型","children":[]}]}],"readingTime":{"minutes":17.4,"words":5220},"filePathRelative":"Interview/Java/Java基础面试篇/1.Java基础面试篇.md","excerpt":"\\n<h2>概念</h2>\\n<h3>1.说一下Java的特点</h3>\\n<p>主要有以下的特点：</p>\\n<ul>\\n<li><strong>平台无关性</strong>：Java的“编写一次，运行无处不在\\"哲学是其最大的特点之一。Java编译器将源代码编译成\\n字节码(bytecode)，该字节码可以在任何安装了Java虚拟机（JVM)的系统上运行。</li>\\n<li><strong>面向对象</strong>：Java是一门严格的面向对象编程语言，几乎一切都是对象。面向对象编程(OOP)特性使\\n得代码更易于维护和重用，包括类(class)、对象（object)、继承(inheritance)、多态\\n(polymorphism)、抽象（abstraction)和封装(encapsulation)。</li>\\n<li><strong>内存管理</strong>：Java有自己的垃圾回收机制，自动管理内存和回收不再使用的对象。这样，开发者不需要\\n手动管理内存，从而减少内存泄漏和其他内存相关的问题。</li>\\n</ul>"}')}}]);