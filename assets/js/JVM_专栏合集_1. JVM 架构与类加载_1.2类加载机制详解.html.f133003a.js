"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[8340],{66262:(s,i)=>{i.A=(s,i)=>{const a=s.__vccOpts||s;for(const[s,n]of i)a[s]=n;return a}},77987:(s,i,a)=>{a.r(i),a.d(i,{comp:()=>t,data:()=>e});var n=a(20641);const l={},t=(0,a(66262).A)(l,[["render",function(s,i){return(0,n.uX)(),(0,n.CE)("div",null,i[0]||(i[0]=[(0,n.Fv)('<h1 id="_1-2-《jvm-类加载机制详解-含双亲委派模型-》" tabindex="-1"><a class="header-anchor" href="#_1-2-《jvm-类加载机制详解-含双亲委派模型-》"><span>1.2 《JVM 类加载机制详解（含双亲委派模型）》</span></a></h1><hr><h2 id="🚀-什么是类加载" tabindex="-1"><a class="header-anchor" href="#🚀-什么是类加载"><span>🚀 什么是类加载？</span></a></h2><p>类加载是指 JVM 在运行时将 <code>.class</code> 字节码文件加载进内存，转化为 <code>java.lang.Class</code> 对象的过程。它是 Java 程序得以动态运行的基础。</p><hr><h2 id="📦-类加载的五个阶段" tabindex="-1"><a class="header-anchor" href="#📦-类加载的五个阶段"><span>📦 类加载的五个阶段</span></a></h2><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>[加载] → [验证] → [准备] → [解析] → [初始化]</span></span>\n<span class="line"><span>            ↘ 属于“连接”阶段 ↙</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><table><thead><tr><th>阶段</th><th>说明</th></tr></thead><tbody><tr><td>加载</td><td>通过类加载器读取 <code>.class</code> 文件，生成 Class 对象</td></tr><tr><td>验证</td><td>字节码校验，防止破坏 JVM 安全性</td></tr><tr><td>准备</td><td>为静态变量分配内存并赋默认值</td></tr><tr><td>解析</td><td>将符号引用替换为直接引用（如方法/字段地址）</td></tr><tr><td>初始化</td><td>执行 <code>&lt;clinit&gt;</code> 静态代码块和静态变量赋值</td></tr></tbody></table><hr><h2 id="🔄-类加载器分类" tabindex="-1"><a class="header-anchor" href="#🔄-类加载器分类"><span>🔄 类加载器分类</span></a></h2><p>JVM 中有三种主要的类加载器：</p><table><thead><tr><th>类加载器</th><th>说明</th><th>加载内容</th></tr></thead><tbody><tr><td>启动类加载器（Bootstrap）</td><td>JVM 内部实现，C++ 编写</td><td>核心类库（rt.jar）</td></tr><tr><td>扩展类加载器（ExtClassLoader）</td><td>加载 <code>ext</code> 目录下的 jar</td><td>Java 扩展类库</td></tr><tr><td>应用类加载器（AppClassLoader）</td><td>默认类加载器</td><td><code>classpath</code> 路径下的类</td></tr></tbody></table><hr><h2 id="🔁-双亲委派模型" tabindex="-1"><a class="header-anchor" href="#🔁-双亲委派模型"><span>🔁 双亲委派模型</span></a></h2><p>双亲委派模型的本质：<strong>优先委托父加载器加载类，只有父加载器加载不到时，才由当前加载器尝试加载。</strong></p><h3 id="原理图" tabindex="-1"><a class="header-anchor" href="#原理图"><span>原理图：</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>ClassLoader.loadClass(String name)</span></span>\n<span class="line"><span>    ↓</span></span>\n<span class="line"><span>父加载器尝试加载（递归调用）</span></span>\n<span class="line"><span>    ↓</span></span>\n<span class="line"><span>找不到 → 当前类加载器加载</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="目的" tabindex="-1"><a class="header-anchor" href="#目的"><span>目的：</span></a></h3><ul><li>避免类的重复加载</li><li>保证核心类的唯一性（如 <code>java.lang.String</code>）</li><li>增强安全性（防止自定义加载器覆盖核心类）</li></ul><hr><h2 id="🔧-自定义类加载器" tabindex="-1"><a class="header-anchor" href="#🔧-自定义类加载器"><span>🔧 自定义类加载器</span></a></h2><p>实现一个类加载器，只需继承 <code>ClassLoader</code> 并重写 <code>findClass</code> 方法：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> MyClassLoader</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> extends</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> ClassLoader</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    @</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Override</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    protected</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Class</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">?</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> findClass</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> name</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> throws</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> ClassNotFoundException</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">        byte</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">[] </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">data</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> loadClassFromDisk</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(name);</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> defineClass</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(name, data, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">data</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">length</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>🧩 常见使用场景：插件热加载、沙箱隔离、Tomcat 的 WebApp 加载等。</p><hr><h2 id="🧪-类初始化触发条件" tabindex="-1"><a class="header-anchor" href="#🧪-类初始化触发条件"><span>🧪 类初始化触发条件</span></a></h2><table><thead><tr><th>场景</th><th>是否触发初始化</th></tr></thead><tbody><tr><td>使用 <code>new</code> 创建实例</td><td>✅ 是</td></tr><tr><td>访问非 final 静态变量</td><td>✅ 是</td></tr><tr><td>调用静态方法</td><td>✅ 是</td></tr><tr><td>反射调用类</td><td>✅ 是</td></tr><tr><td>访问 final 静态常量</td><td>❌ 否（会被编译期内联）</td></tr><tr><td><code>ClassLoader.loadClass()</code></td><td>❌ 否（只加载不初始化）</td></tr></tbody></table><hr><h2 id="✅-示例说明" tabindex="-1"><a class="header-anchor" href="#✅-示例说明"><span>✅ 示例说明</span></a></h2><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Demo</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    static</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> {</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;Demo 类被初始化了&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> value </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 10</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> final</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> CONST </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 100</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Test</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> main</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[] </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">args</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> throws</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Exception</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        Class</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">forName</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;Demo&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);         </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// ✅ 触发初始化</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // ClassLoader.getSystemClassLoader().loadClass(&quot;Demo&quot;); // ❌ 不会初始化</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // System.out.println(Demo.CONST);                         // ❌ 不会初始化</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="📌-面试高频问题" tabindex="-1"><a class="header-anchor" href="#📌-面试高频问题"><span>📌 面试高频问题</span></a></h2><ol><li>类加载的 5 个阶段是什么？</li><li>双亲委派机制的作用？能打破吗？</li><li>自定义类加载器的使用场景？</li><li>哪些操作不会触发类初始化？</li></ol><hr><h2 id="📝-小结" tabindex="-1"><a class="header-anchor" href="#📝-小结"><span>📝 小结</span></a></h2><ul><li>类加载机制使 Java 支持动态加载和模块化架构</li><li>双亲委派模型提升了安全性和一致性</li><li>了解加载流程有助于解决 NoClassDefFoundError、ClassCastException 等问题</li></ul><hr><p>👉 下一篇推荐阅读：<a href="https://chatgpt.com/c/6865ecec-fbc4-800b-952b-a391340aecbc#" target="_blank" rel="noopener noreferrer">1.3 类的初始化与加载的触发条件</a></p>',38)]))}]]),e=JSON.parse('{"path":"/JVM/%E4%B8%93%E6%A0%8F%E5%90%88%E9%9B%86/1.%20JVM%20%E6%9E%B6%E6%9E%84%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD/1.2%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3.html","title":"1.2 《JVM 类加载机制详解（含双亲委派模型）》","lang":"zh-CN","frontmatter":{"gitInclude":[]},"headers":[{"level":2,"title":"🚀 什么是类加载？","slug":"🚀-什么是类加载","link":"#🚀-什么是类加载","children":[]},{"level":2,"title":"📦 类加载的五个阶段","slug":"📦-类加载的五个阶段","link":"#📦-类加载的五个阶段","children":[]},{"level":2,"title":"🔄 类加载器分类","slug":"🔄-类加载器分类","link":"#🔄-类加载器分类","children":[]},{"level":2,"title":"🔁 双亲委派模型","slug":"🔁-双亲委派模型","link":"#🔁-双亲委派模型","children":[{"level":3,"title":"原理图：","slug":"原理图","link":"#原理图","children":[]},{"level":3,"title":"目的：","slug":"目的","link":"#目的","children":[]}]},{"level":2,"title":"🔧 自定义类加载器","slug":"🔧-自定义类加载器","link":"#🔧-自定义类加载器","children":[]},{"level":2,"title":"🧪 类初始化触发条件","slug":"🧪-类初始化触发条件","link":"#🧪-类初始化触发条件","children":[]},{"level":2,"title":"✅ 示例说明","slug":"✅-示例说明","link":"#✅-示例说明","children":[]},{"level":2,"title":"📌 面试高频问题","slug":"📌-面试高频问题","link":"#📌-面试高频问题","children":[]},{"level":2,"title":"📝 小结","slug":"📝-小结","link":"#📝-小结","children":[]}],"readingTime":{"minutes":2.45,"words":734},"filePathRelative":"JVM/专栏合集/1. JVM 架构与类加载/1.2类加载机制详解.md","excerpt":"\\n<hr>\\n<h2>🚀 什么是类加载？</h2>\\n<p>类加载是指 JVM 在运行时将 <code>.class</code> 字节码文件加载进内存，转化为 <code>java.lang.Class</code> 对象的过程。它是 Java 程序得以动态运行的基础。</p>\\n<hr>\\n<h2>📦 类加载的五个阶段</h2>\\n<div class=\\"language- line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"\\" data-title=\\"\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span>[加载] → [验证] → [准备] → [解析] → [初始化]</span></span>\\n<span class=\\"line\\"><span>            ↘ 属于“连接”阶段 ↙</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>"}')}}]);