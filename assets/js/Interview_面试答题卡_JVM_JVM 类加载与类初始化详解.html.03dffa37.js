"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[37134],{66262:(i,s)=>{s.A=(i,s)=>{const a=i.__vccOpts||i;for(const[i,t]of s)a[i]=t;return a}},56731:(i,s,a)=>{a.r(s),a.d(s,{comp:()=>l,data:()=>e});var t=a(20641);const n={},l=(0,a(66262).A)(n,[["render",function(i,s){return(0,t.uX)(),(0,t.CE)("div",null,s[0]||(s[0]=[(0,t.Fv)('<h1 id="☕-jvm面试答题卡-jvm-类加载与类初始化详解" tabindex="-1"><a class="header-anchor" href="#☕-jvm面试答题卡-jvm-类加载与类初始化详解"><span>☕ JVM面试答题卡：JVM 类加载与类初始化详解</span></a></h1><h2 id="✅-一句话概括" tabindex="-1"><a class="header-anchor" href="#✅-一句话概括"><span>✅ 一句话概括</span></a></h2><blockquote><p>Java 类从编译后的 .class 文件被加载到 JVM 运行内存中，要经历类加载的五个阶段，最终在类初始化阶段执行 <code>&lt;clinit&gt;</code> 方法，完成静态变量赋值和静态语句块的执行。</p></blockquote><h2 id="🧱-1-jvm-类加载的五大阶段" tabindex="-1"><a class="header-anchor" href="#🧱-1-jvm-类加载的五大阶段"><span>🧱 1. JVM 类加载的五大阶段</span></a></h2><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>加载 → 验证 → 准备 → 解析 → 初始化</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><table><thead><tr><th><strong>阶段名</strong></th><th><strong>关键点</strong></th></tr></thead><tbody><tr><td><strong>加载</strong></td><td>读取 .class 文件并生成 Class 对象</td></tr><tr><td><strong>验证</strong></td><td>确保字节码格式正确、符合规范（安全检查）</td></tr><tr><td><strong>准备</strong></td><td>为静态变量分配内存，赋默认值</td></tr><tr><td><strong>解析</strong></td><td>将符号引用转为直接引用</td></tr><tr><td><strong>初始化</strong></td><td>执行静态初始化代码 <code>&lt;clinit&gt;</code></td></tr></tbody></table><h2 id="✅-2-类加载过程详解" tabindex="-1"><a class="header-anchor" href="#✅-2-类加载过程详解"><span>✅ 2. 类加载过程详解</span></a></h2><h3 id="✅-2-1-加载-loading" tabindex="-1"><a class="header-anchor" href="#✅-2-1-加载-loading"><span>✅ 2.1 加载（Loading）</span></a></h3><ul><li>通过类加载器读取 .class 文件，生成 java.lang.Class 对象</li><li>类加载器：启动类加载器（Bootstrap）、扩展类加载器（ExtClassLoader）、应用类加载器（AppClassLoader）等</li></ul><h3 id="✅-2-2-验证-verification" tabindex="-1"><a class="header-anchor" href="#✅-2-2-验证-verification"><span>✅ 2.2 验证（Verification）</span></a></h3><ul><li>检查字节码合法性（防止恶意攻击）</li><li>包括文件格式、元数据验证、语义验证、字节码验证等</li></ul><h3 id="✅-2-3-准备-preparation" tabindex="-1"><a class="header-anchor" href="#✅-2-3-准备-preparation"><span>✅ 2.3 准备（Preparation）</span></a></h3><ul><li>为<strong>类的静态变量分配内存</strong>，并赋<strong>默认值</strong></li></ul><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>public static int a = 10;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>此阶段中 a 是 0，值尚未初始化为 10</p><h3 id="✅-2-4-解析-resolution" tabindex="-1"><a class="header-anchor" href="#✅-2-4-解析-resolution"><span>✅ 2.4 解析（Resolution）</span></a></h3><ul><li>将符号引用（字符串或其他形式）转换为直接引用（内存地址/引用）</li><li>延迟解析：JVM 支持按需解析（运行时解析）</li></ul><h3 id="✅-2-5-初始化-initialization" tabindex="-1"><a class="header-anchor" href="#✅-2-5-初始化-initialization"><span>✅ 2.5 初始化（Initialization）</span></a></h3><ul><li><strong>执行类中的静态变量赋值和静态代码块</strong>（<code>&lt;clinit&gt;</code> 方法）</li><li>所有静态初始化逻辑在这里执行</li><li>JVM 保证同一个类的 <code>&lt;clinit&gt;</code> 方法 <strong>只会执行一次</strong></li></ul><h2 id="⚙️-3-什么时候会触发类初始化" tabindex="-1"><a class="header-anchor" href="#⚙️-3-什么时候会触发类初始化"><span>⚙️ 3. 什么时候会触发类初始化？</span></a></h2><p>类初始化是类加载的最后一步，仅在<strong>主动使用类</strong>时才会触发，常见情况：</p><table><thead><tr><th><strong>场景</strong></th><th><strong>是否触发初始化</strong></th></tr></thead><tbody><tr><td>new 对象</td><td>✅ 是</td></tr><tr><td>访问静态变量（非 final）</td><td>✅ 是</td></tr><tr><td>调用静态方法</td><td>✅ 是</td></tr><tr><td>反射（如 Class.forName）</td><td>✅ 是</td></tr><tr><td>子类初始化时，其父类会被初始化</td><td>✅ 是</td></tr><tr><td>JVM 启动时主类</td><td>✅ 是</td></tr><tr><td>访问静态常量（static final）</td><td>❌ 不是（在准备阶段就完成）</td></tr><tr><td>通过数组定义类（如 MyClass[] arr = new MyClass[10]）</td><td>❌ 否</td></tr></tbody></table><h2 id="🧪-4-示例说明" tabindex="-1"><a class="header-anchor" href="#🧪-4-示例说明"><span>🧪 4. 示例说明</span></a></h2><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Demo</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    static</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> {</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;静态代码块执行&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> a </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 42</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> method</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;静态方法&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Test</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> main</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[] </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">args</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        Demo</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">method</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(); </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 会触发类初始化，输出“静态代码块执行”</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="🔍-5-类加载器-classloader-体系" tabindex="-1"><a class="header-anchor" href="#🔍-5-类加载器-classloader-体系"><span>🔍 5. 类加载器（ClassLoader）体系</span></a></h2><table><thead><tr><th><strong>类加载器</strong></th><th><strong>加载内容</strong></th></tr></thead><tbody><tr><td>Bootstrap ClassLoader</td><td>JDK 核心类（rt.jar）</td></tr><tr><td>Extension ClassLoader</td><td>ext 目录下的扩展类</td></tr><tr><td>Application ClassLoader</td><td>项目 classpath 中的类</td></tr><tr><td>自定义类加载器</td><td>通过继承 ClassLoader 实现</td></tr></tbody></table><p>👉 类加载器遵循<strong>双亲委派模型</strong></p><h2 id="📚-6-clinit方法-vs-构造器" tabindex="-1"><a class="header-anchor" href="#📚-6-clinit方法-vs-构造器"><span>📚 6.clinit方法 VS 构造器</span></a></h2><table><thead><tr><th><strong>特性</strong></th><th><code>&lt;clinit&gt;</code> <strong>静态初始化方法</strong></th><th><strong>构造器</strong> Demo()</th></tr></thead><tbody><tr><td>执行时机</td><td>类初始化阶段</td><td>对象创建阶段（new）</td></tr><tr><td>执行次数</td><td>类加载后只执行一次</td><td>每次创建实例时执行</td></tr><tr><td>初始化内容</td><td>静态变量、静态代码块</td><td>普通成员变量、构造代码块</td></tr></tbody></table><h2 id="✅-7-面试高频问法与答题模板-建议背诵" tabindex="-1"><a class="header-anchor" href="#✅-7-面试高频问法与答题模板-建议背诵"><span>✅ 7. 面试高频问法与答题模板（建议背诵）</span></a></h2><blockquote><p>Java 类的加载由 JVM 完成，分为五个阶段：加载、验证、准备、解析、初始化。类初始化阶段会执行 <code>&lt;clinit&gt;</code> 方法，对静态变量赋值并执行静态代码块。类只有在主动使用时才会触发初始化，如 new 对象、访问静态变量、调用静态方法等。JVM 中类加载器使用双亲委派模型，确保核心类安全不可被篡改。</p></blockquote>',31)]))}]]),e=JSON.parse('{"path":"/Interview/%E9%9D%A2%E8%AF%95%E7%AD%94%E9%A2%98%E5%8D%A1/JVM/JVM%20%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B8%8E%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AF%A6%E8%A7%A3.html","title":"☕ JVM面试答题卡：JVM 类加载与类初始化详解","lang":"zh-CN","frontmatter":{"gitInclude":[]},"headers":[{"level":2,"title":"✅ 一句话概括","slug":"✅-一句话概括","link":"#✅-一句话概括","children":[]},{"level":2,"title":"🧱 1. JVM 类加载的五大阶段","slug":"🧱-1-jvm-类加载的五大阶段","link":"#🧱-1-jvm-类加载的五大阶段","children":[]},{"level":2,"title":"✅ 2. 类加载过程详解","slug":"✅-2-类加载过程详解","link":"#✅-2-类加载过程详解","children":[{"level":3,"title":"✅ 2.1 加载（Loading）","slug":"✅-2-1-加载-loading","link":"#✅-2-1-加载-loading","children":[]},{"level":3,"title":"✅ 2.2 验证（Verification）","slug":"✅-2-2-验证-verification","link":"#✅-2-2-验证-verification","children":[]},{"level":3,"title":"✅ 2.3 准备（Preparation）","slug":"✅-2-3-准备-preparation","link":"#✅-2-3-准备-preparation","children":[]},{"level":3,"title":"✅ 2.4 解析（Resolution）","slug":"✅-2-4-解析-resolution","link":"#✅-2-4-解析-resolution","children":[]},{"level":3,"title":"✅ 2.5 初始化（Initialization）","slug":"✅-2-5-初始化-initialization","link":"#✅-2-5-初始化-initialization","children":[]}]},{"level":2,"title":"⚙️ 3. 什么时候会触发类初始化？","slug":"⚙️-3-什么时候会触发类初始化","link":"#⚙️-3-什么时候会触发类初始化","children":[]},{"level":2,"title":"🧪 4. 示例说明","slug":"🧪-4-示例说明","link":"#🧪-4-示例说明","children":[]},{"level":2,"title":"🔍 5. 类加载器（ClassLoader）体系","slug":"🔍-5-类加载器-classloader-体系","link":"#🔍-5-类加载器-classloader-体系","children":[]},{"level":2,"title":"📚 6.clinit方法 VS 构造器","slug":"📚-6-clinit方法-vs-构造器","link":"#📚-6-clinit方法-vs-构造器","children":[]},{"level":2,"title":"✅ 7. 面试高频问法与答题模板（建议背诵）","slug":"✅-7-面试高频问法与答题模板-建议背诵","link":"#✅-7-面试高频问法与答题模板-建议背诵","children":[]}],"readingTime":{"minutes":2.96,"words":887},"filePathRelative":"Interview/面试答题卡/JVM/JVM 类加载与类初始化详解.md","excerpt":"\\n<h2>✅ 一句话概括</h2>\\n<blockquote>\\n<p>Java 类从编译后的 .class 文件被加载到 JVM 运行内存中，要经历类加载的五个阶段，最终在类初始化阶段执行 <code>&lt;clinit&gt;</code> 方法，完成静态变量赋值和静态语句块的执行。</p>\\n</blockquote>\\n<h2>🧱 1. JVM 类加载的五大阶段</h2>\\n<div class=\\"language- line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"\\" data-title=\\"\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span>加载 → 验证 → 准备 → 解析 → 初始化</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div></div></div>"}')}}]);