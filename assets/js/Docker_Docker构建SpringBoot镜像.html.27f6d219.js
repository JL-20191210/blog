"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[3169],{6262:(i,s)=>{s.A=(i,s)=>{const l=i.__vccOpts||i;for(const[i,e]of s)l[i]=e;return l}},7903:(i,s,l)=>{l.r(s),l.d(s,{comp:()=>h,data:()=>c});var e=l(641);const a=l.p+"assets/img/202410271510023.d7494b63.jpeg",n=l.p+"assets/img/202410271510987.b94df4ab.jpeg",t=l.p+"assets/img/202410271510390.a8257264.jpeg",d=l.p+"assets/img/202410271510777.2cfbb68b.jpeg",o=l.p+"assets/img/202410271510945.913f056e.jpeg",r=l.p+"assets/img/202410271510883.4dc917a2.jpeg",p={},h=(0,l(6262).A)(p,[["render",function(i,s){return(0,e.uX)(),(0,e.CE)("div",null,[s[0]||(s[0]=(0,e.Fv)('<h1 id="docker构建springboot镜像" tabindex="-1"><a class="header-anchor" href="#docker构建springboot镜像"><span>Docker构建SpringBoot镜像</span></a></h1><h2 id="_1-什么是-dockerfile" tabindex="-1"><a class="header-anchor" href="#_1-什么是-dockerfile"><span>1. 什么是 Dockerfile ?</span></a></h2><figure><img src="'+a+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>Dockerfile 是用于构建 Docker 镜像的文本文件，其中包含了一系列的指令，每个指令对应着镜像构建过程中的一步操作。通过 Dockerfile，开发者可以定义镜像中包含的文件、环境变量、运行命令等配置。</p>',4)),(0,e.Q3)("more"),s[1]||(s[1]=(0,e.Fv)('<h2 id="_2-创建-dockerfile" tabindex="-1"><a class="header-anchor" href="#_2-创建-dockerfile"><span>2. 创建 Dockerfile</span></a></h2><p>在 <code>weblog-web</code> 入口模块下，创建一个名为 <code>Dockerfile</code> 的文件：</p><figure><img src="'+n+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>内容如下：</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># FROM 指定使用哪个镜像作为基准</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">FROM</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> openjdk:8-jdk-alpine</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 创建目录, 并设置该目录为工作目录</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">RUN</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> mkdir</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -p</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> /weblog</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">WORKDIR</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> /weblog</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 复制文件到镜像中</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">COPY</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> weblog-web-0.0.1-SNAPSHOT.jar</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> app.jar</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 设置时区</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">ENV</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> TZ=Asia/Shanghai</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 设置 JAVA_OPTS 环境变量，可通过 docker run -e &quot;JAVA_OPTS=&quot; 进行覆盖</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">ENV</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> JAVA_OPTS=&quot;-Xms300m -Xmx300m -Djava.security.egd=file:/dev/./urandom&quot;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 应用参数，可通过 docker run -e &quot;ARGS=&quot; 来设置，如 -e &quot;ARGS=--spring.profiles.active=prod&quot;</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">ENV</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> ARGS=&quot;&quot;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 暴露 8080 端口</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">EXPOSE</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 8080</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 启动后端服务</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">CMD</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> java</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;"> ${</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">JAVA_OPTS</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">}</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -jar</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> app.jar</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> $ARGS</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>解释一下每行指令的含义：</p><ul><li><code>FROM openjdk:8-jdk-alpine:</code> : 使用 <code>openjdk:8-jdk-alpine</code> 作为基础镜像，该镜像包含了 OpenJDK 8 和 Alpine Linux。</li><li><code>RUN mkdir -p /weblog</code> : 在容器中创建一个名为 <code>/weblog</code> 的目录。</li><li><code>WORKDIR /weblog</code> : 设置工作目录为 <code>/weblog</code>，后续的指令将在该目录下执行。</li><li><code>COPY weblog-web-0.0.1-SNAPSHOT.jar app.jar</code> : 将本地的 <code>weblog-web-0.0.1-SNAPSHOT.jar</code> 复制到容器中，并命名为 <code>app.jar</code>。</li><li><code>ENV TZ=Asia/Shanghai</code> : 设置时区为亚洲/上海。</li><li><code>ENV JAVA_OPTS=&quot;-Xms300m -Xmx300m -Djava.security.egd=file:/dev/./urandom&quot;</code> : 设置 Java 运行时的环境变量，包括堆内存大小、堆外内存大小和随机数生成源。</li><li><code>ENV ARGS=&quot;&quot;</code> ： 设置一个空的环境变量，用于存放 Java 应用程序的额外参数。</li><li><code>EXPOSE 8080</code> : 声明容器将监听的端口号为 8080。</li><li><code>CMD java ${JAVA_OPTS} -jar app.jar $ARGS</code> : 定义容器启动时默认执行的命令。在这里，它运行 Java 应用程序 <code>app.jar</code>，并传递之前设置的 Java 运行时参数和额外的参数。</li></ul><h2 id="_3-构建镜像" tabindex="-1"><a class="header-anchor" href="#_3-构建镜像"><span>3. 构建镜像</span></a></h2><p>我们将该 <code>Dockerfile</code> 文件上传到云服务中 <code>jar</code> 包的同级目录下，并执行如下命令, 赋予该文件可执行权限</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">chmod</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> +x</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> Dockerfile</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><figure><img src="'+t+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>接着，执行如下构建镜像命令：</p><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" data-title="plain" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>docker build -t weblog-web:0.0.1-SNAPSHOT .</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>解释一下：</p><ul><li><p><strong>docker build:</strong></p></li><li><ul><li>这是 Docker 的构建命令，用于根据 Dockerfile 构建一个 Docker 镜像。</li></ul></li><li><p><strong>-t weblog-web:0.0.1-SNAPSHOT:</strong></p></li><li><ul><li>这个参数用于指定构建的镜像的名称及标签。</li></ul></li><li><p><strong>. :</strong></p></li><li><ul><li>这个点表示 Docker 上下文的路径。Docker 构建时需要一个上下文，它包含了构建过程所需的文件。点表示当前目录是上下文，Docker 将在当前目录查找 Dockerfile 等构建所需的文件。</li></ul></li></ul><p>注意：别遗漏了命令最后的点 <code>.</code></p><figure><img src="'+d+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>镜像构建完成后，可以通过 <code>docker images</code> 来确认一下本地是否存在该镜像：</p><figure><img src="'+o+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h2 id="_4-运行容器" tabindex="-1"><a class="header-anchor" href="#_4-运行容器"><span>4. 运行容器</span></a></h2><p>有了镜像后，接下来就是通过该镜像来运行一个容器了，运行之前，别忘了将之前通过 <code>jar</code> 包启动的服务 <code>kill</code> 掉，然后执行命令如下：</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">docker</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> run</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> --restart=always</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -d</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -p</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> 8080:8080</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -e</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;ARGS=--spring.profiles.active=prod&quot;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -v</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> /app/weblog:/app/weblog</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> --name</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> weblog-web</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> weblog-web:0.0.1-SNAPSHOT</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>解释一下：</p><ol><li><strong>docker run:</strong></li></ol><ul><li><ul><li>启动一个新的容器。</li></ul></li></ul><ol><li><strong>--restart=always:</strong></li></ol><ul><li><ul><li>设置容器在退出时总是重新启动。即使 Docker 守护进程被重启，也会确保容器一直运行。</li></ul></li></ul><ol><li><strong>-d:</strong></li></ol><ul><li><ul><li>在后台运行容器，即以守护态（detached）方式运行。</li></ul></li></ul><ol><li><strong>-p 8080:8080:</strong></li></ol><ul><li><ul><li>将主机的 8080 端口映射到容器的 8080 端口。这样可以通过主机的 8080 端口访问容器内的服务。</li></ul></li></ul><ol><li><strong>-e &quot;ARGS=--spring.profiles.active=prod&quot;:</strong></li></ol><ul><li><ul><li>设置环境变量 <code>ARGS</code>，传递额外的启动参数给容器。在这里，它设置了 Spring Boot 应用程序的激活的配置文件为 <code>prod</code>。</li></ul></li></ul><ol><li><strong>-v /app/weblog:/app/weblog:</strong></li></ol><ul><li><ul><li>将主机的 <code>/app/weblog</code> 目录挂载到容器的 <code>/app/weblog</code> 目录。这可以用于持久化存储，使得容器内的数据可以在主机和容器之间共享。</li></ul></li></ul><ol><li><strong>--name weblog-web:</strong></li></ol><ul><li><ul><li>为容器指定一个名称，这里命名为 <code>weblog-web</code>。</li></ul></li></ul><ol><li><strong>weblog-web:0.0.1-SNAPSHOT:</strong></li></ol><ul><li><ul><li>指定要运行的镜像的名称及版本标签。</li></ul></li></ul><p>执行完成后，通过 <code>docker ps</code> 来查看正在运行中的容器，不出意外就能看到 <code>weblog-web</code> 这个容器了。同时，通过 <code>tail -f</code> 来查看 <code>/app/weblog/logs</code> 中的日志，以及网站运行情况，确认以容器运行的服务是正常的。</p><figure><img src="'+r+'" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>至此，我们就搞定了通过 <code>Dockerfile</code> 来构建 <code>Spring Boot</code> 镜像，以及通过镜像成功运行起了后端服务。</p>',42))])}]]),c=JSON.parse('{"path":"/Docker/Docker%E6%9E%84%E5%BB%BASpringBoot%E9%95%9C%E5%83%8F.html","title":"构建SpringBoot镜像","lang":"zh-CN","frontmatter":{"title":"构建SpringBoot镜像","icon":"laptop-code","date":"2024-10-17T00:00:00.000Z","category":["docker"],"tag":["镜像"],"gitInclude":[]},"headers":[{"level":2,"title":"1. 什么是 Dockerfile ?","slug":"_1-什么是-dockerfile","link":"#_1-什么是-dockerfile","children":[]},{"level":2,"title":"2. 创建 Dockerfile","slug":"_2-创建-dockerfile","link":"#_2-创建-dockerfile","children":[]},{"level":2,"title":"3. 构建镜像","slug":"_3-构建镜像","link":"#_3-构建镜像","children":[]},{"level":2,"title":"4. 运行容器","slug":"_4-运行容器","link":"#_4-运行容器","children":[]}],"readingTime":{"minutes":4.06,"words":1217},"filePathRelative":"Docker/Docker构建SpringBoot镜像.md","localizedDate":"2024年10月17日","excerpt":"\\n<h2>1. 什么是 Dockerfile ?</h2>\\n<figure><figcaption>img</figcaption></figure>\\n<p>Dockerfile 是用于构建 Docker 镜像的文本文件，其中包含了一系列的指令，每个指令对应着镜像构建过程中的一步操作。通过 Dockerfile，开发者可以定义镜像中包含的文件、环境变量、运行命令等配置。</p>\\n\x3c!--more--\x3e\\n<h2>2. 创建 Dockerfile</h2>\\n<p>在 <code>weblog-web</code> 入口模块下，创建一个名为 <code>Dockerfile</code> 的文件：</p>"}')}}]);