"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[50800],{66262:(a,i)=>{i.A=(a,i)=>{const n=a.__vccOpts||a;for(const[a,e]of i)n[a]=e;return n}},18973:(a,i,n)=>{n.r(i),n.d(i,{comp:()=>l,data:()=>r});var e=n(20641);const s={},l=(0,n(66262).A)(s,[["render",function(a,i){const n=(0,e.g2)("RouteLink");return(0,e.uX)(),(0,e.CE)("div",null,[i[2]||(i[2]=(0,e.Fv)('<h1 id="♻️-java-垃圾回收算法与分代机制-图解" tabindex="-1"><a class="header-anchor" href="#♻️-java-垃圾回收算法与分代机制-图解"><span>♻️ Java 垃圾回收算法与分代机制（图解）</span></a></h1><p>JVM 的垃圾回收机制是自动内存管理的核心，它通过回收不再被使用的对象，释放内存空间，防止内存泄漏。Java 中使用了多种垃圾回收算法，并在堆内存中采用“分代”设计提高性能。</p><hr><h2 id="📦-垃圾收集目标-回收不可达对象" tabindex="-1"><a class="header-anchor" href="#📦-垃圾收集目标-回收不可达对象"><span>📦 垃圾收集目标：回收不可达对象</span></a></h2><p>JVM 使用“可达性分析算法”判定对象是否存活。即：从一组称为 <strong>GC Roots</strong> 的根对象出发，能否通过引用链触达到目标对象。</p><p>如果对象不可达，就被视为“垃圾”，可被回收。</p><h3 id="🌱-常见-gc-roots-示例" tabindex="-1"><a class="header-anchor" href="#🌱-常见-gc-roots-示例"><span>🌱 常见 GC Roots 示例：</span></a></h3><ul><li>虚拟机栈中的引用（栈帧中的局部变量）</li><li>方法区中的静态变量</li><li>方法区中的常量引用</li><li>JNI 中的引用</li></ul><hr><h2 id="🧠-java-堆内存的分代结构" tabindex="-1"><a class="header-anchor" href="#🧠-java-堆内存的分代结构"><span>🧠 Java 堆内存的分代结构</span></a></h2><p>Java 堆被划分为两个主要部分：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>Java Heap</span></span>\n<span class="line"><span>├── Young Generation（新生代）</span></span>\n<span class="line"><span>│   ├── Eden（伊甸园）</span></span>\n<span class="line"><span>│   └── Survivor (S0/S1)</span></span>\n<span class="line"><span>└── Old Generation（老年代）</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><strong>新生代</strong>：对象刚创建时分配在此区，生命周期短</li><li><strong>老年代</strong>：经历多次 GC 后仍存活的对象被晋升到此区</li></ul><hr><h2 id="🔁-常见垃圾回收算法" tabindex="-1"><a class="header-anchor" href="#🔁-常见垃圾回收算法"><span>🔁 常见垃圾回收算法</span></a></h2><table><thead><tr><th>算法名称</th><th>描述</th></tr></thead><tbody><tr><td><strong>标记-清除</strong> (Mark-Sweep)</td><td>标记存活对象，清除未被标记的对象，可能产生碎片</td></tr><tr><td><strong>标记-整理</strong> (Mark-Compact)</td><td>标记后将存活对象移动到一端，避免碎片，但耗时较长</td></tr><tr><td><strong>复制算法</strong> (Copying)</td><td>将对象复制到另一块空闲区域，适合新生代，效率高</td></tr><tr><td><strong>分代收集</strong> (Generational)</td><td>根据对象年龄分代处理，新生代用复制，老年代用标记整理</td></tr></tbody></table><hr><h2 id="🔂-新生代垃圾回收-minor-gc" tabindex="-1"><a class="header-anchor" href="#🔂-新生代垃圾回收-minor-gc"><span>🔂 新生代垃圾回收（Minor GC）</span></a></h2><ul><li>使用复制算法（Eden → Survivor）</li><li>对象第一次创建在 Eden</li><li>GC 时将活跃对象复制到 S0/S1</li><li>多次 GC 后仍存活的对象晋升到老年代</li></ul><p>📌 快速、频繁，占用少量堆</p><hr><h2 id="🧹-老年代垃圾回收-major-full-gc" tabindex="-1"><a class="header-anchor" href="#🧹-老年代垃圾回收-major-full-gc"><span>🧹 老年代垃圾回收（Major/Full GC）</span></a></h2><ul><li>使用标记-清除或标记-整理算法</li><li>回收所有区域（包括新生代 + 老年代）</li><li>代价较高，暂停时间长</li></ul><p>📌 应尽量减少 Full GC 的触发频率</p><hr><h2 id="⚙️-对象晋升-tenuring" tabindex="-1"><a class="header-anchor" href="#⚙️-对象晋升-tenuring"><span>⚙️ 对象晋升（Tenuring）</span></a></h2><ul><li>每个对象在 Survivor 区域存活的时间被称为“年龄”</li><li>到达一定年龄阈值（默认 15），会晋升到老年代</li><li>大对象可能直接分配到老年代（避免复制）</li></ul><p>参数配置：</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">-XX:MaxTenuringThreshold</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">=15</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><hr><h2 id="📈-示例图解" tabindex="-1"><a class="header-anchor" href="#📈-示例图解"><span>📈 示例图解</span></a></h2><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>Eden (新对象) --GC--&gt; Survivor --多次GC--&gt; OldGen</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>+-------------------+   Minor GC    +-------------------+</span></span>\n<span class="line"><span>|       Eden        |   ========&gt;   |     Survivor S0    |</span></span>\n<span class="line"><span>+-------------------+               +-------------------+</span></span>\n<span class="line"><span>                                    ↓  若多次存活</span></span>\n<span class="line"><span>                             +--------------------+</span></span>\n<span class="line"><span>                             |    Old Generation   |</span></span>\n<span class="line"><span>                             +--------------------+</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="📝-小结" tabindex="-1"><a class="header-anchor" href="#📝-小结"><span>📝 小结</span></a></h2><ul><li>垃圾回收核心机制是“可达性分析”</li><li>新生代采用复制算法，老年代采用标记整理</li><li>分代收集模型大幅提升 GC 性能</li><li>Minor GC 轻量频繁，Major GC 成本高</li></ul><hr>',37)),(0,e.Lk)("p",null,[i[1]||(i[1]=(0,e.eW)("👉 下一篇推荐：")),(0,e.bF)(n,{to:"/JVM/%E4%B8%80%E5%91%BD%E9%80%9F%E9%80%9A/3.GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/3.2%20CMS%E3%80%81G1%E3%80%81ZGC%E3%80%81Shenandoah%20%E5%AF%B9%E6%AF%94.html"},{default:(0,e.k6)((()=>i[0]||(i[0]=[(0,e.eW)("3.2 CMS、G1、ZGC、Shenandoah 对比详解")]))),_:1})])])}]]),r=JSON.parse('{"path":"/JVM/%E4%B8%80%E5%91%BD%E9%80%9F%E9%80%9A/3.GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/3.1%20Java%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%B8%8E%E5%88%86%E4%BB%A3%E6%9C%BA%E5%88%B6.html","title":"3.1 Java 垃圾回收算法与分代机制（图解）","lang":"zh-CN","frontmatter":{"title":"3.1 Java 垃圾回收算法与分代机制（图解）","date":"2025-07-09T00:00:00.000Z","category":["JVM","GC","性能优化","博客专栏"],"gitInclude":[]},"headers":[{"level":2,"title":"📦 垃圾收集目标：回收不可达对象","slug":"📦-垃圾收集目标-回收不可达对象","link":"#📦-垃圾收集目标-回收不可达对象","children":[{"level":3,"title":"🌱 常见 GC Roots 示例：","slug":"🌱-常见-gc-roots-示例","link":"#🌱-常见-gc-roots-示例","children":[]}]},{"level":2,"title":"🧠 Java 堆内存的分代结构","slug":"🧠-java-堆内存的分代结构","link":"#🧠-java-堆内存的分代结构","children":[]},{"level":2,"title":"🔁 常见垃圾回收算法","slug":"🔁-常见垃圾回收算法","link":"#🔁-常见垃圾回收算法","children":[]},{"level":2,"title":"🔂 新生代垃圾回收（Minor GC）","slug":"🔂-新生代垃圾回收-minor-gc","link":"#🔂-新生代垃圾回收-minor-gc","children":[]},{"level":2,"title":"🧹 老年代垃圾回收（Major/Full GC）","slug":"🧹-老年代垃圾回收-major-full-gc","link":"#🧹-老年代垃圾回收-major-full-gc","children":[]},{"level":2,"title":"⚙️ 对象晋升（Tenuring）","slug":"⚙️-对象晋升-tenuring","link":"#⚙️-对象晋升-tenuring","children":[]},{"level":2,"title":"📈 示例图解","slug":"📈-示例图解","link":"#📈-示例图解","children":[]},{"level":2,"title":"📝 小结","slug":"📝-小结","link":"#📝-小结","children":[]}],"readingTime":{"minutes":2.44,"words":733},"filePathRelative":"JVM/一命速通/3.GC垃圾回收机制/3.1 Java 垃圾回收算法与分代机制.md","localizedDate":"2025年7月9日","excerpt":"\\n<p>JVM 的垃圾回收机制是自动内存管理的核心，它通过回收不再被使用的对象，释放内存空间，防止内存泄漏。Java 中使用了多种垃圾回收算法，并在堆内存中采用“分代”设计提高性能。</p>\\n<hr>\\n<h2>📦 垃圾收集目标：回收不可达对象</h2>\\n<p>JVM 使用“可达性分析算法”判定对象是否存活。即：从一组称为 <strong>GC Roots</strong> 的根对象出发，能否通过引用链触达到目标对象。</p>\\n<p>如果对象不可达，就被视为“垃圾”，可被回收。</p>\\n<h3>🌱 常见 GC Roots 示例：</h3>\\n<ul>\\n<li>虚拟机栈中的引用（栈帧中的局部变量）</li>\\n<li>方法区中的静态变量</li>\\n<li>方法区中的常量引用</li>\\n<li>JNI 中的引用</li>\\n</ul>"}')}}]);